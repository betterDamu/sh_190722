{"version":3,"sources":["main.js","lib\\commoner.js","lib\\cache.js","lib\\watcher.js","lib\\context.js","lib\\grep.js","lib\\reader.js","lib\\relative.js","lib\\output.js","package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ACHA,AFMA,AHSA;AELA,ADGA,AGTA,ACHA,AFMA,AHSA;AELA,ADGA,AGTA,ACHA,AFMA;ADIA,ADGA,AGTA,ACHA,ACHA,AHSA;ADIA,ADGA,AGTA,ACHA,ACHA,AHSA;ADIA,ADGA,AGTA,ACHA,ACHA,AHSA;ADIA,ADGA,AGTA,ACHA,ACHA,ACHA,AJYA;ADIA,ADGA,AGTA,ACHA,ACHA,ACHA,AJYA;ADIA,ADGA,AGTA,ACHA,ACHA,ACHA,AJYA;ADIA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA;ADIA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA;ADIA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA;ADIA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,ACHA,AGTA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AIZA,AFMA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,ACHA,AJYA,AMlBA;APsBA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;ADIA,ADGA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var path = require(\"path\");\nvar Commoner = require(\"./lib/commoner\").Commoner;\nexports.Commoner = Commoner;\n\nfunction defCallback(name) {\n    exports[name] = function() {\n        var commoner = new Commoner;\n        commoner[name].apply(commoner, arguments);\n        commoner.cliBuildP();\n        return commoner;\n    };\n}\n\ndefCallback(\"version\");\ndefCallback(\"resolve\");\ndefCallback(\"process\");\n","var assert = require(\"assert\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar Q = require(\"q\");\nvar iconv = require(\"iconv-lite\");\nvar ReadFileCache = require(\"./cache\").ReadFileCache;\nvar Watcher = require(\"./watcher\").Watcher;\nvar contextModule = require(\"./context\");\nvar BuildContext = contextModule.BuildContext;\nvar PreferredFileExtension = contextModule.PreferredFileExtension;\nvar ModuleReader = require(\"./reader\").ModuleReader;\nvar output = require(\"./output\");\nvar DirOutput = output.DirOutput;\nvar StdOutput = output.StdOutput;\nvar util = require(\"./util\");\nvar log = util.log;\nvar Ap = Array.prototype;\nvar each = Ap.forEach;\n\n// Better stack traces for promises.\nQ.longStackSupport = true;\n\nfunction Commoner() {\n    var self = this;\n    assert.ok(self instanceof Commoner);\n\n    Object.defineProperties(self, {\n        customVersion: { value: null, writable: true },\n        customOptions: { value: [] },\n        resolvers: { value: [] },\n        processors: { value: [] }\n    });\n}\n\nvar Cp = Commoner.prototype;\n\nCp.version = function(version) {\n    this.customVersion = version;\n    return this; // For chaining.\n};\n\n// Add custom command line options\nCp.option = function() {\n    this.customOptions.push(Ap.slice.call(arguments));\n    return this; // For chaining.\n};\n\n// A resolver is a function that takes a module identifier and returns\n// the unmodified source of the corresponding module, either as a string\n// or as a promise for a string.\nCp.resolve = function() {\n    each.call(arguments, function(resolver) {\n        assert.strictEqual(typeof resolver, \"function\");\n        this.resolvers.push(resolver);\n    }, this);\n\n    return this; // For chaining.\n};\n\n// A processor is a function that takes a module identifier and a string\n// representing the source of the module and returns a modified version of\n// the source, either as a string or as a promise for a string.\nCp.process = function(processor) {\n    each.call(arguments, function(processor) {\n        assert.strictEqual(typeof processor, \"function\");\n        this.processors.push(processor);\n    }, this);\n\n    return this; // For chaining.\n};\n\nCp.buildP = function(options, roots) {\n    var self = this;\n    var sourceDir = options.sourceDir;\n    var outputDir = options.outputDir;\n    var readFileCache = new ReadFileCache(sourceDir, options.sourceCharset);\n    var waiting = 0;\n    var output = outputDir\n        ? new DirOutput(outputDir)\n        : new StdOutput;\n\n    if (self.watch) {\n        new Watcher(readFileCache).on(\"changed\", function(file) {\n            log.err(file + \" changed; rebuilding...\", \"yellow\");\n            rebuild();\n        });\n    }\n\n    function outputModules(modules) {\n        // Note that output.outputModules comes pre-bound.\n        modules.forEach(output.outputModule);\n        return modules;\n    }\n\n    function finish(result) {\n        rebuild.ing = false;\n\n        if (waiting > 0) {\n            waiting = 0;\n            process.nextTick(rebuild);\n        }\n\n        return result;\n    }\n\n    function rebuild() {\n        if (rebuild.ing) {\n            waiting += 1;\n            return;\n        }\n\n        rebuild.ing = true;\n\n        var context = new BuildContext(options, readFileCache);\n\n        if (self.preferredFileExtension)\n            context.setPreferredFileExtension(\n                self.preferredFileExtension);\n\n        context.setCacheDirectory(self.cacheDir);\n\n        context.setIgnoreDependencies(self.ignoreDependencies);\n\n        context.setRelativize(self.relativize);\n\n        context.setUseProvidesModule(self.useProvidesModule);\n\n        return new ModuleReader(\n            context,\n            self.resolvers,\n            self.processors\n        ).readMultiP(context.expandIdsOrGlobsP(roots))\n            .then(context.ignoreDependencies ? pass : collectDepsP)\n            .then(outputModules)\n            .then(outputDir ? printModuleIds : pass)\n            .then(finish, function(err) {\n                log.err(err.stack);\n\n                if (!self.watch) {\n                    // If we're not building with --watch, throw the error\n                    // so that cliBuildP can call process.exit(-1).\n                    throw err;\n                }\n\n                finish();\n            });\n    }\n\n    return (\n      // If outputDir is falsy, we can't (and don't need to) mkdirP it.\n      outputDir ? util.mkdirP : Q\n    )(outputDir).then(rebuild);\n};\n\nfunction pass(modules) {\n    return modules;\n}\n\nfunction collectDepsP(rootModules) {\n    var modules = [];\n    var seenIds = {};\n\n    function traverse(module) {\n        if (seenIds.hasOwnProperty(module.id))\n            return Q(modules);\n        seenIds[module.id] = true;\n\n        return module.getRequiredP().then(function(reqs) {\n            return Q.all(reqs.map(traverse));\n        }).then(function() {\n            modules.push(module);\n            return modules;\n        });\n    }\n\n    return Q.all(rootModules.map(traverse)).then(\n        function() { return modules });\n}\n\nfunction printModuleIds(modules) {\n    log.out(JSON.stringify(modules.map(function(module) {\n        return module.id;\n    })));\n\n    return modules;\n}\n\nCp.forceResolve = function(forceId, source) {\n    this.resolvers.unshift(function(id) {\n        if (id === forceId)\n            return source;\n    });\n};\n\nCp.cliBuildP = function() {\n    var version = this.customVersion || require(\"../package.json\").version;\n    return Q.spread([this, version], cliBuildP);\n};\n\nfunction cliBuildP(commoner, version) {\n    var options = require(\"commander\");\n    var workingDir = process.cwd();\n    var sourceDir = workingDir;\n    var outputDir = null;\n    var roots;\n\n    options.version(version)\n        .usage(\"[options] <source directory> <output directory> [<module ID> [<module ID> ...]]\")\n        .option(\"-c, --config [file]\", \"JSON configuration file (no file or - means STDIN)\")\n        .option(\"-w, --watch\", \"Continually rebuild\")\n        .option(\"-x, --extension <js | coffee | ...>\",\n                \"File extension to assume when resolving module identifiers\")\n        .option(\"--relativize\", \"Rewrite all module identifiers to be relative\")\n        .option(\"--follow-requires\", \"Scan modules for required dependencies\")\n        .option(\"--use-provides-module\", \"Respect @providesModules pragma in files\")\n        .option(\"--cache-dir <directory>\", \"Alternate directory to use for disk cache\")\n        .option(\"--no-cache-dir\", \"Disable the disk cache\")\n        .option(\"--source-charset <utf8 | win1252 | ...>\",\n                \"Charset of source (default: utf8)\")\n        .option(\"--output-charset <utf8 | win1252 | ...>\",\n                \"Charset of output (default: utf8)\");\n\n    commoner.customOptions.forEach(function(customOption) {\n        options.option.apply(options, customOption);\n    });\n\n    options.parse(process.argv.slice(0));\n\n    var pfe = new PreferredFileExtension(options.extension || \"js\");\n\n    // TODO Decide whether passing options to buildP via instance\n    // variables is preferable to passing them as arguments.\n    commoner.preferredFileExtension = pfe;\n    commoner.watch = options.watch;\n    commoner.ignoreDependencies = !options.followRequires;\n    commoner.relativize = options.relativize;\n    commoner.useProvidesModule = options.useProvidesModule;\n    commoner.sourceCharset = normalizeCharset(options.sourceCharset);\n    commoner.outputCharset = normalizeCharset(options.outputCharset);\n\n    function fileToId(file) {\n        file = absolutePath(workingDir, file);\n        assert.ok(fs.statSync(file).isFile(), file);\n        return pfe.trim(path.relative(sourceDir, file));\n    }\n\n    var args = options.args.slice(0);\n    var argc = args.length;\n    if (argc === 0) {\n        if (options.config === true) {\n            log.err(\"Cannot read --config from STDIN when reading \" +\n                    \"source from STDIN\");\n            process.exit(-1);\n        }\n\n        sourceDir = workingDir;\n        outputDir = null;\n        roots = [\"<stdin>\"];\n        commoner.forceResolve(\"<stdin>\", util.readFromStdinP());\n\n        // Ignore dependencies because we wouldn't know how to find them.\n        commoner.ignoreDependencies = true;\n\n    } else {\n        var first = absolutePath(workingDir, args[0]);\n        var stats = fs.statSync(first);\n\n        if (argc === 1) {\n            var firstId = fileToId(first);\n            sourceDir = workingDir;\n            outputDir = null;\n            roots = [firstId];\n            commoner.forceResolve(\n                firstId,\n                util.readFileP(first, commoner.sourceCharset)\n            );\n\n            // Ignore dependencies because we wouldn't know how to find them.\n            commoner.ignoreDependencies = true;\n\n        } else if (stats.isDirectory(first)) {\n            sourceDir = first;\n            outputDir = absolutePath(workingDir, args[1]);\n            roots = args.slice(2);\n            if (roots.length === 0)\n                roots.push(commoner.preferredFileExtension.glob());\n\n        } else {\n            options.help();\n            process.exit(-1);\n        }\n    }\n\n    commoner.cacheDir = null;\n    if (options.cacheDir === false) {\n        // Received the --no-cache-dir option, so disable the disk cache.\n    } else if (typeof options.cacheDir === \"string\") {\n        commoner.cacheDir = absolutePath(workingDir, options.cacheDir);\n    } else if (outputDir) {\n        // The default cache directory lives inside the output directory.\n        commoner.cacheDir = path.join(outputDir, \".module-cache\");\n    }\n\n    var promise = getConfigP(\n        workingDir,\n        options.config\n    ).then(function(config) {\n        var cleanOptions = {};\n\n        options.options.forEach(function(option) {\n            var name = util.camelize(option.name());\n            if (options.hasOwnProperty(name)) {\n                cleanOptions[name] = options[name];\n            }\n        });\n\n        cleanOptions.version = version;\n        cleanOptions.config = config;\n        cleanOptions.sourceDir = sourceDir;\n        cleanOptions.outputDir = outputDir;\n        cleanOptions.sourceCharset = commoner.sourceCharset;\n        cleanOptions.outputCharset = commoner.outputCharset;\n\n        return commoner.buildP(cleanOptions, roots);\n    });\n\n    if (!commoner.watch) {\n        // If we're building from the command line without --watch, any\n        // build errors should immediately terminate the process with a\n        // non-zero error code.\n        promise = promise.catch(function(err) {\n            log.err(err.stack);\n            process.exit(-1);\n        });\n    }\n\n    return promise;\n}\n\nfunction normalizeCharset(charset) {\n    charset = charset\n        && charset.replace(/[- ]/g, \"\").toLowerCase()\n        || \"utf8\";\n\n    assert.ok(\n        iconv.encodingExists(charset),\n        \"Unrecognized charset: \" + charset\n    );\n\n    return charset;\n}\n\nfunction absolutePath(workingDir, pathToJoin) {\n    if (pathToJoin) {\n        workingDir = path.normalize(workingDir);\n        pathToJoin = path.normalize(pathToJoin);\n        // TODO: use path.isAbsolute when Node < 0.10 is unsupported\n        if (path.resolve(pathToJoin) !== pathToJoin) {\n            pathToJoin = path.join(workingDir, pathToJoin);\n        }\n    }\n    return pathToJoin;\n}\n\nfunction getConfigP(workingDir, configFile) {\n    if (typeof configFile === \"undefined\")\n        return Q({}); // Empty config.\n\n    if (configFile === true || // --config is present but has no argument\n        configFile === \"<stdin>\" ||\n        configFile === \"-\" ||\n        configFile === path.sep + path.join(\"dev\", \"stdin\")) {\n        return util.readJsonFromStdinP(\n            1000, // Time limit in milliseconds before warning displayed.\n            \"Expecting configuration from STDIN (pass --config <file> \" +\n                \"if stuck here)...\",\n            \"yellow\"\n        );\n    }\n\n    return util.readJsonFileP(absolutePath(workingDir, configFile));\n}\n\nexports.Commoner = Commoner;\n","var assert = require(\"assert\");\nvar Q = require(\"q\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar util = require(\"./util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * ReadFileCache is an EventEmitter subclass that caches file contents in\n * memory so that subsequent calls to readFileP return the same contents,\n * regardless of any changes in the underlying file.\n */\nfunction ReadFileCache(sourceDir, charset) {\n    assert.ok(this instanceof ReadFileCache);\n    assert.strictEqual(typeof sourceDir, \"string\");\n\n    this.charset = charset;\n\n    EventEmitter.call(this);\n\n    Object.defineProperties(this, {\n        sourceDir: { value: sourceDir },\n        sourceCache: { value: {} }\n    });\n}\n\nutil.inherits(ReadFileCache, EventEmitter);\nvar RFCp = ReadFileCache.prototype;\n\n/**\n * Read a file from the cache if possible, else from disk.\n */\nRFCp.readFileP = function(relativePath) {\n    var cache = this.sourceCache;\n\n    relativePath = path.normalize(relativePath);\n\n    return hasOwn.call(cache, relativePath)\n        ? cache[relativePath]\n        : this.noCacheReadFileP(relativePath);\n};\n\n/**\n * Read (or re-read) a file without using the cache.\n *\n * The new contents are stored in the cache for any future calls to\n * readFileP.\n */\nRFCp.noCacheReadFileP = function(relativePath) {\n    relativePath = path.normalize(relativePath);\n\n    var added = !hasOwn.call(this.sourceCache, relativePath);\n    var promise = this.sourceCache[relativePath] = util.readFileP(\n        path.join(this.sourceDir, relativePath), this.charset);\n\n    if (added) {\n        this.emit(\"added\", relativePath);\n    }\n\n    return promise;\n};\n\n/**\n * If you have reason to believe the contents of a file have changed, call\n * this method to re-read the file and compare the new contents to the\n * cached contents.  If the new contents differ from the contents of the\n * cache, the \"changed\" event will be emitted.\n */\nRFCp.reportPossiblyChanged = function(relativePath) {\n    var self = this;\n    var cached = self.readFileP(relativePath);\n    var fresh = self.noCacheReadFileP(relativePath);\n\n    Q.spread([\n        cached.catch(orNull),\n        fresh.catch(orNull)\n    ], function(oldData, newData) {\n        if (oldData !== newData) {\n            self.emit(\"changed\", relativePath);\n        }\n    }).done();\n};\n\n/**\n * Invoke the given callback for all files currently known to the\n * ReadFileCache, and invoke it in the future when any new files become\n * known to the cache.\n */\nRFCp.subscribe = function(callback, context) {\n    for (var relativePath in this.sourceCache) {\n        if (hasOwn.call(this.sourceCache, relativePath)) {\n            callback.call(context || null, relativePath);\n        }\n    }\n\n    this.on(\"added\", function(relativePath) {\n        callback.call(context || null, relativePath);\n    });\n};\n\n/**\n * Avoid memory leaks by removing listeners and emptying the cache.\n */\nRFCp.clear = function() {\n    this.removeAllListeners();\n\n    for (var relativePath in this.sourceCache) {\n        delete this.sourceCache[relativePath];\n    }\n};\n\nfunction orNull(err) {\n    return null;\n}\n\nexports.ReadFileCache = ReadFileCache;\n","var assert = require(\"assert\");\nvar path = require(\"path\");\nvar fs = require(\"graceful-fs\");\nvar spawn = require(\"child_process\").spawn;\nvar Q = require(\"q\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar ReadFileCache = require(\"./cache\").ReadFileCache;\nvar util = require(\"./util\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Watcher(readFileCache, persistent) {\n    assert.ok(this instanceof Watcher);\n    assert.ok(this instanceof EventEmitter);\n    assert.ok(readFileCache instanceof ReadFileCache);\n\n    // During tests (and only during tests), persistent === false so that\n    // the test suite can actually finish and exit.\n    if (typeof persistent === \"undefined\") {\n        persistent = true;\n    }\n\n    EventEmitter.call(this);\n\n    var self = this;\n    var sourceDir = readFileCache.sourceDir;\n    var dirWatcher = new DirWatcher(sourceDir, persistent);\n\n    Object.defineProperties(self, {\n        sourceDir: { value: sourceDir },\n        readFileCache: { value: readFileCache },\n        dirWatcher: { value: dirWatcher }\n    });\n\n    // Watch everything the readFileCache already knows about, and any new\n    // files added in the future.\n    readFileCache.subscribe(function(relativePath) {\n        self.watch(relativePath);\n    });\n\n    readFileCache.on(\"changed\", function(relativePath) {\n        self.emit(\"changed\", relativePath);\n    });\n\n    function handleDirEvent(event, relativePath) {\n        if (self.dirWatcher.ready) {\n            self.getFileHandler(relativePath)(event);\n        }\n    }\n\n    dirWatcher.on(\"added\", function(relativePath) {\n        handleDirEvent(\"added\", relativePath);\n    }).on(\"deleted\", function(relativePath) {\n        handleDirEvent(\"deleted\", relativePath);\n    }).on(\"changed\", function(relativePath) {\n        handleDirEvent(\"changed\", relativePath);\n    });\n}\n\nutil.inherits(Watcher, EventEmitter);\nvar Wp = Watcher.prototype;\n\nWp.watch = function(relativePath) {\n    this.dirWatcher.add(path.dirname(path.join(\n        this.sourceDir, relativePath)));\n};\n\nWp.readFileP = function(relativePath) {\n    return this.readFileCache.readFileP(relativePath);\n};\n\nWp.noCacheReadFileP = function(relativePath) {\n    return this.readFileCache.noCacheReadFileP(relativePath);\n};\n\nWp.getFileHandler = util.cachedMethod(function(relativePath) {\n    var self = this;\n    return function handler(event) {\n        self.readFileCache.reportPossiblyChanged(relativePath);\n    };\n});\n\nfunction orNull(err) {\n    return null;\n}\n\nWp.close = function() {\n    this.dirWatcher.close();\n};\n\n/**\n * DirWatcher code adapted from Jeffrey Lin's original implementation:\n * https://github.com/jeffreylin/jsx_transformer_fun/blob/master/dirWatcher.js\n *\n * Invariant: this only watches the dir inode, not the actual path.\n * That means the dir can't be renamed and swapped with another dir.\n */\nfunction DirWatcher(inputPath, persistent) {\n    assert.ok(this instanceof DirWatcher);\n\n    var self = this;\n    var absPath = path.resolve(inputPath);\n\n    if (!fs.statSync(absPath).isDirectory()) {\n        throw new Error(inputPath + \"is not a directory!\");\n    }\n\n    EventEmitter.call(self);\n\n    self.ready = false;\n    self.on(\"ready\", function(){\n        self.ready = true;\n    });\n\n    Object.defineProperties(self, {\n        // Map of absDirPaths to fs.FSWatcher objects from fs.watch().\n        watchers: { value: {} },\n        dirContents: { value: {} },\n        rootPath: { value: absPath },\n        persistent: { value: !!persistent }\n    });\n\n    process.nextTick(function() {\n        self.add(absPath);\n        self.emit(\"ready\");\n    });\n}\n\nutil.inherits(DirWatcher, EventEmitter);\nvar DWp = DirWatcher.prototype;\n\nDWp.add = function(absDirPath) {\n    var self = this;\n    if (hasOwn.call(self.watchers, absDirPath)) {\n        return;\n    }\n\n    self.watchers[absDirPath] = fs.watch(absDirPath, {\n        persistent: this.persistent\n    }).on(\"change\", function(event, filename) {\n        self.updateDirContents(absDirPath, event, filename);\n    });\n\n    // Update internal dir contents.\n    self.updateDirContents(absDirPath);\n\n    // Since we've never seen this path before, recursively add child\n    // directories of this path.  TODO: Don't do fs.readdirSync on the\n    // same dir twice in a row.  We already do an fs.statSync in\n    // this.updateDirContents() and we're just going to do another one\n    // here...\n    fs.readdirSync(absDirPath).forEach(function(filename) {\n        var filepath = path.join(absDirPath, filename);\n\n        // Look for directories.\n        if (fs.statSync(filepath).isDirectory()) {\n            self.add(filepath);\n        }\n    });\n};\n\nDWp.updateDirContents = function(absDirPath, event, fsWatchReportedFilename) {\n    var self = this;\n\n    if (!hasOwn.call(self.dirContents, absDirPath)) {\n        self.dirContents[absDirPath] = [];\n    }\n\n    var oldContents = self.dirContents[absDirPath];\n    var newContents = fs.readdirSync(absDirPath);\n\n    var deleted = {};\n    var added = {};\n\n    oldContents.forEach(function(filename) {\n        deleted[filename] = true;\n    });\n\n    newContents.forEach(function(filename) {\n        if (hasOwn.call(deleted, filename)) {\n            delete deleted[filename];\n        } else {\n            added[filename] = true;\n        }\n    });\n\n    var deletedNames = Object.keys(deleted);\n    deletedNames.forEach(function(filename) {\n        self.emit(\n            \"deleted\",\n            path.relative(\n                self.rootPath,\n                path.join(absDirPath, filename)\n            )\n        );\n    });\n\n    var addedNames = Object.keys(added);\n    addedNames.forEach(function(filename) {\n        self.emit(\n            \"added\",\n            path.relative(\n                self.rootPath,\n                path.join(absDirPath, filename)\n            )\n        );\n    });\n\n    // So changed is not deleted or added?\n    if (fsWatchReportedFilename &&\n        !hasOwn.call(deleted, fsWatchReportedFilename) &&\n        !hasOwn.call(added, fsWatchReportedFilename))\n    {\n        self.emit(\n            \"changed\",\n            path.relative(\n                self.rootPath,\n                path.join(absDirPath, fsWatchReportedFilename)\n            )\n        );\n    }\n\n    // If any of the things removed were directories, remove their watchers.\n    // If a dir was moved, hopefully two changed events fired?\n    //  1) event in dir where it was removed\n    //  2) event in dir where it was moved to (added)\n    deletedNames.forEach(function(filename) {\n        var filepath = path.join(absDirPath, filename);\n        delete self.dirContents[filepath];\n        delete self.watchers[filepath];\n    });\n\n    // if any of the things added were directories, recursively deal with them\n    addedNames.forEach(function(filename) {\n        var filepath = path.join(absDirPath, filename);\n        if (fs.existsSync(filepath) &&\n            fs.statSync(filepath).isDirectory())\n        {\n            self.add(filepath);\n            // mighttttttt need a self.updateDirContents() here in case\n            // we're somehow adding a path that replaces another one...?\n        }\n    });\n\n    // Update state of internal dir contents.\n    self.dirContents[absDirPath] = newContents;\n};\n\nDWp.close = function() {\n    var watchers = this.watchers;\n    Object.keys(watchers).forEach(function(filename) {\n        watchers[filename].close();\n    });\n};\n\nexports.Watcher = Watcher;\n","var assert = require(\"assert\");\nvar path = require(\"path\");\nvar Q = require(\"q\");\nvar util = require(\"./util\");\nvar spawn = require(\"child_process\").spawn;\nvar ReadFileCache = require(\"./cache\").ReadFileCache;\nvar grepP = require(\"./grep\");\nvar glob = require(\"glob\");\nvar env = process.env;\n\nfunction BuildContext(options, readFileCache) {\n    var self = this;\n    assert.ok(self instanceof BuildContext);\n    assert.ok(readFileCache instanceof ReadFileCache);\n\n    if (options) {\n        assert.strictEqual(typeof options, \"object\");\n    } else {\n        options = {};\n    }\n\n    Object.freeze(options);\n\n    Object.defineProperties(self, {\n        readFileCache: { value: readFileCache },\n        config: { value: options.config },\n        options: { value: options },\n        optionsHash: { value: util.deepHash(options) }\n    });\n}\n\nvar BCp = BuildContext.prototype;\n\nBCp.makePromise = function(callback, context) {\n    return util.makePromise(callback, context);\n};\n\nBCp.spawnP = function(command, args, kwargs) {\n    args = args || [];\n    kwargs = kwargs || {};\n\n    var deferred = Q.defer();\n\n    var outs = [];\n    var errs = [];\n\n    var options = {\n        stdio: \"pipe\",\n        env: env\n    };\n\n    if (kwargs.cwd) {\n        options.cwd = kwargs.cwd;\n    }\n\n    var child = spawn(command, args, options);\n\n    child.stdout.on(\"data\", function(data) {\n        outs.push(data);\n    });\n\n    child.stderr.on(\"data\", function(data) {\n        errs.push(data);\n    });\n\n    child.on(\"close\", function(code) {\n        if (errs.length > 0 || code !== 0) {\n            var err = {\n                code: code,\n                text: errs.join(\"\")\n            };\n        }\n\n        deferred.resolve([err, outs.join(\"\")]);\n    });\n\n    var stdin = kwargs && kwargs.stdin;\n    if (stdin) {\n        child.stdin.end(stdin);\n    }\n\n    return deferred.promise;\n};\n\nBCp.setIgnoreDependencies = function(value) {\n    Object.defineProperty(this, \"ignoreDependencies\", {\n        value: !!value\n    });\n};\n\n// This default can be overridden by individual BuildContext instances.\nBCp.setIgnoreDependencies(false);\n\nBCp.setRelativize = function(value) {\n    Object.defineProperty(this, \"relativize\", {\n        value: !!value\n    });\n};\n\n// This default can be overridden by individual BuildContext instances.\nBCp.setRelativize(false);\n\nBCp.setUseProvidesModule = function(value) {\n    Object.defineProperty(this, \"useProvidesModule\", {\n        value: !!value\n    });\n};\n\n// This default can be overridden by individual BuildContext instances.\nBCp.setUseProvidesModule(false);\n\nBCp.setCacheDirectory = function(dir) {\n    if (!dir) {\n        // Disable the cache directory.\n    } else {\n        assert.strictEqual(typeof dir, \"string\");\n    }\n\n    Object.defineProperty(this, \"cacheDir\", {\n        value: dir || null\n    });\n};\n\n// This default can be overridden by individual BuildContext instances.\nBCp.setCacheDirectory(null);\n\nfunction PreferredFileExtension(ext) {\n    assert.strictEqual(typeof ext, \"string\");\n    assert.ok(this instanceof PreferredFileExtension);\n    Object.defineProperty(this, \"extension\", {\n        value: ext.toLowerCase()\n    });\n}\n\nvar PFEp = PreferredFileExtension.prototype;\n\nPFEp.check = function(file) {\n    return file.split(\".\").pop().toLowerCase() === this.extension;\n};\n\nPFEp.trim = function(file) {\n    if (this.check(file)) {\n        var len = file.length;\n        var extLen = 1 + this.extension.length;\n        file = file.slice(0, len - extLen);\n    }\n    return file;\n};\n\nPFEp.glob = function() {\n    return \"**/*.\" + this.extension;\n};\n\nexports.PreferredFileExtension = PreferredFileExtension;\n\nBCp.setPreferredFileExtension = function(pfe) {\n    assert.ok(pfe instanceof PreferredFileExtension);\n    Object.defineProperty(this, \"preferredFileExtension\", { value: pfe });\n};\n\nBCp.setPreferredFileExtension(new PreferredFileExtension(\"js\"));\n\nBCp.expandIdsOrGlobsP = function(idsOrGlobs) {\n    var context = this;\n\n    return Q.all(\n        idsOrGlobs.map(this.expandSingleIdOrGlobP, this)\n    ).then(function(listOfListsOfIDs) {\n        var result = [];\n        var seen = {};\n\n        util.flatten(listOfListsOfIDs).forEach(function(id) {\n            if (!seen.hasOwnProperty(id)) {\n                seen[id] = true;\n                if (util.isValidModuleId(id))\n                    result.push(id);\n            }\n        });\n\n        return result;\n    });\n};\n\nBCp.expandSingleIdOrGlobP = function(idOrGlob) {\n    var context = this;\n\n    return util.makePromise(function(callback) {\n        // If idOrGlob already looks like an acceptable identifier, don't\n        // try to expand it.\n        if (util.isValidModuleId(idOrGlob)) {\n            callback(null, [idOrGlob]);\n            return;\n        }\n\n        glob(idOrGlob, {\n            cwd: context.readFileCache.sourceDir\n        }, function(err, files) {\n            if (err) {\n                callback(err);\n            } else {\n                callback(null, files.filter(function(file) {\n                    return !context.isHiddenFile(file);\n                }).map(function(file) {\n                    return context.preferredFileExtension.trim(file);\n                }));\n            }\n        });\n    });\n};\n\nBCp.readModuleP = function(id) {\n    return this.readFileCache.readFileP(\n        id + \".\" + this.preferredFileExtension.extension\n    );\n};\n\nBCp.readFileP = function(file) {\n    return this.readFileCache.readFileP(file);\n};\n\n// Text editors such as VIM and Emacs often create temporary swap files\n// that should be ignored.\nvar hiddenExp = /^\\.|~$/;\nBCp.isHiddenFile = function(file) {\n    return hiddenExp.test(path.basename(file));\n};\n\nBCp.getProvidedP = util.cachedMethod(function() {\n    var context = this;\n    var pattern = \"@providesModule\\\\s+\\\\S+\";\n\n    return grepP(\n        pattern,\n        context.readFileCache.sourceDir\n    ).then(function(pathToMatch) {\n        var idToPath = {};\n\n        Object.keys(pathToMatch).sort().forEach(function(path) {\n            if (context.isHiddenFile(path))\n                return;\n\n            var id = pathToMatch[path].split(/\\s+/).pop();\n\n            // If we're about to overwrite an existing module identifier,\n            // make sure the corresponding path ends with the preferred\n            // file extension. This allows @providesModule directives in\n            // .coffee files, for example, but prevents .js~ temporary\n            // files from taking precedence over actual .js files.\n            if (!idToPath.hasOwnProperty(id) ||\n                context.preferredFileExtension.check(path))\n                idToPath[id] = path;\n        });\n\n        return idToPath;\n    });\n});\n\nvar providesExp = /@providesModule[ ]+(\\S+)/;\n\nBCp.getProvidedId = function(source) {\n    var match = providesExp.exec(source);\n    return match && match[1];\n};\n\nexports.BuildContext = BuildContext;\n","var assert = require(\"assert\");\nvar path = require(\"path\");\nvar Q = require(\"q\");\nvar fs = require(\"graceful-fs\");\nvar util = require(\"./util\");\nvar readdir = Q.denodeify(fs.readdir);\nvar lstat = Q.denodeify(fs.lstat);\n\nfunction processDirP(pattern, dir) {\n    return readdir(dir).then(function(files) {\n        return Q.all(files.map(function(file) {\n            file = path.join(dir, file);\n            return lstat(file).then(function(stat) {\n                return stat.isDirectory()\n                    ? processDirP(pattern, file)\n                    : processFileP(pattern, file);\n            });\n        })).then(function(results) {\n            return util.flatten(results);\n        });\n    });\n}\n\nfunction processFileP(pattern, file) {\n    return util.readFileP(file).then(function(contents) {\n        var result = new RegExp(pattern, 'g').exec(contents);\n        return result ? [{\n            path: file,\n            match: result[0]\n        }] : [];\n    });\n}\n\nmodule.exports = function(pattern, sourceDir) {\n    assert.strictEqual(typeof pattern, \"string\");\n\n    return processDirP(pattern, sourceDir).then(function(results) {\n        var pathToMatch = {};\n\n        results.forEach(function(result) {\n            pathToMatch[path.relative(\n                sourceDir,\n                result.path\n            ).split(\"\\\\\").join(\"/\")] = result.match;\n        });\n        \n        return pathToMatch;\n    });\n};\n","var assert = require(\"assert\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar Q = require(\"q\");\nvar iconv = require(\"iconv-lite\");\nvar createHash = require(\"crypto\").createHash;\nvar detective = require(\"detective\");\nvar util = require(\"./util\");\nvar BuildContext = require(\"./context\").BuildContext;\nvar slice = Array.prototype.slice;\n\nfunction getRequiredIDs(id, source) {\n    var ids = {};\n    detective(source).forEach(function (dep) {\n        ids[path.normalize(path.join(id, \"..\", dep))] = true;\n    });\n    return Object.keys(ids);\n}\n\nfunction ModuleReader(context, resolvers, processors) {\n    var self = this;\n    assert.ok(self instanceof ModuleReader);\n    assert.ok(context instanceof BuildContext);\n    assert.ok(resolvers instanceof Array);\n    assert.ok(processors instanceof Array);\n\n    var hash = createHash(\"sha1\").update(context.optionsHash + \"\\0\");\n\n    function hashCallbacks(salt) {\n        hash.update(salt + \"\\0\");\n\n        var cbs = util.flatten(slice.call(arguments, 1));\n\n        cbs.forEach(function(cb) {\n            assert.strictEqual(typeof cb, \"function\");\n            hash.update(cb + \"\\0\");\n        });\n\n        return cbs;\n    }\n\n    resolvers = hashCallbacks(\"resolvers\", resolvers, warnMissingModule);\n\n    var procArgs = [processors];\n    if (context.relativize && !context.ignoreDependencies)\n        procArgs.push(require(\"./relative\").getProcessor(self));\n    processors = hashCallbacks(\"processors\", procArgs);\n\n    Object.defineProperties(self, {\n        context: { value: context },\n        idToHash: { value: {} },\n        resolvers: { value: resolvers },\n        processors: { value: processors },\n        salt: { value: hash.digest(\"hex\") }\n    });\n}\n\nModuleReader.prototype = {\n    getSourceP: util.cachedMethod(function(id) {\n        var context = this.context;\n        var copy = this.resolvers.slice(0).reverse();\n        assert.ok(copy.length > 0, \"no source resolvers registered\");\n\n        function tryNextResolverP() {\n            var resolve = copy.pop();\n\n            try {\n                var promise = Q(resolve && resolve.call(context, id));\n            } catch (e) {\n                promise = Q.reject(e);\n            }\n\n            return resolve ? promise.then(function(result) {\n                if (typeof result === \"string\")\n                    return result;\n                return tryNextResolverP();\n            }, tryNextResolverP) : promise;\n        }\n\n        return tryNextResolverP();\n    }),\n\n    getCanonicalIdP: util.cachedMethod(function(id) {\n        var reader = this;\n        if (reader.context.useProvidesModule) {\n            return reader.getSourceP(id).then(function(source) {\n                return reader.context.getProvidedId(source) || id;\n            });\n        } else {\n          return Q(id);\n        }\n    }),\n\n    readModuleP: util.cachedMethod(function(id) {\n        var reader = this;\n\n        return reader.getSourceP(id).then(function(source) {\n            if (reader.context.useProvidesModule) {\n                // If the source contains a @providesModule declaration, treat\n                // that declaration as canonical. Note that the Module object\n                // returned by readModuleP might have an .id property whose\n                // value differs from the original id parameter.\n                id = reader.context.getProvidedId(source) || id;\n            }\n\n            assert.strictEqual(typeof source, \"string\");\n\n            var hash = createHash(\"sha1\")\n                .update(\"module\\0\")\n                .update(id + \"\\0\")\n                .update(reader.salt + \"\\0\")\n                .update(source.length + \"\\0\" + source)\n                .digest(\"hex\");\n\n            if (reader.idToHash.hasOwnProperty(id)) {\n                // Ensure that the same module identifier is not\n                // provided by distinct modules.\n                assert.strictEqual(\n                    reader.idToHash[id], hash,\n                    \"more than one module named \" +\n                        JSON.stringify(id));\n            } else {\n                reader.idToHash[id] = hash;\n            }\n\n            return reader.buildModuleP(id, hash, source);\n        });\n    }),\n\n    buildModuleP: util.cachedMethod(function(id, hash, source) {\n        var reader = this;\n        return reader.processOutputP(\n            id, hash, source\n        ).then(function(output) {\n            return new Module(reader, id, hash, output);\n        });\n    }, function(id, hash, source) {\n        return hash;\n    }),\n\n    processOutputP: function(id, hash, source) {\n        var reader = this;\n        var cacheDir = reader.context.cacheDir;\n        var manifestDir = cacheDir && path.join(cacheDir, \"manifest\");\n        var charset = reader.context.options.outputCharset;\n\n        function buildP() {\n            var promise = Q(source);\n\n            reader.processors.forEach(function(build) {\n                promise = promise.then(function(input) {\n                    return util.waitForValuesP(\n                        build.call(reader.context, id, input)\n                    );\n                });\n            });\n\n            return promise.then(function(output) {\n                if (typeof output === \"string\") {\n                    output = { \".js\": output };\n                } else {\n                    assert.strictEqual(typeof output, \"object\");\n                }\n\n                return util.waitForValuesP(output);\n\n            }).then(function(output) {\n                util.log.err(\n                    \"built Module(\" + JSON.stringify(id) + \")\",\n                    \"cyan\"\n                );\n\n                return output;\n\n            }).catch(function(err) {\n                // Provide additional context for uncaught build errors.\n                util.log.err(\"Error while reading module \" + id + \":\");\n                throw err;\n            });\n        }\n\n        if (manifestDir) {\n            return util.mkdirP(manifestDir).then(function(manifestDir) {\n                var manifestFile = path.join(manifestDir, hash + \".json\");\n\n                return util.readJsonFileP(manifestFile).then(function(manifest) {\n                    Object.keys(manifest).forEach(function(key) {\n                        var cacheFile = path.join(cacheDir, manifest[key]);\n                        manifest[key] = util.readFileP(cacheFile);\n                    });\n\n                    return util.waitForValuesP(manifest, true);\n\n                }).catch(function(err) {\n                    return buildP().then(function(output) {\n                        var manifest = {};\n\n                        Object.keys(output).forEach(function(key) {\n                            var cacheFile = manifest[key] = hash + key;\n                            var fullPath = path.join(cacheDir, cacheFile);\n\n                            if (charset) {\n                                fs.writeFileSync(fullPath, iconv.encode(output[key], charset))\n                            } else {\n                                fs.writeFileSync(fullPath, output[key], \"utf8\");\n                            }\n                        });\n\n                        fs.writeFileSync(\n                            manifestFile,\n                            JSON.stringify(manifest),\n                            \"utf8\"\n                        );\n\n                        return output;\n                    });\n                });\n            });\n        }\n\n        return buildP();\n    },\n\n    readMultiP: function(ids) {\n        var reader = this;\n\n        return Q(ids).all().then(function(ids) {\n            if (ids.length === 0)\n                return ids; // Shortcut.\n\n            var modulePs = ids.map(reader.readModuleP, reader);\n            return Q(modulePs).all().then(function(modules) {\n                var seen = {};\n                var result = [];\n\n                modules.forEach(function(module) {\n                    if (!seen.hasOwnProperty(module.id)) {\n                        seen[module.id] = true;\n                        result.push(module);\n                    }\n                });\n\n                return result;\n            });\n        });\n    }\n};\n\nexports.ModuleReader = ModuleReader;\n\nfunction warnMissingModule(id) {\n    // A missing module may be a false positive and therefore does not warrant\n    // a fatal error, but a warning is certainly in order.\n    util.log.err(\n        \"unable to resolve module \" + JSON.stringify(id) + \"; false positive?\",\n        \"yellow\");\n\n    // Missing modules are installed as if they existed, but it's a run-time\n    // error if one is ever actually required.\n    var message = \"nonexistent module required: \" + id;\n    return \"throw new Error(\" + JSON.stringify(message) + \");\";\n}\n\nfunction Module(reader, id, hash, output) {\n    assert.ok(this instanceof Module);\n    assert.ok(reader instanceof ModuleReader);\n    assert.strictEqual(typeof output, \"object\");\n\n    var source = output[\".js\"];\n    assert.strictEqual(typeof source, \"string\");\n\n    Object.defineProperties(this, {\n        reader: { value: reader },\n        id: { value: id },\n        hash: { value: hash }, // TODO Remove?\n        deps: { value: getRequiredIDs(id, source) },\n        source: { value: source },\n        output: { value: output }\n    });\n}\n\nModule.prototype = {\n    getRequiredP: function() {\n        return this.reader.readMultiP(this.deps);\n    },\n\n    writeVersionP: function(outputDir) {\n        var id = this.id;\n        var hash = this.hash;\n        var output = this.output;\n        var cacheDir = this.reader.context.cacheDir;\n        var charset = this.reader.context.options.outputCharset;\n\n        return Q.all(Object.keys(output).map(function(key) {\n            var outputFile = path.join(outputDir, id + key);\n\n            function writeCopy() {\n                if (charset) {\n                    fs.writeFileSync(outputFile, iconv.encode(output[key], charset));\n                } else {\n                    fs.writeFileSync(outputFile, output[key], \"utf8\");\n                }\n                return outputFile;\n            }\n\n            if (cacheDir) {\n                var cacheFile = path.join(cacheDir, hash + key);\n                return util.linkP(cacheFile, outputFile)\n                    // If the hard linking fails, the cache directory\n                    // might be on a different device, so fall back to\n                    // writing a copy of the file (slightly slower).\n                    .catch(writeCopy);\n            }\n\n            return util.mkdirP(path.dirname(outputFile)).then(writeCopy);\n        }));\n    },\n\n    toString: function() {\n        return \"Module(\" + JSON.stringify(this.id) + \")\";\n    },\n\n    resolveId: function(id) {\n        return util.absolutize(this.id, id);\n    }\n};\n","var assert = require(\"assert\");\nvar Q = require(\"q\");\nvar path = require(\"path\");\nvar util = require(\"./util\");\nvar recast = require(\"recast\");\nvar n = recast.types.namedTypes;\n\nfunction Relativizer(reader) {\n    assert.ok(this instanceof Relativizer);\n    assert.ok(reader === null ||\n              reader instanceof require(\"./reader\").ModuleReader);\n\n    Object.defineProperties(this, {\n        reader: { value: reader }\n    });\n}\n\nvar Rp = Relativizer.prototype;\n\nexports.getProcessor = function(reader) {\n    var relativizer = new Relativizer(reader);\n    return function(id, input) {\n        return relativizer.processSourceP(id, input);\n    };\n};\n\nRp.processSourceP = function(id, input) {\n    var relativizer = this;\n    var output = typeof input === \"string\" ? {\n        \".js\": input\n    } : input;\n\n    return Q(output[\".js\"]).then(function(source) {\n        var promises = [];\n        var ast = recast.parse(source);\n\n        function fixRequireP(literal) {\n            promises.push(relativizer.relativizeP(\n                id, literal.value\n            ).then(function(newValue) {\n                return literal.value = newValue;\n            }));\n        }\n\n        recast.visit(ast, {\n            visitCallExpression: function(path) {\n                var args = path.value.arguments;\n                var callee = path.value.callee;\n\n                if (n.Identifier.check(callee) &&\n                    callee.name === \"require\" &&\n                    args.length === 1) {\n                    var arg = args[0];\n                    if (n.Literal.check(arg) &&\n                        typeof arg.value === \"string\") {\n                        fixRequireP(arg);\n                    }\n                }\n\n                this.traverse(path);\n            }\n        });\n\n        return Q.all(promises).then(function() {\n            output[\".js\"] = recast.print(ast).code;\n            return output;\n        });\n    });\n};\n\nRp.absolutizeP = function(moduleId, requiredId) {\n    requiredId = util.absolutize(moduleId, requiredId);\n\n    if (this.reader)\n        return this.reader.getCanonicalIdP(requiredId);\n\n    return Q(requiredId);\n};\n\nRp.relativizeP = function(moduleId, requiredId) {\n    return this.absolutizeP(\n        moduleId,\n        requiredId\n    ).then(function(absoluteId) {\n        return util.relativize(moduleId, absoluteId);\n    });\n};\n","var assert = require(\"assert\");\nvar util = require(\"./util\");\nvar log = util.log;\n\nfunction AbstractOutput() {\n    assert.ok(this instanceof AbstractOutput);\n    Object.defineProperties(this, {\n        outputModule: { value: this.outputModule.bind(this) }\n    });\n}\n\nvar AOp = AbstractOutput.prototype;\nexports.AbstractOutput = AbstractOutput;\n\nAOp.outputModule = function(module) {\n    throw new Error(\"not implemented\");\n};\n\nfunction StdOutput() {\n    assert.ok(this instanceof StdOutput);\n    AbstractOutput.call(this);\n}\n\nvar SOp = util.inherits(StdOutput, AbstractOutput);\nexports.StdOutput = StdOutput;\n\nSOp.outputModule = function(module) {\n    log.out(module.source);\n};\n\nfunction DirOutput(outputDir) {\n    assert.ok(this instanceof DirOutput);\n    assert.strictEqual(typeof outputDir, \"string\");\n    AbstractOutput.call(this);\n\n    Object.defineProperties(this, {\n        outputDir: { value: outputDir }\n    });\n}\n\nvar DOp = util.inherits(DirOutput, AbstractOutput);\nexports.DirOutput = DirOutput;\n\nDOp.outputModule = function(module) {\n    return module.writeVersionP(this.outputDir);\n};\n\nfunction TestOutput() {\n    assert.ok(this instanceof TestOutput);\n    AbstractOutput.call(this);\n}\n\nvar TOp = util.inherits(TestOutput, AbstractOutput);\nexports.TestOutput = TestOutput;\n\nTOp.outputModule = function(module) {\n    // Swallow any output.\n};\n","module.exports = {\n  \"_from\": \"commoner@^0.10.8\",\n  \"_id\": \"commoner@0.10.8\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha1-NPw2cs0kOT6LtH5wyqApOBH08sU=\",\n  \"_location\": \"/commoner\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"commoner@^0.10.8\",\n    \"name\": \"commoner\",\n    \"escapedName\": \"commoner\",\n    \"rawSpec\": \"^0.10.8\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^0.10.8\"\n  },\n  \"_requiredBy\": [\n    \"/regenerator\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/commoner/-/commoner-0.10.8.tgz\",\n  \"_shasum\": \"34fc3672cd24393e8bb47e70caa0293811f4f2c5\",\n  \"_spec\": \"commoner@^0.10.8\",\n  \"_where\": \"D:\\\\code\\\\WeChatCode\\\\sh_19_0722_3\\\\node_modules\\\\regenerator\",\n  \"author\": {\n    \"name\": \"Ben Newman\",\n    \"email\": \"ben@benjamn.com\"\n  },\n  \"bin\": {\n    \"commonize\": \"./bin/commonize\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/benjamn/commoner/issues\"\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {\n    \"commander\": \"^2.5.0\",\n    \"detective\": \"^4.3.1\",\n    \"glob\": \"^5.0.15\",\n    \"graceful-fs\": \"^4.1.2\",\n    \"iconv-lite\": \"^0.4.5\",\n    \"mkdirp\": \"^0.5.0\",\n    \"private\": \"^0.1.6\",\n    \"q\": \"^1.1.2\",\n    \"recast\": \"^0.11.17\"\n  },\n  \"deprecated\": false,\n  \"description\": \"Flexible tool for translating any dialect of JavaScript into Node-readable CommonJS modules\",\n  \"devDependencies\": {\n    \"mocha\": \"^2.3.3\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.8\"\n  },\n  \"files\": [\n    \"bin\",\n    \"lib\",\n    \"main.js\"\n  ],\n  \"homepage\": \"http://github.com/benjamn/commoner\",\n  \"keywords\": [\n    \"modules\",\n    \"require\",\n    \"commonjs\",\n    \"exports\",\n    \"commoner\",\n    \"browserify\",\n    \"stitch\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"main.js\",\n  \"name\": \"commoner\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/benjamn/commoner.git\"\n  },\n  \"scripts\": {\n    \"test\": \"rm -rf test/output ; node ./node_modules/mocha/bin/mocha --reporter spec test/run.js\"\n  },\n  \"version\": \"0.10.8\"\n}\n"]}