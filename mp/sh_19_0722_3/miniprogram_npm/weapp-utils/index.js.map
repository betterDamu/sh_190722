{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["function getType(val) {\r\n    return Object.prototype.toString.call(val).replace(/^\\[object\\s(\\w+)\\]$/, '$1').toLowerCase();\r\n}\r\n\r\nfunction isNumber(val) {\r\n    return getType(val) === 'number'\r\n}\r\n\r\nfunction isString(val) {\r\n    return getType(val) === 'string'\r\n}\r\n\r\nfunction isBool(val) {\r\n    return getType(val) === 'boolean'\r\n}\r\n\r\nfunction isUndefined(val) {\r\n    return getType(val) === 'undefined'\r\n}\r\n\r\nfunction isNull(val) {\r\n    return getType(val) === 'null'\r\n}\r\n\r\nfunction isNullOrUndef(val) {\r\n    return isNull(val) || isUndefined(val)\r\n}\r\n\r\nfunction isUseless(val) {\r\n    return isNullOrUndef(val) || val === ''\r\n}\r\n\r\nfunction isDefined(val) {\r\n    return !isUndefined(val) && !isNull(val)\r\n}\r\n\r\nfunction isObject(val) {\r\n    return getType(val) === 'object'\r\n}\r\n\r\nfunction isFunction(val) {\r\n    return getType(val) === 'function'\r\n}\r\n\r\nfunction isArray(val) {\r\n    return isFunction(Array.isArray) ? Array.isArray(val) : getType(val) === 'array'\r\n}\r\n\r\nfunction isBasicType(val) {\r\n    return isNumber(val) || isString(val) || isBool(val) || isUndefined(val) || isNull(val)\r\n}\r\n\r\n// 暂时只用来判断String,Array,Object类型\r\nfunction isEmpty(val) {\r\n    let dataType = getType(val);\r\n    if (dataType === 'object') {\r\n        return Object.keys(val).length === 0\r\n    } else if (dataType === 'array' || dataType === 'string') {\r\n        return val.length === 0\r\n    }\r\n}\r\n\r\n// 深拷贝，此处不考虑Symbol,Map,Set,Function等数据类型\r\nfunction deepClone(obj) {\r\n    let newObj;\r\n    if (isObject(obj)) {\r\n        newObj = {};\r\n        Object.keys(obj).forEach(key => {\r\n            newObj[key] = deepClone(obj[key])\r\n        })\r\n    } else if (isArray(obj)) {\r\n        newObj = [];\r\n        obj.forEach(item => {\r\n            newObj.push(deepClone(item))\r\n        })\r\n    } else {\r\n        newObj = obj;\r\n    }\r\n    return newObj\r\n}\r\n\r\n// 比较值是否一样，如果是引用类型，会通过递归方式去比较值\r\nfunction isEqual(obj1, obj2) {\r\n    let [type1, type2] = [getType(obj1), getType(obj2)]\r\n    if (type1 === type2) {\r\n        if (isBasicType(obj1)) {\r\n            return obj1 === obj2\r\n        } else if (type1 === 'object') {\r\n            return Object.keys(obj1).every(key => {\r\n                return isEqual(obj1[key], obj2[key])\r\n            })\r\n        } else if (type1 === 'array') {\r\n            return obj1.every((item, index) => {\r\n                return isEqual(item, obj2[index])\r\n            })\r\n        } else if (type1 === 'function' || type1 === 'symbol') {\r\n            return obj1.toString() === obj2.toString();\r\n        } else if (type1 === 'map') {\r\n            let handledKeys1 = Array.from(obj1.keys())\r\n            let handledKeys2 = Array.from(obj2.keys())\r\n            return handledKeys1.length === handledKeys2.length && handledKeys1.every(key => isEqual(obj1.get(key), obj2.get(key)))\r\n        } else if (type1 === 'set') {\r\n            let handledArray1 = Array.from(obj1.values())\r\n            let handledArray2 = Array.from(obj2.values())\r\n            return handledArray1.length === handledArray2.length && handledArray1.every((item, index) => isEqual(item, handledArray2[index]))\r\n        } else {\r\n            // 未知类型\r\n            return false;\r\n        }\r\n    } else {\r\n        // 类型不一致，无需比较\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction contains(obj, item) {\r\n    let dataType = getType(obj);\r\n    let containFlag = false;\r\n    if (dataType === 'object') {\r\n        let keys = Object.keys(obj)\r\n        for (let index = 0; index < keys.length; index++) {\r\n            if (isEqual(keys[index], item)) {\r\n                containFlag = true;\r\n                break;\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n    } else if (dataType === 'array') {\r\n        for (let index = 0; index < obj.length; index++) {\r\n            if (isEqual(obj[index], item)) {\r\n                containFlag = true;\r\n                break;\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error('only support type of object or array!')\r\n    }\r\n    return containFlag;\r\n}\r\n\r\nfunction findIndex(arr, item) {\r\n    let targetIndex = -1;\r\n    for (let index = 0; index < arr.length; index++) {\r\n        if (isEqual(arr[index], item)) {\r\n            targetIndex = index;\r\n            break;\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    return targetIndex;\r\n}\r\n\r\n// 主要是用于处理ajax参数，此处不考虑Symbol,Map,Set,Function等数据类型\r\n// isStrict默认为false，过滤掉参数中的null,undefined；当isStrict为true时，会过滤掉空字符串\r\n// checkArr默认为false，不会处理数组中的null,undefined，例如[1,undefined,null]这种数据不会做处理；当checkArr为true时，则会进行过滤，此时如果isStrict为true，还会过滤空字符串\r\nfunction dataFilter(obj, isStrict = false, checkArr = false) {\r\n    let objType = getType(obj);\r\n    if (objType === 'object') {\r\n        let newObj = {};\r\n        for (key in obj) {\r\n            let isDataValid = isStrict ? !isUseless(obj[key]) : isDefined(obj[key])\r\n            if (obj.hasOwnProperty(key) && isDataValid) {\r\n                newObj[key] = dataFilter(obj[key], isStrict, checkArr)\r\n            }\r\n        }\r\n        return newObj\r\n    } else if (objType === 'array') {\r\n        let newArr = [];\r\n        obj.forEach(item => {\r\n            let itemType = getType(item)\r\n            if (itemType === 'object' || itemType === 'array') {\r\n                newArr.push(dataFilter(item, isStrict, checkArr))\r\n            } else if (checkArr) {\r\n                let isDataValid = isStrict ? !isUseless(item) : isDefined(item)\r\n                if (isDataValid) {\r\n                    newArr.push(item)\r\n                }\r\n            } else {\r\n                newArr.push(item)\r\n            }\r\n        })\r\n        return newArr;\r\n    } else {\r\n        return obj\r\n    }\r\n}\r\n\r\n// 合并两个数据，用于支撑merge方法\r\nfunction mergeTwo(obj1, obj2) {\r\n    let dataType1 = getType(obj1);\r\n    let dataType2 = getType(obj2);\r\n    if (dataType1 === dataType2) {\r\n        // 如果合并的两个数据类型一致\r\n        if (dataType1 === 'object') {\r\n            // Object类型\r\n            Object.keys(obj2).forEach(key => {\r\n                // 遍历obj2的keys\r\n                if (obj1.hasOwnProperty(key)) {\r\n                    // 如果obj1包含obj2的key，采用合并策略\r\n                    obj1[key] = mergeTwo(obj1[key], obj2[key])\r\n                } else {\r\n                    // 不包含，则直接赋值\r\n                    obj1[key] = deepClone(obj2[key])\r\n                }\r\n            })\r\n        } else if (dataType1 === 'array') {\r\n            // Array类型\r\n            obj2.forEach(item => {\r\n                // 遍历obj2\r\n                if (contains(obj1, item)) {\r\n                    // 合并数组不能forEach按顺序遍历，只能判断是否包含，如果obj1包含item，采用合并策略\r\n                    let dataindex = findIndex(obj1, item);\r\n                    obj1[dataindex] = mergeTwo(obj1[dataindex], item)\r\n                } else {\r\n                    // 不包含，直接push\r\n                    obj1.push(deepClone(item))\r\n                }\r\n            })\r\n        } else if (isBasicType(obj1)) {\r\n            obj1 = obj2\r\n        }\r\n    } else {\r\n        // 数据类型不一致，取后面的数据值\r\n        obj1 = deepClone(obj2)\r\n    }\r\n    return obj1;\r\n}\r\n\r\n// 合并多个对象\r\nfunction merge(srcObj, ...objs) {\r\n    let srcObjType = getType(srcObj)\r\n    if (srcObjType === 'object' || srcObjType === 'array') {\r\n        let isSameType = objs.every(item => {\r\n            return getType(item) === srcObjType\r\n        })\r\n        if (isSameType) {\r\n            // 是同样的类型，进行合并操作\r\n            if (srcObjType === 'object') {\r\n                // object\r\n                let params = {};\r\n                return [srcObj, ...objs].reduce((preVal, curVal) => {\r\n                    return mergeTwo(preVal, curVal)\r\n                }, {})\r\n            } else {\r\n                // array\r\n                let params = [];\r\n                return [srcObj, ...objs].reduce((preVal, curVal) => {\r\n                    return mergeTwo(preVal, curVal)\r\n                }, [])\r\n            }\r\n        } else {\r\n            // 类型不一致，直接深拷贝源对象\r\n            return deepClone(srcObj)\r\n        }\r\n    } else {\r\n        // 其他数据类型\r\n        throw new Error('only support type of object or array!');\r\n    }\r\n}\r\n\r\nfunction debounce(func, wait, options) {\r\n    var lastArgs,\r\n        lastThis,\r\n        maxWait,\r\n        result,\r\n        timerId,\r\n        lastCallTime,\r\n        lastInvokeTime = 0,\r\n        leading = false,\r\n        maxing = false,\r\n        trailing = true;\r\n\r\n    if (typeof func != 'function') {\r\n        throw new TypeError('first param must be function.');\r\n    }\r\n    wait = Number(wait) || 0;\r\n    if (isObject(options)) {\r\n        leading = !!options.leading;\r\n        maxing = 'maxWait' in options;\r\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\r\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n    }\r\n\r\n    function invokeFunc(time) {\r\n        var args = lastArgs,\r\n            thisArg = lastThis;\r\n\r\n        lastArgs = lastThis = undefined;\r\n        lastInvokeTime = time;\r\n        result = func.apply(thisArg, args);\r\n        return result;\r\n    }\r\n\r\n    function leadingEdge(time) {\r\n        // Reset any `maxWait` timer.\r\n        lastInvokeTime = time;\r\n        // Start the timer for the trailing edge.\r\n        timerId = setTimeout(timerExpired, wait);\r\n        // Invoke the leading edge.\r\n        return leading ? invokeFunc(time) : result;\r\n    }\r\n\r\n    function remainingWait(time) {\r\n        var timeSinceLastCall = time - lastCallTime,\r\n            timeSinceLastInvoke = time - lastInvokeTime,\r\n            timeWaiting = wait - timeSinceLastCall;\r\n\r\n        return maxing\r\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\r\n            : timeWaiting;\r\n    }\r\n\r\n    function shouldInvoke(time) {\r\n        var timeSinceLastCall = time - lastCallTime,\r\n            timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n        // Either this is the first call, activity has stopped and we're at the\r\n        // trailing edge, the system time has gone backwards and we're treating\r\n        // it as the trailing edge, or we've hit the `maxWait` limit.\r\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\r\n            (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\r\n    }\r\n\r\n    function timerExpired() {\r\n        var time = Date.now();\r\n        if (shouldInvoke(time)) {\r\n            return trailingEdge(time);\r\n        }\r\n        // Restart the timer.\r\n        timerId = setTimeout(timerExpired, remainingWait(time));\r\n    }\r\n\r\n    function trailingEdge(time) {\r\n        timerId = undefined;\r\n\r\n        // Only invoke if we have `lastArgs` which means `func` has been\r\n        // debounced at least once.\r\n        if (trailing && lastArgs) {\r\n            return invokeFunc(time);\r\n        }\r\n        lastArgs = lastThis = undefined;\r\n        return result;\r\n    }\r\n\r\n    function cancel() {\r\n        if (timerId !== undefined) {\r\n            clearTimeout(timerId);\r\n        }\r\n        lastInvokeTime = 0;\r\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n    }\r\n\r\n    function flush() {\r\n        return timerId === undefined ? result : trailingEdge(Date.now());\r\n    }\r\n\r\n    function debounced() {\r\n        var time = Date.now(),\r\n            isInvoking = shouldInvoke(time);\r\n\r\n        lastArgs = arguments;\r\n        lastThis = this;\r\n        lastCallTime = time;\r\n\r\n        if (isInvoking) {\r\n            if (timerId === undefined) {\r\n                return leadingEdge(lastCallTime);\r\n            }\r\n            if (maxing) {\r\n                // Handle invocations in a tight loop.\r\n                timerId = setTimeout(timerExpired, wait);\r\n                return invokeFunc(lastCallTime);\r\n            }\r\n        }\r\n        if (timerId === undefined) {\r\n            timerId = setTimeout(timerExpired, wait);\r\n        }\r\n        return result;\r\n    }\r\n    debounced.cancel = cancel;\r\n    debounced.flush = flush;\r\n    return debounced;\r\n}\r\n\r\nfunction throttle(func, wait, options) {\r\n    var leading = true,\r\n        trailing = true;\r\n\r\n    if (typeof func != 'function') {\r\n        throw new TypeError('the first param is not a function');\r\n    }\r\n    if (isObject(options)) {\r\n        leading = 'leading' in options ? !!options.leading : leading;\r\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n    }\r\n    return debounce(func, wait, {\r\n        'leading': leading,\r\n        'maxWait': wait,\r\n        'trailing': trailing\r\n    });\r\n}\r\n\r\nmodule.exports = {\r\n    getType,\r\n    isNumber,\r\n    isString,\r\n    isBool,\r\n    isUndefined,\r\n    isNull,\r\n    isObject,\r\n    isFunction,\r\n    isArray,\r\n    isNullOrUndef,\r\n    isUseless,\r\n    isDefined,\r\n    isBasicType,\r\n    isEmpty,\r\n    deepClone,\r\n    isEqual,\r\n    contains,\r\n    findIndex,\r\n    dataFilter,\r\n    merge,\r\n    debounce,\r\n    throttle\r\n}\r\n"]}