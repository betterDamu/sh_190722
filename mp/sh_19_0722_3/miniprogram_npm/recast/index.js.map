{"version":3,"sources":["main.js","lib\\types.js","lib\\parser.js","lib\\patcher.js","lib\\lines.js","lib\\options.js","lib\\util.js","lib\\mapping.js","lib\\fast-path.js","lib\\comments.js","lib\\printer.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,AFMA,ACHA,AHSA;AIXA,ACHA,AHSA,ACHA,AHSA;AIXA,ACHA,AHSA,ACHA,AHSA;AIXA,ACHA,AHSA,ACHA,AHSA;AIXA,ACHA,AHSA,ACHA,AGTA,ANkBA;AIXA,ACHA,AHSA,ACHA,AGTA,ANkBA;AIXA,ACHA,AHSA,ACHA,AGTA,ANkBA;AIXA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AIXA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AIXA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AQvBA,AJYA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AQvBA,AJYA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AQvBA,AJYA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AGTA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA,ANkBA;AS1BA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AFMA,AHSA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,ALeA,ACHA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,AGTA,AJYA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA,AJYA;AGRA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;ADIA,ADGA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;AFOA,AJYA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,ADGA,AOrBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var types = require(\"./lib/types\");\nvar parse = require(\"./lib/parser\").parse;\nvar Printer = require(\"./lib/printer\").Printer;\n\nfunction print(node, options) {\n    return new Printer(options).print(node);\n}\n\nfunction prettyPrint(node, options) {\n    return new Printer(options).printGenerically(node);\n}\n\nfunction run(transformer, options) {\n    return runFile(process.argv[2], transformer, options);\n}\n\nfunction runFile(path, transformer, options) {\n    require(\"fs\").readFile(path, \"utf-8\", function(err, code) {\n        if (err) {\n            console.error(err);\n            return;\n        }\n\n        runString(code, transformer, options);\n    });\n}\n\nfunction defaultWriteback(output) {\n    process.stdout.write(output);\n}\n\nfunction runString(code, transformer, options) {\n    var writeback = options && options.writeback || defaultWriteback;\n    transformer(parse(code, options), function(node) {\n        writeback(print(node, options).code);\n    });\n}\n\nObject.defineProperties(exports, {\n    /**\n     * Parse a string of code into an augmented syntax tree suitable for\n     * arbitrary modification and reprinting.\n     */\n    parse: {\n        enumerable: true,\n        value: parse\n    },\n\n    /**\n     * Traverse and potentially modify an abstract syntax tree using a\n     * convenient visitor syntax:\n     *\n     *   recast.visit(ast, {\n     *     names: [],\n     *     visitIdentifier: function(path) {\n     *       var node = path.value;\n     *       this.visitor.names.push(node.name);\n     *       this.traverse(path);\n     *     }\n     *   });\n     */\n    visit: {\n        enumerable: true,\n        value: types.visit\n    },\n\n    /**\n     * Reprint a modified syntax tree using as much of the original source\n     * code as possible.\n     */\n    print: {\n        enumerable: true,\n        value: print\n    },\n\n    /**\n     * Print without attempting to reuse any original source code.\n     */\n    prettyPrint: {\n        enumerable: false,\n        value: prettyPrint\n    },\n\n    /**\n     * Customized version of require(\"ast-types\").\n     */\n    types: {\n        enumerable: false,\n        value: types\n    },\n\n    /**\n     * Convenient command-line interface (see e.g. example/add-braces).\n     */\n    run: {\n        enumerable: false,\n        value: run\n    }\n});\n","// This module was originally created so that Recast could add its own\n// custom types to the AST type system (in particular, the File type), but\n// those types are now incorporated into ast-types, so this module doesn't\n// have much to do anymore. Still, it might prove useful in the future.\nmodule.exports = require(\"ast-types\");\n","var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar n = types.namedTypes;\nvar b = types.builders;\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isFunction = types.builtInTypes.function;\nvar Patcher = require(\"./patcher\").Patcher;\nvar normalizeOptions = require(\"./options\").normalize;\nvar fromString = require(\"./lines\").fromString;\nvar attachComments = require(\"./comments\").attach;\nvar util = require(\"./util\");\n\nexports.parse = function parse(source, options) {\n  options = normalizeOptions(options);\n\n  var lines = fromString(source, options);\n\n  var sourceWithoutTabs = lines.toString({\n    tabWidth: options.tabWidth,\n    reuseWhitespace: false,\n    useTabs: false\n  });\n\n  var comments = [];\n  var program = options.parser.parse(sourceWithoutTabs, {\n    jsx: true,\n    loc: true,\n    locations: true,\n    range: options.range,\n    comment: true,\n    onComment: comments,\n    tolerant: options.tolerant,\n    ecmaVersion: 6,\n    sourceType: 'module'\n  });\n\n  // If the source was empty, some parsers give loc.{start,end}.line\n  // values of 0, instead of the minimum of 1.\n  util.fixFaultyLocations(program, lines);\n\n  program.loc = program.loc || {\n    start: lines.firstPos(),\n    end: lines.lastPos()\n  };\n\n  program.loc.lines = lines;\n  program.loc.indent = 0;\n\n  // Expand the Program node's .loc to include all comments, since\n  // typically its .loc.start and .loc.end will coincide with those of the\n  // first and last statements, respectively, excluding any comments that\n  // fall outside that region.\n  var trueProgramLoc = util.getTrueLoc(program, lines);\n  program.loc.start = trueProgramLoc.start;\n  program.loc.end = trueProgramLoc.end;\n\n  if (program.comments) {\n    comments = program.comments;\n    delete program.comments;\n  }\n\n  // In order to ensure we reprint leading and trailing program comments,\n  // wrap the original Program node with a File node.\n  var file = program;\n  if (file.type === \"Program\") {\n    var file = b.file(program, options.sourceFileName || null);\n    file.loc = {\n      lines: lines,\n      indent: 0,\n      start: lines.firstPos(),\n      end: lines.lastPos()\n    };\n  } else if (file.type === \"File\") {\n    program = file.program;\n  }\n\n  // Passing file.program here instead of just file means that initial\n  // comments will be attached to program.body[0] instead of program.\n  attachComments(\n    comments,\n    program.body.length ? file.program : file,\n    lines\n  );\n\n  // Return a copy of the original AST so that any changes made may be\n  // compared to the original.\n  return new TreeCopier(lines).copy(file);\n};\n\nfunction TreeCopier(lines) {\n  assert.ok(this instanceof TreeCopier);\n  this.lines = lines;\n  this.indent = 0;\n}\n\nvar TCp = TreeCopier.prototype;\n\nTCp.copy = function(node) {\n  if (isArray.check(node)) {\n    return node.map(this.copy, this);\n  }\n\n  if (!isObject.check(node)) {\n    return node;\n  }\n\n  util.fixFaultyLocations(node, this.lines);\n\n  var copy = Object.create(Object.getPrototypeOf(node), {\n    original: { // Provide a link from the copy to the original.\n      value: node,\n      configurable: false,\n      enumerable: false,\n      writable: true\n    }\n  });\n\n  var loc = node.loc;\n  var oldIndent = this.indent;\n  var newIndent = oldIndent;\n\n  if (loc) {\n    // When node is a comment, we set node.loc.indent to\n    // node.loc.start.column so that, when/if we print the comment by\n    // itself, we can strip that much whitespace from the left margin of\n    // the comment. This only really matters for multiline Block comments,\n    // but it doesn't hurt for Line comments.\n    if (node.type === \"Block\" || node.type === \"Line\" ||\n        node.type === \"CommentBlock\" || node.type === \"CommentLine\" ||\n        this.lines.isPrecededOnlyByWhitespace(loc.start)) {\n      newIndent = this.indent = loc.start.column;\n    }\n\n    loc.lines = this.lines;\n    loc.indent = newIndent;\n  }\n\n  var keys = Object.keys(node);\n  var keyCount = keys.length;\n  for (var i = 0; i < keyCount; ++i) {\n    var key = keys[i];\n    if (key === \"loc\") {\n      copy[key] = node[key];\n    } else if (key === \"tokens\" &&\n               node.type === \"File\") {\n      // Preserve file.tokens (uncopied) in case client code cares about\n      // it, even though Recast ignores it when reprinting.\n      copy[key] = node[key];\n    } else {\n      copy[key] = this.copy(node[key]);\n    }\n  }\n\n  this.indent = oldIndent;\n\n  return copy;\n};\n","var assert = require(\"assert\");\nvar linesModule = require(\"./lines\");\nvar types = require(\"./types\");\nvar getFieldValue = types.getFieldValue;\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar util = require(\"./util\");\nvar comparePos = util.comparePos;\nvar FastPath = require(\"./fast-path\");\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\n\nfunction Patcher(lines) {\n    assert.ok(this instanceof Patcher);\n    assert.ok(lines instanceof linesModule.Lines);\n\n    var self = this,\n        replacements = [];\n\n    self.replace = function(loc, lines) {\n        if (isString.check(lines))\n            lines = linesModule.fromString(lines);\n\n        replacements.push({\n            lines: lines,\n            start: loc.start,\n            end: loc.end\n        });\n    };\n\n    self.get = function(loc) {\n        // If no location is provided, return the complete Lines object.\n        loc = loc || {\n            start: { line: 1, column: 0 },\n            end: { line: lines.length,\n                   column: lines.getLineLength(lines.length) }\n        };\n\n        var sliceFrom = loc.start,\n            toConcat = [];\n\n        function pushSlice(from, to) {\n            assert.ok(comparePos(from, to) <= 0);\n            toConcat.push(lines.slice(from, to));\n        }\n\n        replacements.sort(function(a, b) {\n            return comparePos(a.start, b.start);\n        }).forEach(function(rep) {\n            if (comparePos(sliceFrom, rep.start) > 0) {\n                // Ignore nested replacement ranges.\n            } else {\n                pushSlice(sliceFrom, rep.start);\n                toConcat.push(rep.lines);\n                sliceFrom = rep.end;\n            }\n        });\n\n        pushSlice(sliceFrom, loc.end);\n\n        return linesModule.concat(toConcat);\n    };\n}\nexports.Patcher = Patcher;\n\nvar Pp = Patcher.prototype;\n\nPp.tryToReprintComments = function(newNode, oldNode, print) {\n    var patcher = this;\n\n    if (!newNode.comments &&\n        !oldNode.comments) {\n        // We were (vacuously) able to reprint all the comments!\n        return true;\n    }\n\n    var newPath = FastPath.from(newNode);\n    var oldPath = FastPath.from(oldNode);\n\n    newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n    oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n\n    var reprints = [];\n    var ableToReprintComments =\n        findArrayReprints(newPath, oldPath, reprints);\n\n    // No need to pop anything from newPath.stack or oldPath.stack, since\n    // newPath and oldPath are fresh local variables.\n\n    if (ableToReprintComments && reprints.length > 0) {\n        reprints.forEach(function(reprint) {\n            var oldComment = reprint.oldPath.getValue();\n            assert.ok(oldComment.leading || oldComment.trailing);\n            patcher.replace(\n                oldComment.loc,\n                // Comments can't have .comments, so it doesn't matter\n                // whether we print with comments or without.\n                print(reprint.newPath).indentTail(oldComment.loc.indent)\n            );\n        });\n    }\n\n    return ableToReprintComments;\n};\n\n// Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\nfunction getSurroundingComments(node) {\n    var result = [];\n    if (node.comments &&\n        node.comments.length > 0) {\n        node.comments.forEach(function(comment) {\n            if (comment.leading || comment.trailing) {\n                result.push(comment);\n            }\n        });\n    }\n    return result;\n}\n\nPp.deleteComments = function(node) {\n    if (!node.comments) {\n        return;\n    }\n\n    var patcher = this;\n\n    node.comments.forEach(function(comment) {\n        if (comment.leading) {\n            // Delete leading comments along with any trailing whitespace\n            // they might have.\n            patcher.replace({\n                start: comment.loc.start,\n                end: node.loc.lines.skipSpaces(\n                    comment.loc.end, false, false)\n            }, \"\");\n\n        } else if (comment.trailing) {\n            // Delete trailing comments along with any leading whitespace\n            // they might have.\n            patcher.replace({\n                start: node.loc.lines.skipSpaces(\n                    comment.loc.start, true, false),\n                end: comment.loc.end\n            }, \"\");\n        }\n    });\n};\n\nexports.getReprinter = function(path) {\n    assert.ok(path instanceof FastPath);\n\n    // Make sure that this path refers specifically to a Node, rather than\n    // some non-Node subproperty of a Node.\n    var node = path.getValue();\n    if (!Printable.check(node))\n        return;\n\n    var orig = node.original;\n    var origLoc = orig && orig.loc;\n    var lines = origLoc && origLoc.lines;\n    var reprints = [];\n\n    if (!lines || !findReprints(path, reprints))\n        return;\n\n    return function(print) {\n        var patcher = new Patcher(lines);\n\n        reprints.forEach(function(reprint) {\n            var newNode = reprint.newPath.getValue();\n            var oldNode = reprint.oldPath.getValue();\n\n            SourceLocation.assert(oldNode.loc, true);\n\n            var needToPrintNewPathWithComments =\n                !patcher.tryToReprintComments(newNode, oldNode, print)\n\n            if (needToPrintNewPathWithComments) {\n                // Since we were not able to preserve all leading/trailing\n                // comments, we delete oldNode's comments, print newPath\n                // with comments, and then patch the resulting lines where\n                // oldNode used to be.\n                patcher.deleteComments(oldNode);\n            }\n\n            var newLines = print(\n                reprint.newPath,\n                needToPrintNewPathWithComments\n            ).indentTail(oldNode.loc.indent);\n\n            var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n            var nts = needsTrailingSpace(lines, oldNode.loc, newLines);\n\n            // If we try to replace the argument of a ReturnStatement like\n            // return\"asdf\" with e.g. a literal null expression, we run\n            // the risk of ending up with returnnull, so we need to add an\n            // extra leading space in situations where that might\n            // happen. Likewise for \"asdf\"in obj. See #170.\n            if (nls || nts) {\n                var newParts = [];\n                nls && newParts.push(\" \");\n                newParts.push(newLines);\n                nts && newParts.push(\" \");\n                newLines = linesModule.concat(newParts);\n            }\n\n            patcher.replace(oldNode.loc, newLines);\n        });\n\n        // Recall that origLoc is the .loc of an ancestor node that is\n        // guaranteed to contain all the reprinted nodes and comments.\n        return patcher.get(origLoc).indentTail(-orig.loc.indent);\n    };\n};\n\n// If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n    var posBeforeOldLoc = util.copyPos(oldLoc.start);\n\n    // The character just before the location occupied by oldNode.\n    var charBeforeOldLoc =\n        oldLines.prevPos(posBeforeOldLoc) &&\n        oldLines.charAt(posBeforeOldLoc);\n\n    // First character of the reprinted node.\n    var newFirstChar = newLines.charAt(newLines.firstPos());\n\n    return charBeforeOldLoc &&\n        riskyAdjoiningCharExp.test(charBeforeOldLoc) &&\n        newFirstChar &&\n        riskyAdjoiningCharExp.test(newFirstChar);\n}\n\n// If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n    // The character just after the location occupied by oldNode.\n    var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n\n    var newLastPos = newLines.lastPos();\n\n    // Last character of the reprinted node.\n    var newLastChar = newLines.prevPos(newLastPos) &&\n        newLines.charAt(newLastPos);\n\n    return newLastChar &&\n        riskyAdjoiningCharExp.test(newLastChar) &&\n        charAfterOldLoc &&\n        riskyAdjoiningCharExp.test(charAfterOldLoc);\n}\n\nfunction findReprints(newPath, reprints) {\n    var newNode = newPath.getValue();\n    Printable.assert(newNode);\n\n    var oldNode = newNode.original;\n    Printable.assert(oldNode);\n\n    assert.deepEqual(reprints, []);\n\n    if (newNode.type !== oldNode.type) {\n        return false;\n    }\n\n    var oldPath = new FastPath(oldNode);\n    var canReprint = findChildReprints(newPath, oldPath, reprints);\n\n    if (!canReprint) {\n        // Make absolutely sure the calling code does not attempt to reprint\n        // any nodes.\n        reprints.length = 0;\n    }\n\n    return canReprint;\n}\n\nfunction findAnyReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n\n    if (newNode === oldNode)\n        return true;\n\n    if (isArray.check(newNode))\n        return findArrayReprints(newPath, oldPath, reprints);\n\n    if (isObject.check(newNode))\n        return findObjectReprints(newPath, oldPath, reprints);\n\n    return false;\n}\n\nfunction findArrayReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    isArray.assert(newNode);\n    var len = newNode.length;\n\n    if (!(isArray.check(oldNode) &&\n          oldNode.length === len))\n        return false;\n\n    for (var i = 0; i < len; ++i) {\n        newPath.stack.push(i, newNode[i]);\n        oldPath.stack.push(i, oldNode[i]);\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findObjectReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    isObject.assert(newNode);\n\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n\n    var oldNode = oldPath.getValue();\n    if (!isObject.check(oldNode))\n        return false;\n\n    if (Printable.check(newNode)) {\n        if (!Printable.check(oldNode)) {\n            return false;\n        }\n\n        // Here we need to decide whether the reprinted code for newNode\n        // is appropriate for patching into the location of oldNode.\n\n        if (newNode.type === oldNode.type) {\n            var childReprints = [];\n\n            if (findChildReprints(newPath, oldPath, childReprints)) {\n                reprints.push.apply(reprints, childReprints);\n            } else if (oldNode.loc) {\n                // If we have no .loc information for oldNode, then we\n                // won't be able to reprint it.\n                reprints.push({\n                    oldPath: oldPath.copy(),\n                    newPath: newPath.copy()\n                });\n            } else {\n                return false;\n            }\n\n            return true;\n        }\n\n        if (Expression.check(newNode) &&\n            Expression.check(oldNode) &&\n            // If we have no .loc information for oldNode, then we won't\n            // be able to reprint it.\n            oldNode.loc) {\n\n            // If both nodes are subtypes of Expression, then we should be\n            // able to fill the location occupied by the old node with\n            // code printed for the new node with no ill consequences.\n            reprints.push({\n                oldPath: oldPath.copy(),\n                newPath: newPath.copy()\n            });\n\n            return true;\n        }\n\n        // The nodes have different types, and at least one of the types\n        // is not a subtype of the Expression type, so we cannot safely\n        // assume the nodes are syntactically interchangeable.\n        return false;\n    }\n\n    return findChildReprints(newPath, oldPath, reprints);\n}\n\n// This object is reused in hasOpeningParen and hasClosingParen to avoid\n// having to allocate a temporary object.\nvar reusablePos = { line: 1, column: 0 };\nvar nonSpaceExp = /\\S/;\n\nfunction hasOpeningParen(oldPath) {\n    var oldNode = oldPath.getValue();\n    var loc = oldNode.loc;\n    var lines = loc && loc.lines;\n\n    if (lines) {\n        var pos = reusablePos;\n        pos.line = loc.start.line;\n        pos.column = loc.start.column;\n\n        while (lines.prevPos(pos)) {\n            var ch = lines.charAt(pos);\n\n            if (ch === \"(\") {\n                // If we found an opening parenthesis but it occurred before\n                // the start of the original subtree for this reprinting, then\n                // we must not return true for hasOpeningParen(oldPath).\n                return comparePos(oldPath.getRootValue().loc.start, pos) <= 0;\n            }\n\n            if (nonSpaceExp.test(ch)) {\n                return false;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction hasClosingParen(oldPath) {\n    var oldNode = oldPath.getValue();\n    var loc = oldNode.loc;\n    var lines = loc && loc.lines;\n\n    if (lines) {\n        var pos = reusablePos;\n        pos.line = loc.end.line;\n        pos.column = loc.end.column;\n\n        do {\n            var ch = lines.charAt(pos);\n\n            if (ch === \")\") {\n                // If we found a closing parenthesis but it occurred after the\n                // end of the original subtree for this reprinting, then we\n                // must not return true for hasClosingParen(oldPath).\n                return comparePos(pos, oldPath.getRootValue().loc.end) <= 0;\n            }\n\n            if (nonSpaceExp.test(ch)) {\n                return false;\n            }\n\n        } while (lines.nextPos(pos));\n    }\n\n    return false;\n}\n\nfunction hasParens(oldPath) {\n    // This logic can technically be fooled if the node has parentheses\n    // but there are comments intervening between the parentheses and the\n    // node. In such cases the node will be harmlessly wrapped in an\n    // additional layer of parentheses.\n    return hasOpeningParen(oldPath) && hasClosingParen(oldPath);\n}\n\nfunction findChildReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n\n    isObject.assert(newNode);\n    isObject.assert(oldNode);\n\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n\n    // If this type of node cannot come lexically first in its enclosing\n    // statement (e.g. a function expression or object literal), and it\n    // seems to be doing so, then the only way we can ignore this problem\n    // and save ourselves from falling back to the pretty printer is if an\n    // opening parenthesis happens to precede the node.  For example,\n    // (function(){ ... }()); does not need to be reprinted, even though\n    // the FunctionExpression comes lexically first in the enclosing\n    // ExpressionStatement and fails the hasParens test, because the\n    // parent CallExpression passes the hasParens test. If we relied on\n    // the path.needsParens() && !hasParens(oldNode) check below, the\n    // absence of a closing parenthesis after the FunctionExpression would\n    // trigger pretty-printing unnecessarily.\n    if (!newPath.canBeFirstInStatement() &&\n        newPath.firstInStatement() &&\n        !hasOpeningParen(oldPath))\n        return false;\n\n    // If this node needs parentheses and will not be wrapped with\n    // parentheses when reprinted, then return false to skip reprinting\n    // and let it be printed generically.\n    if (newPath.needsParens(true) && !hasParens(oldPath)) {\n        return false;\n    }\n\n    var keys = util.getUnionOfKeys(oldNode, newNode);\n\n    if (oldNode.type === \"File\" ||\n        newNode.type === \"File\") {\n        // Don't bother traversing file.tokens, an often very large array\n        // returned by Babylon, and useless for our purposes.\n        delete keys.tokens;\n    }\n\n    // Don't bother traversing .loc objects looking for reprintable nodes.\n    delete keys.loc;\n\n    var originalReprintCount = reprints.length;\n\n    for (var k in keys) {\n        newPath.stack.push(k, types.getFieldValue(newNode, k));\n        oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n\n        if (!canReprint) {\n            return false;\n        }\n    }\n\n    // Return statements might end up running into ASI issues due to comments\n    // inserted deep within the tree, so reprint them if anything changed\n    // within them.\n    if (ReturnStatement.check(newPath.getNode()) &&\n        reprints.length > originalReprintCount) {\n        return false;\n    }\n\n    return true;\n}\n","var assert = require(\"assert\");\nvar sourceMap = require(\"source-map\");\nvar normalizeOptions = require(\"./options\").normalize;\nvar secretKey = require(\"private\").makeUniqueKey();\nvar types = require(\"./types\");\nvar isString = types.builtInTypes.string;\nvar comparePos = require(\"./util\").comparePos;\nvar Mapping = require(\"./mapping\");\n\n// Goals:\n// 1. Minimize new string creation.\n// 2. Keep (de)identation O(lines) time.\n// 3. Permit negative indentations.\n// 4. Enforce immutability.\n// 5. No newline characters.\n\nfunction getSecret(lines) {\n    return lines[secretKey];\n}\n\nfunction Lines(infos, sourceFileName) {\n    assert.ok(this instanceof Lines);\n    assert.ok(infos.length > 0);\n\n    if (sourceFileName) {\n        isString.assert(sourceFileName);\n    } else {\n        sourceFileName = null;\n    }\n\n    Object.defineProperty(this, secretKey, {\n        value: {\n            infos: infos,\n            mappings: [],\n            name: sourceFileName,\n            cachedSourceMap: null\n        }\n    });\n\n    if (sourceFileName) {\n        getSecret(this).mappings.push(new Mapping(this, {\n            start: this.firstPos(),\n            end: this.lastPos()\n        }));\n    }\n}\n\n// Exposed for instanceof checks. The fromString function should be used\n// to create new Lines objects.\nexports.Lines = Lines;\nvar Lp = Lines.prototype;\n\n// These properties used to be assigned to each new object in the Lines\n// constructor, but we can more efficiently stuff them into the secret and\n// let these lazy accessors compute their values on-the-fly.\nObject.defineProperties(Lp, {\n    length: {\n        get: function() {\n            return getSecret(this).infos.length;\n        }\n    },\n\n    name: {\n        get: function() {\n            return getSecret(this).name;\n        }\n    }\n});\n\nfunction copyLineInfo(info) {\n    return {\n        line: info.line,\n        indent: info.indent,\n        locked: info.locked,\n        sliceStart: info.sliceStart,\n        sliceEnd: info.sliceEnd\n    };\n}\n\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\n\nfunction countSpaces(spaces, tabWidth) {\n    var count = 0;\n    var len = spaces.length;\n\n    for (var i = 0; i < len; ++i) {\n        switch (spaces.charCodeAt(i)) {\n        case 9: // '\\t'\n            assert.strictEqual(typeof tabWidth, \"number\");\n            assert.ok(tabWidth > 0);\n\n            var next = Math.ceil(count / tabWidth) * tabWidth;\n            if (next === count) {\n                count += tabWidth;\n            } else {\n                count = next;\n            }\n\n            break;\n\n        case 11: // '\\v'\n        case 12: // '\\f'\n        case 13: // '\\r'\n        case 0xfeff: // zero-width non-breaking space\n            // These characters contribute nothing to indentation.\n            break;\n\n        case 32: // ' '\n        default: // Treat all other whitespace like ' '.\n            count += 1;\n            break;\n        }\n    }\n\n    return count;\n}\nexports.countSpaces = countSpaces;\n\nvar leadingSpaceExp = /^\\s*/;\n\n// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\nvar lineTerminatorSeqExp =\n    /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n\n/**\n * @param {Object} options - Options object that configures printing.\n */\nfunction fromString(string, options) {\n    if (string instanceof Lines)\n        return string;\n\n    string += \"\";\n\n    var tabWidth = options && options.tabWidth;\n    var tabless = string.indexOf(\"\\t\") < 0;\n    var locked = !! (options && options.locked);\n    var cacheable = !options && tabless && (string.length <= maxCacheKeyLen);\n\n    assert.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n\n    if (cacheable && hasOwn.call(fromStringCache, string))\n        return fromStringCache[string];\n\n    var lines = new Lines(string.split(lineTerminatorSeqExp).map(function(line) {\n        var spaces = leadingSpaceExp.exec(line)[0];\n        return {\n            line: line,\n            indent: countSpaces(spaces, tabWidth),\n            // Boolean indicating whether this line can be reindented.\n            locked: locked,\n            sliceStart: spaces.length,\n            sliceEnd: line.length\n        };\n    }), normalizeOptions(options).sourceFileName);\n\n    if (cacheable)\n        fromStringCache[string] = lines;\n\n    return lines;\n}\nexports.fromString = fromString;\n\nfunction isOnlyWhitespace(string) {\n    return !/\\S/.test(string);\n}\n\nLp.toString = function(options) {\n    return this.sliceString(this.firstPos(), this.lastPos(), options);\n};\n\nLp.getSourceMap = function(sourceMapName, sourceRoot) {\n    if (!sourceMapName) {\n        // Although we could make up a name or generate an anonymous\n        // source map, instead we assume that any consumer who does not\n        // provide a name does not actually want a source map.\n        return null;\n    }\n\n    var targetLines = this;\n\n    function updateJSON(json) {\n        json = json || {};\n\n        isString.assert(sourceMapName);\n        json.file = sourceMapName;\n\n        if (sourceRoot) {\n            isString.assert(sourceRoot);\n            json.sourceRoot = sourceRoot;\n        }\n\n        return json;\n    }\n\n    var secret = getSecret(targetLines);\n    if (secret.cachedSourceMap) {\n        // Since Lines objects are immutable, we can reuse any source map\n        // that was previously generated. Nevertheless, we return a new\n        // JSON object here to protect the cached source map from outside\n        // modification.\n        return updateJSON(secret.cachedSourceMap.toJSON());\n    }\n\n    var smg = new sourceMap.SourceMapGenerator(updateJSON());\n    var sourcesToContents = {};\n\n    secret.mappings.forEach(function(mapping) {\n        var sourceCursor = mapping.sourceLines.skipSpaces(\n            mapping.sourceLoc.start\n        ) || mapping.sourceLines.lastPos();\n\n        var targetCursor = targetLines.skipSpaces(\n            mapping.targetLoc.start\n        ) || targetLines.lastPos();\n\n        while (comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&\n               comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n\n            var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n            var targetChar = targetLines.charAt(targetCursor);\n            assert.strictEqual(sourceChar, targetChar);\n\n            var sourceName = mapping.sourceLines.name;\n\n            // Add mappings one character at a time for maximum resolution.\n            smg.addMapping({\n                source: sourceName,\n                original: { line: sourceCursor.line,\n                            column: sourceCursor.column },\n                generated: { line: targetCursor.line,\n                             column: targetCursor.column }\n            });\n\n            if (!hasOwn.call(sourcesToContents, sourceName)) {\n                var sourceContent = mapping.sourceLines.toString();\n                smg.setSourceContent(sourceName, sourceContent);\n                sourcesToContents[sourceName] = sourceContent;\n            }\n\n            targetLines.nextPos(targetCursor, true);\n            mapping.sourceLines.nextPos(sourceCursor, true);\n        }\n    });\n\n    secret.cachedSourceMap = smg;\n\n    return smg.toJSON();\n};\n\nLp.bootstrapCharAt = function(pos) {\n    assert.strictEqual(typeof pos, \"object\");\n    assert.strictEqual(typeof pos.line, \"number\");\n    assert.strictEqual(typeof pos.column, \"number\");\n\n    var line = pos.line,\n        column = pos.column,\n        strings = this.toString().split(lineTerminatorSeqExp),\n        string = strings[line - 1];\n\n    if (typeof string === \"undefined\")\n        return \"\";\n\n    if (column === string.length &&\n        line < strings.length)\n        return \"\\n\";\n\n    if (column >= string.length)\n        return \"\";\n\n    return string.charAt(column);\n};\n\nLp.charAt = function(pos) {\n    assert.strictEqual(typeof pos, \"object\");\n    assert.strictEqual(typeof pos.line, \"number\");\n    assert.strictEqual(typeof pos.column, \"number\");\n\n    var line = pos.line,\n        column = pos.column,\n        secret = getSecret(this),\n        infos = secret.infos,\n        info = infos[line - 1],\n        c = column;\n\n    if (typeof info === \"undefined\" || c < 0)\n        return \"\";\n\n    var indent = this.getIndentAt(line);\n    if (c < indent)\n        return \" \";\n\n    c += info.sliceStart - indent;\n\n    if (c === info.sliceEnd &&\n        line < this.length)\n        return \"\\n\";\n\n    if (c >= info.sliceEnd)\n        return \"\";\n\n    return info.line.charAt(c);\n};\n\nLp.stripMargin = function(width, skipFirstLine) {\n    if (width === 0)\n        return this;\n\n    assert.ok(width > 0, \"negative margin: \" + width);\n\n    if (skipFirstLine && this.length === 1)\n        return this;\n\n    var secret = getSecret(this);\n\n    var lines = new Lines(secret.infos.map(function(info, i) {\n        if (info.line && (i > 0 || !skipFirstLine)) {\n            info = copyLineInfo(info);\n            info.indent = Math.max(0, info.indent - width);\n        }\n        return info;\n    }));\n\n    if (secret.mappings.length > 0) {\n        var newMappings = getSecret(lines).mappings;\n        assert.strictEqual(newMappings.length, 0);\n        secret.mappings.forEach(function(mapping) {\n            newMappings.push(mapping.indent(width, skipFirstLine, true));\n        });\n    }\n\n    return lines;\n};\n\nLp.indent = function(by) {\n    if (by === 0)\n        return this;\n\n    var secret = getSecret(this);\n\n    var lines = new Lines(secret.infos.map(function(info) {\n        if (info.line && ! info.locked) {\n            info = copyLineInfo(info);\n            info.indent += by;\n        }\n        return info\n    }));\n\n    if (secret.mappings.length > 0) {\n        var newMappings = getSecret(lines).mappings;\n        assert.strictEqual(newMappings.length, 0);\n        secret.mappings.forEach(function(mapping) {\n            newMappings.push(mapping.indent(by));\n        });\n    }\n\n    return lines;\n};\n\nLp.indentTail = function(by) {\n    if (by === 0)\n        return this;\n\n    if (this.length < 2)\n        return this;\n\n    var secret = getSecret(this);\n\n    var lines = new Lines(secret.infos.map(function(info, i) {\n        if (i > 0 && info.line && ! info.locked) {\n            info = copyLineInfo(info);\n            info.indent += by;\n        }\n\n        return info;\n    }));\n\n    if (secret.mappings.length > 0) {\n        var newMappings = getSecret(lines).mappings;\n        assert.strictEqual(newMappings.length, 0);\n        secret.mappings.forEach(function(mapping) {\n            newMappings.push(mapping.indent(by, true));\n        });\n    }\n\n    return lines;\n};\n\nLp.lockIndentTail = function () {\n    if (this.length < 2) {\n        return this;\n    }\n\n    var infos = getSecret(this).infos;\n\n    return new Lines(infos.map(function (info, i) {\n        info = copyLineInfo(info);\n        info.locked = i > 0;\n        return info;\n    }));\n};\n\nLp.getIndentAt = function(line) {\n    assert.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n    var secret = getSecret(this),\n        info = secret.infos[line - 1];\n    return Math.max(info.indent, 0);\n};\n\nLp.guessTabWidth = function() {\n    var secret = getSecret(this);\n    if (hasOwn.call(secret, \"cachedTabWidth\")) {\n        return secret.cachedTabWidth;\n    }\n\n    var counts = []; // Sparse array.\n    var lastIndent = 0;\n\n    for (var line = 1, last = this.length; line <= last; ++line) {\n        var info = secret.infos[line - 1];\n        var sliced = info.line.slice(info.sliceStart, info.sliceEnd);\n\n        // Whitespace-only lines don't tell us much about the likely tab\n        // width of this code.\n        if (isOnlyWhitespace(sliced)) {\n            continue;\n        }\n\n        var diff = Math.abs(info.indent - lastIndent);\n        counts[diff] = ~~counts[diff] + 1;\n        lastIndent = info.indent;\n    }\n\n    var maxCount = -1;\n    var result = 2;\n\n    for (var tabWidth = 1;\n         tabWidth < counts.length;\n         tabWidth += 1) {\n        if (hasOwn.call(counts, tabWidth) &&\n            counts[tabWidth] > maxCount) {\n            maxCount = counts[tabWidth];\n            result = tabWidth;\n        }\n    }\n\n    return secret.cachedTabWidth = result;\n};\n\n// Determine if the list of lines has a first line that starts with a //\n// or /* comment. If this is the case, the code may need to be wrapped in\n// parens to avoid ASI issues.\nLp.startsWithComment = function () {\n    var secret = getSecret(this);\n    if (secret.infos.length === 0) {\n        return false;\n    }\n    var firstLineInfo = secret.infos[0],\n        sliceStart = firstLineInfo.sliceStart,\n        sliceEnd = firstLineInfo.sliceEnd,\n        firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n    return firstLine.length === 0 ||\n        firstLine.slice(0, 2) === \"//\" ||\n        firstLine.slice(0, 2) === \"/*\";\n};\n\nLp.isOnlyWhitespace = function() {\n    return isOnlyWhitespace(this.toString());\n};\n\nLp.isPrecededOnlyByWhitespace = function(pos) {\n    var secret = getSecret(this);\n    var info = secret.infos[pos.line - 1];\n    var indent = Math.max(info.indent, 0);\n\n    var diff = pos.column - indent;\n    if (diff <= 0) {\n        // If pos.column does not exceed the indentation amount, then\n        // there must be only whitespace before it.\n        return true;\n    }\n\n    var start = info.sliceStart;\n    var end = Math.min(start + diff, info.sliceEnd);\n    var prefix = info.line.slice(start, end);\n\n    return isOnlyWhitespace(prefix);\n};\n\nLp.getLineLength = function(line) {\n    var secret = getSecret(this),\n        info = secret.infos[line - 1];\n    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n};\n\nLp.nextPos = function(pos, skipSpaces) {\n    var l = Math.max(pos.line, 0),\n        c = Math.max(pos.column, 0);\n\n    if (c < this.getLineLength(l)) {\n        pos.column += 1;\n\n        return skipSpaces\n            ? !!this.skipSpaces(pos, false, true)\n            : true;\n    }\n\n    if (l < this.length) {\n        pos.line += 1;\n        pos.column = 0;\n\n        return skipSpaces\n            ? !!this.skipSpaces(pos, false, true)\n            : true;\n    }\n\n    return false;\n};\n\nLp.prevPos = function(pos, skipSpaces) {\n    var l = pos.line,\n        c = pos.column;\n\n    if (c < 1) {\n        l -= 1;\n\n        if (l < 1)\n            return false;\n\n        c = this.getLineLength(l);\n\n    } else {\n        c = Math.min(c - 1, this.getLineLength(l));\n    }\n\n    pos.line = l;\n    pos.column = c;\n\n    return skipSpaces\n        ? !!this.skipSpaces(pos, true, true)\n        : true;\n};\n\nLp.firstPos = function() {\n    // Trivial, but provided for completeness.\n    return { line: 1, column: 0 };\n};\n\nLp.lastPos = function() {\n    return {\n        line: this.length,\n        column: this.getLineLength(this.length)\n    };\n};\n\nLp.skipSpaces = function(pos, backward, modifyInPlace) {\n    if (pos) {\n        pos = modifyInPlace ? pos : {\n            line: pos.line,\n            column: pos.column\n        };\n    } else if (backward) {\n        pos = this.lastPos();\n    } else {\n        pos = this.firstPos();\n    }\n\n    if (backward) {\n        while (this.prevPos(pos)) {\n            if (!isOnlyWhitespace(this.charAt(pos)) &&\n                this.nextPos(pos)) {\n                return pos;\n            }\n        }\n\n        return null;\n\n    } else {\n        while (isOnlyWhitespace(this.charAt(pos))) {\n            if (!this.nextPos(pos)) {\n                return null;\n            }\n        }\n\n        return pos;\n    }\n};\n\nLp.trimLeft = function() {\n    var pos = this.skipSpaces(this.firstPos(), false, true);\n    return pos ? this.slice(pos) : emptyLines;\n};\n\nLp.trimRight = function() {\n    var pos = this.skipSpaces(this.lastPos(), true, true);\n    return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n};\n\nLp.trim = function() {\n    var start = this.skipSpaces(this.firstPos(), false, true);\n    if (start === null)\n        return emptyLines;\n\n    var end = this.skipSpaces(this.lastPos(), true, true);\n    assert.notStrictEqual(end, null);\n\n    return this.slice(start, end);\n};\n\nLp.eachPos = function(callback, startPos, skipSpaces) {\n    var pos = this.firstPos();\n\n    if (startPos) {\n        pos.line = startPos.line,\n        pos.column = startPos.column\n    }\n\n    if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n        return; // Encountered nothing but spaces.\n    }\n\n    do callback.call(this, pos);\n    while (this.nextPos(pos, skipSpaces));\n};\n\nLp.bootstrapSlice = function(start, end) {\n    var strings = this.toString().split(\n        lineTerminatorSeqExp\n    ).slice(\n        start.line - 1,\n        end.line\n    );\n\n    strings.push(strings.pop().slice(0, end.column));\n    strings[0] = strings[0].slice(start.column);\n\n    return fromString(strings.join(\"\\n\"));\n};\n\nLp.slice = function(start, end) {\n    if (!end) {\n        if (!start) {\n            // The client seems to want a copy of this Lines object, but\n            // Lines objects are immutable, so it's perfectly adequate to\n            // return the same object.\n            return this;\n        }\n\n        // Slice to the end if no end position was provided.\n        end = this.lastPos();\n    }\n\n    var secret = getSecret(this);\n    var sliced = secret.infos.slice(start.line - 1, end.line);\n\n    if (start.line === end.line) {\n        sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n    } else {\n        assert.ok(start.line < end.line);\n        sliced[0] = sliceInfo(sliced[0], start.column);\n        sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n    }\n\n    var lines = new Lines(sliced);\n\n    if (secret.mappings.length > 0) {\n        var newMappings = getSecret(lines).mappings;\n        assert.strictEqual(newMappings.length, 0);\n        secret.mappings.forEach(function(mapping) {\n            var sliced = mapping.slice(this, start, end);\n            if (sliced) {\n                newMappings.push(sliced);\n            }\n        }, this);\n    }\n\n    return lines;\n};\n\nfunction sliceInfo(info, startCol, endCol) {\n    var sliceStart = info.sliceStart;\n    var sliceEnd = info.sliceEnd;\n    var indent = Math.max(info.indent, 0);\n    var lineLength = indent + sliceEnd - sliceStart;\n\n    if (typeof endCol === \"undefined\") {\n        endCol = lineLength;\n    }\n\n    startCol = Math.max(startCol, 0);\n    endCol = Math.min(endCol, lineLength);\n    endCol = Math.max(endCol, startCol);\n\n    if (endCol < indent) {\n        indent = endCol;\n        sliceEnd = sliceStart;\n    } else {\n        sliceEnd -= lineLength - endCol;\n    }\n\n    lineLength = endCol;\n    lineLength -= startCol;\n\n    if (startCol < indent) {\n        indent -= startCol;\n    } else {\n        startCol -= indent;\n        indent = 0;\n        sliceStart += startCol;\n    }\n\n    assert.ok(indent >= 0);\n    assert.ok(sliceStart <= sliceEnd);\n    assert.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n\n    if (info.indent === indent &&\n        info.sliceStart === sliceStart &&\n        info.sliceEnd === sliceEnd) {\n        return info;\n    }\n\n    return {\n        line: info.line,\n        indent: indent,\n        // A destructive slice always unlocks indentation.\n        locked: false,\n        sliceStart: sliceStart,\n        sliceEnd: sliceEnd\n    };\n}\n\nLp.bootstrapSliceString = function(start, end, options) {\n    return this.slice(start, end).toString(options);\n};\n\nLp.sliceString = function(start, end, options) {\n    if (!end) {\n        if (!start) {\n            // The client seems to want a copy of this Lines object, but\n            // Lines objects are immutable, so it's perfectly adequate to\n            // return the same object.\n            return this;\n        }\n\n        // Slice to the end if no end position was provided.\n        end = this.lastPos();\n    }\n\n    options = normalizeOptions(options);\n\n    var infos = getSecret(this).infos;\n    var parts = [];\n    var tabWidth = options.tabWidth;\n\n    for (var line = start.line; line <= end.line; ++line) {\n        var info = infos[line - 1];\n\n        if (line === start.line) {\n            if (line === end.line) {\n                info = sliceInfo(info, start.column, end.column);\n            } else {\n                info = sliceInfo(info, start.column);\n            }\n        } else if (line === end.line) {\n            info = sliceInfo(info, 0, end.column);\n        }\n\n        var indent = Math.max(info.indent, 0);\n\n        var before = info.line.slice(0, info.sliceStart);\n        if (options.reuseWhitespace &&\n            isOnlyWhitespace(before) &&\n            countSpaces(before, options.tabWidth) === indent) {\n            // Reuse original spaces if the indentation is correct.\n            parts.push(info.line.slice(0, info.sliceEnd));\n            continue;\n        }\n\n        var tabs = 0;\n        var spaces = indent;\n\n        if (options.useTabs) {\n            tabs = Math.floor(indent / tabWidth);\n            spaces -= tabs * tabWidth;\n        }\n\n        var result = \"\";\n\n        if (tabs > 0) {\n            result += new Array(tabs + 1).join(\"\\t\");\n        }\n\n        if (spaces > 0) {\n            result += new Array(spaces + 1).join(\" \");\n        }\n\n        result += info.line.slice(info.sliceStart, info.sliceEnd);\n\n        parts.push(result);\n    }\n\n    return parts.join(options.lineTerminator);\n};\n\nLp.isEmpty = function() {\n    return this.length < 2 && this.getLineLength(1) < 1;\n};\n\nLp.join = function(elements) {\n    var separator = this;\n    var separatorSecret = getSecret(separator);\n    var infos = [];\n    var mappings = [];\n    var prevInfo;\n\n    function appendSecret(secret) {\n        if (secret === null)\n            return;\n\n        if (prevInfo) {\n            var info = secret.infos[0];\n            var indent = new Array(info.indent + 1).join(\" \");\n            var prevLine = infos.length;\n            var prevColumn = Math.max(prevInfo.indent, 0) +\n                prevInfo.sliceEnd - prevInfo.sliceStart;\n\n            prevInfo.line = prevInfo.line.slice(\n                0, prevInfo.sliceEnd) + indent + info.line.slice(\n                    info.sliceStart, info.sliceEnd);\n\n            // If any part of a line is indentation-locked, the whole line\n            // will be indentation-locked.\n            prevInfo.locked = prevInfo.locked || info.locked;\n\n            prevInfo.sliceEnd = prevInfo.line.length;\n\n            if (secret.mappings.length > 0) {\n                secret.mappings.forEach(function(mapping) {\n                    mappings.push(mapping.add(prevLine, prevColumn));\n                });\n            }\n\n        } else if (secret.mappings.length > 0) {\n            mappings.push.apply(mappings, secret.mappings);\n        }\n\n        secret.infos.forEach(function(info, i) {\n            if (!prevInfo || i > 0) {\n                prevInfo = copyLineInfo(info);\n                infos.push(prevInfo);\n            }\n        });\n    }\n\n    function appendWithSeparator(secret, i) {\n        if (i > 0)\n            appendSecret(separatorSecret);\n        appendSecret(secret);\n    }\n\n    elements.map(function(elem) {\n        var lines = fromString(elem);\n        if (lines.isEmpty())\n            return null;\n        return getSecret(lines);\n    }).forEach(separator.isEmpty()\n               ? appendSecret\n               : appendWithSeparator);\n\n    if (infos.length < 1)\n        return emptyLines;\n\n    var lines = new Lines(infos);\n\n    getSecret(lines).mappings = mappings;\n\n    return lines;\n};\n\nexports.concat = function(elements) {\n    return emptyLines.join(elements);\n};\n\nLp.concat = function(other) {\n    var args = arguments,\n        list = [this];\n    list.push.apply(list, args);\n    assert.strictEqual(list.length, args.length + 1);\n    return emptyLines.join(list);\n};\n\n// The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\nvar emptyLines = fromString(\"\");\n","var defaults = {\n    // If you want to use a different branch of esprima, or any other\n    // module that supports a .parse function, pass that module object to\n    // recast.parse as options.parser (legacy synonym: options.esprima).\n    parser: require(\"esprima\"),\n\n    // Number of spaces the pretty-printer should use per tab for\n    // indentation. If you do not pass this option explicitly, it will be\n    // (quite reliably!) inferred from the original code.\n    tabWidth: 4,\n\n    // If you really want the pretty-printer to use tabs instead of\n    // spaces, make this option true.\n    useTabs: false,\n\n    // The reprinting code leaves leading whitespace untouched unless it\n    // has to reindent a line, or you pass false for this option.\n    reuseWhitespace: true,\n\n    // Override this option to use a different line terminator, e.g. \\r\\n.\n    lineTerminator: require(\"os\").EOL,\n\n    // Some of the pretty-printer code (such as that for printing function\n    // parameter lists) makes a valiant attempt to prevent really long\n    // lines. You can adjust the limit by changing this option; however,\n    // there is no guarantee that line length will fit inside this limit.\n    wrapColumn: 74, // Aspirational for now.\n\n    // Pass a string as options.sourceFileName to recast.parse to tell the\n    // reprinter to keep track of reused code so that it can construct a\n    // source map automatically.\n    sourceFileName: null,\n\n    // Pass a string as options.sourceMapName to recast.print, and\n    // (provided you passed options.sourceFileName earlier) the\n    // PrintResult of recast.print will have a .map property for the\n    // generated source map.\n    sourceMapName: null,\n\n    // If provided, this option will be passed along to the source map\n    // generator as a root directory for relative source file paths.\n    sourceRoot: null,\n\n    // If you provide a source map that was generated from a previous call\n    // to recast.print as options.inputSourceMap, the old source map will\n    // be composed with the new source map.\n    inputSourceMap: null,\n\n    // If you want esprima to generate .range information (recast only\n    // uses .loc internally), pass true for this option.\n    range: false,\n\n    // If you want esprima not to throw exceptions when it encounters\n    // non-fatal errors, keep this option true.\n    tolerant: true,\n\n    // If you want to override the quotes used in string literals, specify\n    // either \"single\", \"double\", or \"auto\" here (\"auto\" will select the one\n    // which results in the shorter literal)\n    // Otherwise, double quotes are used.\n    quote: null,\n\n    // Controls the printing of trailing commas in object literals,\n    // array expressions and function parameters.\n    //\n    // This option could either be:\n    // * Boolean - enable/disable in all contexts (objects, arrays and function params).\n    // * Object - enable/disable per context.\n    //\n    // Example:\n    // trailingComma: {\n    //   objects: true,\n    //   arrays: true,\n    //   parameters: false,\n    // }\n    trailingComma: false,\n\n    // Controls the printing of spaces inside array brackets.\n    // See: http://eslint.org/docs/rules/array-bracket-spacing\n    arrayBracketSpacing: false,\n\n    // Controls the printing of spaces inside object literals,\n    // destructuring assignments, and import/export specifiers.\n    // See: http://eslint.org/docs/rules/object-curly-spacing\n    objectCurlySpacing: true,\n\n    // If you want parenthesis to wrap single-argument arrow function parameter\n    // lists, pass true for this option.\n    arrowParensAlways: false,\n\n    // There are 2 supported syntaxes (`,` and `;`) in Flow Object Types;\n    // The use of commas is in line with the more popular style and matches\n    // how objects are defined in JS, making it a bit more natural to write.\n    flowObjectCommas: true,\n}, hasOwn = defaults.hasOwnProperty;\n\n// Copy options and fill in default values.\nexports.normalize = function(options) {\n    options = options || defaults;\n\n    function get(key) {\n        return hasOwn.call(options, key)\n            ? options[key]\n            : defaults[key];\n    }\n\n    return {\n        tabWidth: +get(\"tabWidth\"),\n        useTabs: !!get(\"useTabs\"),\n        reuseWhitespace: !!get(\"reuseWhitespace\"),\n        lineTerminator: get(\"lineTerminator\"),\n        wrapColumn: Math.max(get(\"wrapColumn\"), 0),\n        sourceFileName: get(\"sourceFileName\"),\n        sourceMapName: get(\"sourceMapName\"),\n        sourceRoot: get(\"sourceRoot\"),\n        inputSourceMap: get(\"inputSourceMap\"),\n        parser: get(\"esprima\") || get(\"parser\"),\n        range: get(\"range\"),\n        tolerant: get(\"tolerant\"),\n        quote: get(\"quote\"),\n        trailingComma: get(\"trailingComma\"),\n        arrayBracketSpacing: get(\"arrayBracketSpacing\"),\n        objectCurlySpacing: get(\"objectCurlySpacing\"),\n        arrowParensAlways: get(\"arrowParensAlways\"),\n        flowObjectCommas: get(\"flowObjectCommas\"),\n    };\n};\n","var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar getFieldValue = types.getFieldValue;\nvar n = types.namedTypes;\nvar sourceMap = require(\"source-map\");\nvar SourceMapConsumer = sourceMap.SourceMapConsumer;\nvar SourceMapGenerator = sourceMap.SourceMapGenerator;\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar util = exports;\n\nfunction getUnionOfKeys() {\n  var result = {};\n  var argc = arguments.length;\n  for (var i = 0; i < argc; ++i) {\n    var keys = Object.keys(arguments[i]);\n    var keyCount = keys.length;\n    for (var j = 0; j < keyCount; ++j) {\n      result[keys[j]] = true;\n    }\n  }\n  return result;\n}\nutil.getUnionOfKeys = getUnionOfKeys;\n\nfunction comparePos(pos1, pos2) {\n  return (pos1.line - pos2.line) || (pos1.column - pos2.column);\n}\nutil.comparePos = comparePos;\n\nfunction copyPos(pos) {\n  return {\n    line: pos.line,\n    column: pos.column\n  };\n}\nutil.copyPos = copyPos;\n\nutil.composeSourceMaps = function(formerMap, latterMap) {\n  if (formerMap) {\n    if (!latterMap) {\n      return formerMap;\n    }\n  } else {\n    return latterMap || null;\n  }\n\n  var smcFormer = new SourceMapConsumer(formerMap);\n  var smcLatter = new SourceMapConsumer(latterMap);\n  var smg = new SourceMapGenerator({\n    file: latterMap.file,\n    sourceRoot: latterMap.sourceRoot\n  });\n\n  var sourcesToContents = {};\n\n  smcLatter.eachMapping(function(mapping) {\n    var origPos = smcFormer.originalPositionFor({\n      line: mapping.originalLine,\n      column: mapping.originalColumn\n    });\n\n    var sourceName = origPos.source;\n    if (sourceName === null) {\n      return;\n    }\n\n    smg.addMapping({\n      source: sourceName,\n      original: copyPos(origPos),\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      },\n      name: mapping.name\n    });\n\n    var sourceContent = smcFormer.sourceContentFor(sourceName);\n    if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {\n      sourcesToContents[sourceName] = sourceContent;\n      smg.setSourceContent(sourceName, sourceContent);\n    }\n  });\n\n  return smg.toJSON();\n};\n\nutil.getTrueLoc = function(node, lines) {\n  // It's possible that node is newly-created (not parsed by Esprima),\n  // in which case it probably won't have a .loc property (or an\n  // .original property for that matter). That's fine; we'll just\n  // pretty-print it as usual.\n  if (!node.loc) {\n    return null;\n  }\n\n  var result = {\n    start: node.loc.start,\n    end: node.loc.end\n  };\n\n  function include(node) {\n    expandLoc(result, node.loc);\n  }\n\n  // If the node has any comments, their locations might contribute to\n  // the true start/end positions of the node.\n  if (node.comments) {\n    node.comments.forEach(include);\n  }\n\n  // If the node is an export declaration and its .declaration has any\n  // decorators, their locations might contribute to the true start/end\n  // positions of the export declaration node.\n  if (node.declaration && util.isExportDeclaration(node) &&\n      node.declaration.decorators) {\n    node.declaration.decorators.forEach(include);\n  }\n\n  if (comparePos(result.start, result.end) < 0) {\n    // Trim leading whitespace.\n    result.start = copyPos(result.start);\n    lines.skipSpaces(result.start, false, true);\n\n    if (comparePos(result.start, result.end) < 0) {\n      // Trim trailing whitespace, if the end location is not already the\n      // same as the start location.\n      result.end = copyPos(result.end);\n      lines.skipSpaces(result.end, true, true);\n    }\n  }\n\n  return result;\n};\n\nfunction expandLoc(parentLoc, childLoc) {\n  if (parentLoc && childLoc) {\n    if (comparePos(childLoc.start, parentLoc.start) < 0) {\n      parentLoc.start = childLoc.start;\n    }\n\n    if (comparePos(parentLoc.end, childLoc.end) < 0) {\n      parentLoc.end = childLoc.end;\n    }\n  }\n}\n\nutil.fixFaultyLocations = function(node, lines) {\n  var loc = node.loc;\n  if (loc) {\n    if (loc.start.line < 1) {\n      loc.start.line = 1;\n    }\n\n    if (loc.end.line < 1) {\n      loc.end.line = 1;\n    }\n  }\n\n  if (node.type === \"File\") {\n    // Babylon returns File nodes whose .loc.{start,end} do not include\n    // leading or trailing whitespace.\n    loc.start = lines.firstPos();\n    loc.end = lines.lastPos();\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    fixTemplateLiteral(node, lines);\n\n  } else if (loc && node.decorators) {\n    // Expand the .loc of the node responsible for printing the decorators\n    // (here, the decorated node) so that it includes node.decorators.\n    node.decorators.forEach(function (decorator) {\n      expandLoc(loc, decorator.loc);\n    });\n\n  } else if (node.declaration && util.isExportDeclaration(node)) {\n    // Nullify .loc information for the child declaration so that we never\n    // try to reprint it without also reprinting the export declaration.\n    node.declaration.loc = null;\n\n    // Expand the .loc of the node responsible for printing the decorators\n    // (here, the export declaration) so that it includes node.decorators.\n    var decorators = node.declaration.decorators;\n    if (decorators) {\n      decorators.forEach(function (decorator) {\n        expandLoc(loc, decorator.loc);\n      });\n    }\n\n  } else if ((n.MethodDefinition && n.MethodDefinition.check(node)) ||\n             (n.Property.check(node) && (node.method || node.shorthand))) {\n    // If the node is a MethodDefinition or a .method or .shorthand\n    // Property, then the location information stored in\n    // node.value.loc is very likely untrustworthy (just the {body}\n    // part of a method, or nothing in the case of shorthand\n    // properties), so we null out that information to prevent\n    // accidental reuse of bogus source code during reprinting.\n    node.value.loc = null;\n\n    if (n.FunctionExpression.check(node.value)) {\n      // FunctionExpression method values should be anonymous,\n      // because their .id fields are ignored anyway.\n      node.value.id = null;\n    }\n\n  } else if (node.type === \"ObjectTypeProperty\") {\n    var loc = node.loc;\n    var end = loc && loc.end;\n    if (end) {\n      end = copyPos(end);\n      if (lines.prevPos(end) &&\n          lines.charAt(end) === \",\") {\n        // Some parsers accidentally include trailing commas in the\n        // .loc.end information for ObjectTypeProperty nodes.\n        if ((end = lines.skipSpaces(end, true, true))) {\n          loc.end = end;\n        }\n      }\n    }\n  }\n};\n\nfunction fixTemplateLiteral(node, lines) {\n  assert.strictEqual(node.type, \"TemplateLiteral\");\n\n  if (node.quasis.length === 0) {\n    // If there are no quasi elements, then there is nothing to fix.\n    return;\n  }\n\n  // First we need to exclude the opening ` from the .loc of the first\n  // quasi element, in case the parser accidentally decided to include it.\n  var afterLeftBackTickPos = copyPos(node.loc.start);\n  assert.strictEqual(lines.charAt(afterLeftBackTickPos), \"`\");\n  assert.ok(lines.nextPos(afterLeftBackTickPos));\n  var firstQuasi = node.quasis[0];\n  if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {\n    firstQuasi.loc.start = afterLeftBackTickPos;\n  }\n\n  // Next we need to exclude the closing ` from the .loc of the last quasi\n  // element, in case the parser accidentally decided to include it.\n  var rightBackTickPos = copyPos(node.loc.end);\n  assert.ok(lines.prevPos(rightBackTickPos));\n  assert.strictEqual(lines.charAt(rightBackTickPos), \"`\");\n  var lastQuasi = node.quasis[node.quasis.length - 1];\n  if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {\n    lastQuasi.loc.end = rightBackTickPos;\n  }\n\n  // Now we need to exclude ${ and } characters from the .loc's of all\n  // quasi elements, since some parsers accidentally include them.\n  node.expressions.forEach(function (expr, i) {\n    // Rewind from expr.loc.start over any whitespace and the ${ that\n    // precedes the expression. The position of the $ should be the same\n    // as the .loc.end of the preceding quasi element, but some parsers\n    // accidentally include the ${ in the .loc of the quasi element.\n    var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);\n    if (lines.prevPos(dollarCurlyPos) &&\n        lines.charAt(dollarCurlyPos) === \"{\" &&\n        lines.prevPos(dollarCurlyPos) &&\n        lines.charAt(dollarCurlyPos) === \"$\") {\n      var quasiBefore = node.quasis[i];\n      if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {\n        quasiBefore.loc.end = dollarCurlyPos;\n      }\n    }\n\n    // Likewise, some parsers accidentally include the } that follows\n    // the expression in the .loc of the following quasi element.\n    var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);\n    if (lines.charAt(rightCurlyPos) === \"}\") {\n      assert.ok(lines.nextPos(rightCurlyPos));\n      // Now rightCurlyPos is technically the position just after the }.\n      var quasiAfter = node.quasis[i + 1];\n      if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {\n        quasiAfter.loc.start = rightCurlyPos;\n      }\n    }\n  });\n}\n\nutil.isExportDeclaration = function (node) {\n  if (node) switch (node.type) {\n  case \"ExportDeclaration\":\n  case \"ExportDefaultDeclaration\":\n  case \"ExportDefaultSpecifier\":\n  case \"DeclareExportDeclaration\":\n  case \"ExportNamedDeclaration\":\n  case \"ExportAllDeclaration\":\n    return true;\n  }\n\n  return false;\n};\n\nutil.getParentExportDeclaration = function (path) {\n  var parentNode = path.getParentNode();\n  if (path.getName() === \"declaration\" &&\n      util.isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n};\n\nutil.isTrailingCommaEnabled = function(options, context) {\n  var trailingComma = options.trailingComma;\n  if (typeof trailingComma === \"object\") {\n    return !!trailingComma[context];\n  }\n  return !!trailingComma;\n};\n","var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar isString = types.builtInTypes.string;\nvar isNumber = types.builtInTypes.number;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar Position = types.namedTypes.Position;\nvar linesModule = require(\"./lines\");\nvar comparePos = require(\"./util\").comparePos;\n\nfunction Mapping(sourceLines, sourceLoc, targetLoc) {\n    assert.ok(this instanceof Mapping);\n    assert.ok(sourceLines instanceof linesModule.Lines);\n    SourceLocation.assert(sourceLoc);\n\n    if (targetLoc) {\n        // In certain cases it's possible for targetLoc.{start,end}.column\n        // values to be negative, which technically makes them no longer\n        // valid SourceLocation nodes, so we need to be more forgiving.\n        assert.ok(\n            isNumber.check(targetLoc.start.line) &&\n            isNumber.check(targetLoc.start.column) &&\n            isNumber.check(targetLoc.end.line) &&\n            isNumber.check(targetLoc.end.column)\n        );\n    } else {\n        // Assume identity mapping if no targetLoc specified.\n        targetLoc = sourceLoc;\n    }\n\n    Object.defineProperties(this, {\n        sourceLines: { value: sourceLines },\n        sourceLoc: { value: sourceLoc },\n        targetLoc: { value: targetLoc }\n    });\n}\n\nvar Mp = Mapping.prototype;\nmodule.exports = Mapping;\n\nMp.slice = function(lines, start, end) {\n    assert.ok(lines instanceof linesModule.Lines);\n    Position.assert(start);\n\n    if (end) {\n        Position.assert(end);\n    } else {\n        end = lines.lastPos();\n    }\n\n    var sourceLines = this.sourceLines;\n    var sourceLoc = this.sourceLoc;\n    var targetLoc = this.targetLoc;\n\n    function skip(name) {\n        var sourceFromPos = sourceLoc[name];\n        var targetFromPos = targetLoc[name];\n        var targetToPos = start;\n\n        if (name === \"end\") {\n            targetToPos = end;\n        } else {\n            assert.strictEqual(name, \"start\");\n        }\n\n        return skipChars(\n            sourceLines, sourceFromPos,\n            lines, targetFromPos, targetToPos\n        );\n    }\n\n    if (comparePos(start, targetLoc.start) <= 0) {\n        if (comparePos(targetLoc.end, end) <= 0) {\n            targetLoc = {\n                start: subtractPos(targetLoc.start, start.line, start.column),\n                end: subtractPos(targetLoc.end, start.line, start.column)\n            };\n\n            // The sourceLoc can stay the same because the contents of the\n            // targetLoc have not changed.\n\n        } else if (comparePos(end, targetLoc.start) <= 0) {\n            return null;\n\n        } else {\n            sourceLoc = {\n                start: sourceLoc.start,\n                end: skip(\"end\")\n            };\n\n            targetLoc = {\n                start: subtractPos(targetLoc.start, start.line, start.column),\n                end: subtractPos(end, start.line, start.column)\n            };\n        }\n\n    } else {\n        if (comparePos(targetLoc.end, start) <= 0) {\n            return null;\n        }\n\n        if (comparePos(targetLoc.end, end) <= 0) {\n            sourceLoc = {\n                start: skip(\"start\"),\n                end: sourceLoc.end\n            };\n\n            targetLoc = {\n                // Same as subtractPos(start, start.line, start.column):\n                start: { line: 1, column: 0 },\n                end: subtractPos(targetLoc.end, start.line, start.column)\n            };\n\n        } else {\n            sourceLoc = {\n                start: skip(\"start\"),\n                end: skip(\"end\")\n            };\n\n            targetLoc = {\n                // Same as subtractPos(start, start.line, start.column):\n                start: { line: 1, column: 0 },\n                end: subtractPos(end, start.line, start.column)\n            };\n        }\n    }\n\n    return new Mapping(this.sourceLines, sourceLoc, targetLoc);\n};\n\nMp.add = function(line, column) {\n    return new Mapping(this.sourceLines, this.sourceLoc, {\n        start: addPos(this.targetLoc.start, line, column),\n        end: addPos(this.targetLoc.end, line, column)\n    });\n};\n\nfunction addPos(toPos, line, column) {\n    return {\n        line: toPos.line + line - 1,\n        column: (toPos.line === 1)\n            ? toPos.column + column\n            : toPos.column\n    };\n}\n\nMp.subtract = function(line, column) {\n    return new Mapping(this.sourceLines, this.sourceLoc, {\n        start: subtractPos(this.targetLoc.start, line, column),\n        end: subtractPos(this.targetLoc.end, line, column)\n    });\n};\n\nfunction subtractPos(fromPos, line, column) {\n    return {\n        line: fromPos.line - line + 1,\n        column: (fromPos.line === line)\n            ? fromPos.column - column\n            : fromPos.column\n    };\n}\n\nMp.indent = function(by, skipFirstLine, noNegativeColumns) {\n    if (by === 0) {\n        return this;\n    }\n\n    var targetLoc = this.targetLoc;\n    var startLine = targetLoc.start.line;\n    var endLine = targetLoc.end.line;\n\n    if (skipFirstLine && startLine === 1 && endLine === 1) {\n        return this;\n    }\n\n    targetLoc = {\n        start: targetLoc.start,\n        end: targetLoc.end\n    };\n\n    if (!skipFirstLine || startLine > 1) {\n        var startColumn = targetLoc.start.column + by;\n        targetLoc.start = {\n            line: startLine,\n            column: noNegativeColumns\n                ? Math.max(0, startColumn)\n                : startColumn\n        };\n    }\n\n    if (!skipFirstLine || endLine > 1) {\n        var endColumn = targetLoc.end.column + by;\n        targetLoc.end = {\n            line: endLine,\n            column: noNegativeColumns\n                ? Math.max(0, endColumn)\n                : endColumn\n        };\n    }\n\n    return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);\n};\n\nfunction skipChars(\n    sourceLines, sourceFromPos,\n    targetLines, targetFromPos, targetToPos\n) {\n    assert.ok(sourceLines instanceof linesModule.Lines);\n    assert.ok(targetLines instanceof linesModule.Lines);\n    Position.assert(sourceFromPos);\n    Position.assert(targetFromPos);\n    Position.assert(targetToPos);\n\n    var targetComparison = comparePos(targetFromPos, targetToPos);\n    if (targetComparison === 0) {\n        // Trivial case: no characters to skip.\n        return sourceFromPos;\n    }\n\n    if (targetComparison < 0) {\n        // Skipping forward.\n\n        var sourceCursor = sourceLines.skipSpaces(sourceFromPos);\n        var targetCursor = targetLines.skipSpaces(targetFromPos);\n\n        var lineDiff = targetToPos.line - targetCursor.line;\n        sourceCursor.line += lineDiff;\n        targetCursor.line += lineDiff;\n\n        if (lineDiff > 0) {\n            // If jumping to later lines, reset columns to the beginnings\n            // of those lines.\n            sourceCursor.column = 0;\n            targetCursor.column = 0;\n        } else {\n            assert.strictEqual(lineDiff, 0);\n        }\n\n        while (comparePos(targetCursor, targetToPos) < 0 &&\n               targetLines.nextPos(targetCursor, true)) {\n            assert.ok(sourceLines.nextPos(sourceCursor, true));\n            assert.strictEqual(\n                sourceLines.charAt(sourceCursor),\n                targetLines.charAt(targetCursor)\n            );\n        }\n\n    } else {\n        // Skipping backward.\n\n        var sourceCursor = sourceLines.skipSpaces(sourceFromPos, true);\n        var targetCursor = targetLines.skipSpaces(targetFromPos, true);\n\n        var lineDiff = targetToPos.line - targetCursor.line;\n        sourceCursor.line += lineDiff;\n        targetCursor.line += lineDiff;\n\n        if (lineDiff < 0) {\n            // If jumping to earlier lines, reset columns to the ends of\n            // those lines.\n            sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);\n            targetCursor.column = targetLines.getLineLength(targetCursor.line);\n        } else {\n            assert.strictEqual(lineDiff, 0);\n        }\n\n        while (comparePos(targetToPos, targetCursor) < 0 &&\n               targetLines.prevPos(targetCursor, true)) {\n            assert.ok(sourceLines.prevPos(sourceCursor, true));\n            assert.strictEqual(\n                sourceLines.charAt(sourceCursor),\n                targetLines.charAt(targetCursor)\n            );\n        }\n    }\n\n    return sourceCursor;\n}\n","var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar n = types.namedTypes;\nvar Node = n.Node;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\n\nfunction FastPath(value) {\n    assert.ok(this instanceof FastPath);\n    this.stack = [value];\n}\n\nvar FPp = FastPath.prototype;\nmodule.exports = FastPath;\n\n// Static convenience function for coercing a value to a FastPath.\nFastPath.from = function(obj) {\n    if (obj instanceof FastPath) {\n        // Return a defensive copy of any existing FastPath instances.\n        return obj.copy();\n    }\n\n    if (obj instanceof types.NodePath) {\n        // For backwards compatibility, unroll NodePath instances into\n        // lightweight FastPath [..., name, value] stacks.\n        var copy = Object.create(FastPath.prototype);\n        var stack = [obj.value];\n        for (var pp; (pp = obj.parentPath); obj = pp)\n            stack.push(obj.name, pp.value);\n        copy.stack = stack.reverse();\n        return copy;\n    }\n\n    // Otherwise use obj as the value of the new FastPath instance.\n    return new FastPath(obj);\n};\n\nFPp.copy = function copy() {\n    var copy = Object.create(FastPath.prototype);\n    copy.stack = this.stack.slice(0);\n    return copy;\n};\n\n// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\nFPp.getName = function getName() {\n    var s = this.stack;\n    var len = s.length;\n    if (len > 1) {\n        return s[len - 2];\n    }\n    // Since the name is always a string, null is a safe sentinel value to\n    // return if we do not know the name of the (root) value.\n    return null;\n};\n\n// The value of the current property is always the final element of\n// this.stack.\nFPp.getValue = function getValue() {\n    var s = this.stack;\n    return s[s.length - 1];\n};\n\nfunction getNodeHelper(path, count) {\n    var s = path.stack;\n\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        var value = s[i];\n        if (n.Node.check(value) && --count < 0) {\n            return value;\n        }\n    }\n\n    return null;\n}\n\nFPp.getNode = function getNode(count) {\n    return getNodeHelper(this, ~~count);\n};\n\nFPp.getParentNode = function getParentNode(count) {\n    return getNodeHelper(this, ~~count + 1);\n};\n\n// The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\nFPp.getRootValue = function getRootValue() {\n    var s = this.stack;\n    if (s.length % 2 === 0) {\n        return s[1];\n    }\n    return s[0];\n};\n\n// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\nFPp.call = function call(callback/*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    var result = callback(this);\n    s.length = origLen;\n    return result;\n};\n\n// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\nFPp.each = function each(callback/*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            // If the callback needs to know the value of i, call\n            // path.getName(), assuming path is the parameter name.\n            callback(this);\n            s.length -= 2;\n        }\n    }\n\n    s.length = origLen;\n};\n\n// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nFPp.map = function map(callback/*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n\n    var result = new Array(value.length);\n\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            result[i] = callback(this, i);\n            s.length -= 2;\n        }\n    }\n\n    s.length = origLen;\n\n    return result;\n};\n\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\nFPp.needsParens = function(assumeExpressionContext) {\n    var parent = this.getParentNode();\n    if (!parent) {\n        return false;\n    }\n\n    var name = this.getName();\n    var node = this.getNode();\n\n    // If the value of this path is some child of a Node and not a Node\n    // itself, then it doesn't need parentheses. Only Node objects (in\n    // fact, only Expression nodes) need parentheses.\n    if (this.getValue() !== node) {\n        return false;\n    }\n\n    // Only statements don't need parentheses.\n    if (n.Statement.check(node)) {\n        return false;\n    }\n\n    // Identifiers never need parentheses.\n    if (node.type === \"Identifier\") {\n        return false;\n    }\n\n    if (parent.type === \"ParenthesizedExpression\") {\n        return false;\n    }\n\n    switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\"\n            && name === \"object\"\n            && parent.object === node;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n        switch (parent.type) {\n        case \"CallExpression\":\n            return name === \"callee\"\n                && parent.callee === node;\n\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n            return true;\n\n        case \"MemberExpression\":\n            return name === \"object\"\n                && parent.object === node;\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            var po = parent.operator;\n            var pp = PRECEDENCE[po];\n            var no = node.operator;\n            var np = PRECEDENCE[no];\n\n            if (pp > np) {\n                return true;\n            }\n\n            if (pp === np && name === \"right\") {\n                assert.strictEqual(parent.right, node);\n                return true;\n            }\n\n        default:\n            return false;\n        }\n\n    case \"SequenceExpression\":\n        switch (parent.type) {\n        case \"ReturnStatement\":\n            return false;\n\n        case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n        case \"ExpressionStatement\":\n            return name !== \"expression\";\n\n        default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n    case \"YieldExpression\":\n        switch (parent.type) {\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n        case \"ConditionalExpression\":\n        case \"YieldExpression\":\n            return true;\n\n        default:\n            return false;\n        }\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n        return parent.type === \"NullableTypeAnnotation\";\n\n    case \"Literal\":\n        return parent.type === \"MemberExpression\"\n            && isNumber.check(node.value)\n            && name === \"object\"\n            && parent.object === node;\n\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n        switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            return true;\n\n        case \"CallExpression\":\n            return name === \"callee\"\n                && parent.callee === node;\n\n        case \"ConditionalExpression\":\n            return name === \"test\"\n                && parent.test === node;\n\n        case \"MemberExpression\":\n            return name === \"object\"\n                && parent.object === node;\n\n        default:\n            return false;\n        }\n\n    case \"ArrowFunctionExpression\":\n        if(n.CallExpression.check(parent) && name === 'callee') {\n            return true;\n        }\n        if(n.MemberExpression.check(parent) && name === 'object') {\n            return true;\n        }\n\n        return isBinary(parent);\n\n    case \"ObjectExpression\":\n        if (parent.type === \"ArrowFunctionExpression\" &&\n            name === \"body\") {\n            return true;\n        }\n\n    default:\n        if (parent.type === \"NewExpression\" &&\n            name === \"callee\" &&\n            parent.callee === node) {\n            return containsCallExpression(node);\n        }\n    }\n\n    if (assumeExpressionContext !== true &&\n        !this.canBeFirstInStatement() &&\n        this.firstInStatement())\n        return true;\n\n    return false;\n};\n\nfunction isBinary(node) {\n    return n.BinaryExpression.check(node)\n        || n.LogicalExpression.check(node);\n}\n\nfunction isUnaryLike(node) {\n    return n.UnaryExpression.check(node)\n        // I considered making SpreadElement and SpreadProperty subtypes\n        // of UnaryExpression, but they're not really Expression nodes.\n        || (n.SpreadElement && n.SpreadElement.check(node))\n        || (n.SpreadProperty && n.SpreadProperty.check(node));\n}\n\nvar PRECEDENCE = {};\n[[\"||\"],\n [\"&&\"],\n [\"|\"],\n [\"^\"],\n [\"&\"],\n [\"==\", \"===\", \"!=\", \"!==\"],\n [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n [\">>\", \"<<\", \">>>\"],\n [\"+\", \"-\"],\n [\"*\", \"/\", \"%\", \"**\"]\n].forEach(function(tier, i) {\n    tier.forEach(function(op) {\n        PRECEDENCE[op] = i;\n    });\n});\n\nfunction containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n        return true;\n    }\n\n    if (isArray.check(node)) {\n        return node.some(containsCallExpression);\n    }\n\n    if (n.Node.check(node)) {\n        return types.someField(node, function(name, child) {\n            return containsCallExpression(child);\n        });\n    }\n\n    return false;\n}\n\nFPp.canBeFirstInStatement = function() {\n    var node = this.getNode();\n    return !n.FunctionExpression.check(node)\n        && !n.ObjectExpression.check(node);\n};\n\nFPp.firstInStatement = function() {\n    var s = this.stack;\n    var parentName, parent;\n    var childName, child;\n\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        if (n.Node.check(s[i])) {\n            childName = parentName;\n            child = parent;\n            parentName = s[i - 1];\n            parent = s[i];\n        }\n\n        if (!parent || !child) {\n            continue;\n        }\n\n        if (n.BlockStatement.check(parent) &&\n            parentName === \"body\" &&\n            childName === 0) {\n            assert.strictEqual(parent.body[0], child);\n            return true;\n        }\n\n        if (n.ExpressionStatement.check(parent) &&\n            childName === \"expression\") {\n            assert.strictEqual(parent.expression, child);\n            return true;\n        }\n\n        if (n.SequenceExpression.check(parent) &&\n            parentName === \"expressions\" &&\n            childName === 0) {\n            assert.strictEqual(parent.expressions[0], child);\n            continue;\n        }\n\n        if (n.CallExpression.check(parent) &&\n            childName === \"callee\") {\n            assert.strictEqual(parent.callee, child);\n            continue;\n        }\n\n        if (n.MemberExpression.check(parent) &&\n            childName === \"object\") {\n            assert.strictEqual(parent.object, child);\n            continue;\n        }\n\n        if (n.ConditionalExpression.check(parent) &&\n            childName === \"test\") {\n            assert.strictEqual(parent.test, child);\n            continue;\n        }\n\n        if (isBinary(parent) &&\n            childName === \"left\") {\n            assert.strictEqual(parent.left, child);\n            continue;\n        }\n\n        if (n.UnaryExpression.check(parent) &&\n            !parent.prefix &&\n            childName === \"argument\") {\n            assert.strictEqual(parent.argument, child);\n            continue;\n        }\n\n        return false;\n    }\n\n    return true;\n};\n","var assert = require(\"assert\");\nvar types = require(\"./types\");\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar linesModule = require(\"./lines\");\nvar fromString = linesModule.fromString;\nvar Lines = linesModule.Lines;\nvar concat = linesModule.concat;\nvar util = require(\"./util\");\nvar comparePos = util.comparePos;\nvar childNodesCacheKey = require(\"private\").makeUniqueKey();\n\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, lines, resultArray) {\n    if (!node) {\n        return;\n    }\n\n    // The .loc checks below are sensitive to some of the problems that\n    // are fixed by this utility function. Specifically, if it decides to\n    // set node.loc to null, indicating that the node's .loc information\n    // is unreliable, then we don't want to add node to the resultArray.\n    util.fixFaultyLocations(node, lines);\n\n    if (resultArray) {\n        if (n.Node.check(node) &&\n            n.SourceLocation.check(node.loc)) {\n            // This reverse insertion sort almost always takes constant\n            // time because we almost always (maybe always?) append the\n            // nodes in order anyway.\n            for (var i = resultArray.length - 1; i >= 0; --i) {\n                if (comparePos(resultArray[i].loc.end,\n                               node.loc.start) <= 0) {\n                    break;\n                }\n            }\n            resultArray.splice(i + 1, 0, node);\n            return;\n        }\n    } else if (node[childNodesCacheKey]) {\n        return node[childNodesCacheKey];\n    }\n\n    var names;\n    if (isArray.check(node)) {\n        names = Object.keys(node);\n    } else if (isObject.check(node)) {\n        names = types.getFieldNames(node);\n    } else {\n        return;\n    }\n\n    if (!resultArray) {\n        Object.defineProperty(node, childNodesCacheKey, {\n            value: resultArray = [],\n            enumerable: false\n        });\n    }\n\n    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n        getSortedChildNodes(node[names[i]], lines, resultArray);\n    }\n\n    return resultArray;\n}\n\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, lines) {\n    var childNodes = getSortedChildNodes(node, lines);\n\n    // Time to dust off the old binary search robes and wizard hat.\n    var left = 0, right = childNodes.length;\n    while (left < right) {\n        var middle = (left + right) >> 1;\n        var child = childNodes[middle];\n\n        if (comparePos(child.loc.start, comment.loc.start) <= 0 &&\n            comparePos(comment.loc.end, child.loc.end) <= 0) {\n            // The comment is completely contained by this child node.\n            decorateComment(comment.enclosingNode = child, comment, lines);\n            return; // Abandon the binary search at this level.\n        }\n\n        if (comparePos(child.loc.end, comment.loc.start) <= 0) {\n            // This child node falls completely before the comment.\n            // Because we will never consider this node or any nodes\n            // before it again, this node must be the closest preceding\n            // node we have encountered so far.\n            var precedingNode = child;\n            left = middle + 1;\n            continue;\n        }\n\n        if (comparePos(comment.loc.end, child.loc.start) <= 0) {\n            // This child node falls completely after the comment.\n            // Because we will never consider this node or any nodes after\n            // it again, this node must be the closest following node we\n            // have encountered so far.\n            var followingNode = child;\n            right = middle;\n            continue;\n        }\n\n        throw new Error(\"Comment location overlaps with node location\");\n    }\n\n    if (precedingNode) {\n        comment.precedingNode = precedingNode;\n    }\n\n    if (followingNode) {\n        comment.followingNode = followingNode;\n    }\n}\n\nexports.attach = function(comments, ast, lines) {\n    if (!isArray.check(comments)) {\n        return;\n    }\n\n    var tiesToBreak = [];\n\n    comments.forEach(function(comment) {\n        comment.loc.lines = lines;\n        decorateComment(ast, comment, lines);\n\n        var pn = comment.precedingNode;\n        var en = comment.enclosingNode;\n        var fn = comment.followingNode;\n\n        if (pn && fn) {\n            var tieCount = tiesToBreak.length;\n            if (tieCount > 0) {\n                var lastTie = tiesToBreak[tieCount - 1];\n\n                assert.strictEqual(\n                    lastTie.precedingNode === comment.precedingNode,\n                    lastTie.followingNode === comment.followingNode\n                );\n\n                if (lastTie.followingNode !== comment.followingNode) {\n                    breakTies(tiesToBreak, lines);\n                }\n            }\n\n            tiesToBreak.push(comment);\n\n        } else if (pn) {\n            // No contest: we have a trailing comment.\n            breakTies(tiesToBreak, lines);\n            addTrailingComment(pn, comment);\n\n        } else if (fn) {\n            // No contest: we have a leading comment.\n            breakTies(tiesToBreak, lines);\n            addLeadingComment(fn, comment);\n\n        } else if (en) {\n            // The enclosing node has no child nodes at all, so what we\n            // have here is a dangling comment, e.g. [/* crickets */].\n            breakTies(tiesToBreak, lines);\n            addDanglingComment(en, comment);\n\n        } else {\n            throw new Error(\"AST contains no nodes at all?\");\n        }\n    });\n\n    breakTies(tiesToBreak, lines);\n\n    comments.forEach(function(comment) {\n        // These node references were useful for breaking ties, but we\n        // don't need them anymore, and they create cycles in the AST that\n        // may lead to infinite recursion if we don't delete them here.\n        delete comment.precedingNode;\n        delete comment.enclosingNode;\n        delete comment.followingNode;\n    });\n};\n\nfunction breakTies(tiesToBreak, lines) {\n    var tieCount = tiesToBreak.length;\n    if (tieCount === 0) {\n        return;\n    }\n\n    var pn = tiesToBreak[0].precedingNode;\n    var fn = tiesToBreak[0].followingNode;\n    var gapEndPos = fn.loc.start;\n\n    // Iterate backwards through tiesToBreak, examining the gaps\n    // between the tied comments. In order to qualify as leading, a\n    // comment must be separated from fn by an unbroken series of\n    // whitespace-only gaps (or other comments).\n    for (var indexOfFirstLeadingComment = tieCount;\n         indexOfFirstLeadingComment > 0;\n         --indexOfFirstLeadingComment) {\n        var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n        assert.strictEqual(comment.precedingNode, pn);\n        assert.strictEqual(comment.followingNode, fn);\n\n        var gap = lines.sliceString(comment.loc.end, gapEndPos);\n        if (/\\S/.test(gap)) {\n            // The gap string contained something other than whitespace.\n            break;\n        }\n\n        gapEndPos = comment.loc.start;\n    }\n\n    while (indexOfFirstLeadingComment <= tieCount &&\n           (comment = tiesToBreak[indexOfFirstLeadingComment]) &&\n           // If the comment is a //-style comment and indented more\n           // deeply than the node itself, reconsider it as trailing.\n           (comment.type === \"Line\" || comment.type === \"CommentLine\") &&\n           comment.loc.start.column > fn.loc.start.column) {\n        ++indexOfFirstLeadingComment;\n    }\n\n    tiesToBreak.forEach(function(comment, i) {\n        if (i < indexOfFirstLeadingComment) {\n            addTrailingComment(pn, comment);\n        } else {\n            addLeadingComment(fn, comment);\n        }\n    });\n\n    tiesToBreak.length = 0;\n}\n\nfunction addCommentHelper(node, comment) {\n    var comments = node.comments || (node.comments = []);\n    comments.push(comment);\n}\n\nfunction addLeadingComment(node, comment) {\n    comment.leading = true;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = true;\n    addCommentHelper(node, comment);\n}\n\nfunction printLeadingComment(commentPath, print) {\n    var comment = commentPath.getValue();\n    n.Comment.assert(comment);\n\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [print(commentPath)];\n\n    if (comment.trailing) {\n        // When we print trailing comments as leading comments, we don't\n        // want to bring any trailing spaces along.\n        parts.push(\"\\n\");\n\n    } else if (lines instanceof Lines) {\n        var trailingSpace = lines.slice(\n            loc.end,\n            lines.skipSpaces(loc.end)\n        );\n\n        if (trailingSpace.length === 1) {\n            // If the trailing space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(trailingSpace);\n        } else {\n            // If the trailing space contains newlines, then replace it\n            // with just that many newlines, with all other spaces removed.\n            parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n        }\n\n    } else {\n        parts.push(\"\\n\");\n    }\n\n    return concat(parts);\n}\n\nfunction printTrailingComment(commentPath, print) {\n    var comment = commentPath.getValue(commentPath);\n    n.Comment.assert(comment);\n\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [];\n\n    if (lines instanceof Lines) {\n        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n        var leadingSpace = lines.slice(fromPos, loc.start);\n\n        if (leadingSpace.length === 1) {\n            // If the leading space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(leadingSpace);\n        } else {\n            // If the leading space contains newlines, then replace it\n            // with just that many newlines, sans all other spaces.\n            parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n        }\n    }\n\n    parts.push(print(commentPath));\n\n    return concat(parts);\n}\n\nexports.printComments = function(path, print) {\n    var value = path.getValue();\n    var innerLines = print(path);\n    var comments = n.Node.check(value) &&\n        types.getFieldValue(value, \"comments\");\n\n    if (!comments || comments.length === 0) {\n        return innerLines;\n    }\n\n    var leadingParts = [];\n    var trailingParts = [innerLines];\n\n    path.each(function(commentPath) {\n        var comment = commentPath.getValue();\n        var leading = types.getFieldValue(comment, \"leading\");\n        var trailing = types.getFieldValue(comment, \"trailing\");\n\n        if (leading || (trailing && !(n.Statement.check(value) ||\n                                      comment.type === \"Block\" ||\n                                      comment.type === \"CommentBlock\"))) {\n            leadingParts.push(printLeadingComment(commentPath, print));\n        } else if (trailing) {\n            trailingParts.push(printTrailingComment(commentPath, print));\n        }\n    }, \"comments\");\n\n    leadingParts.push.apply(leadingParts, trailingParts);\n    return concat(leadingParts);\n};\n","var assert = require(\"assert\");\nvar sourceMap = require(\"source-map\");\nvar printComments = require(\"./comments\").printComments;\nvar linesModule = require(\"./lines\");\nvar fromString = linesModule.fromString;\nvar concat = linesModule.concat;\nvar normalizeOptions = require(\"./options\").normalize;\nvar getReprinter = require(\"./patcher\").getReprinter;\nvar types = require(\"./types\");\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar isObject = types.builtInTypes.object;\nvar FastPath = require(\"./fast-path\");\nvar util = require(\"./util\");\n\nfunction PrintResult(code, sourceMap) {\n    assert.ok(this instanceof PrintResult);\n\n    isString.assert(code);\n    this.code = code;\n\n    if (sourceMap) {\n        isObject.assert(sourceMap);\n        this.map = sourceMap;\n    }\n}\n\nvar PRp = PrintResult.prototype;\nvar warnedAboutToString = false;\n\nPRp.toString = function() {\n    if (!warnedAboutToString) {\n        console.warn(\n            \"Deprecation warning: recast.print now returns an object with \" +\n            \"a .code property. You appear to be treating the object as a \" +\n            \"string, which might still work but is strongly discouraged.\"\n        );\n\n        warnedAboutToString = true;\n    }\n\n    return this.code;\n};\n\nvar emptyPrintResult = new PrintResult(\"\");\n\nfunction Printer(originalOptions) {\n    assert.ok(this instanceof Printer);\n\n    var explicitTabWidth = originalOptions && originalOptions.tabWidth;\n    var options = normalizeOptions(originalOptions);\n    assert.notStrictEqual(options, originalOptions);\n\n    // It's common for client code to pass the same options into both\n    // recast.parse and recast.print, but the Printer doesn't need (and\n    // can be confused by) options.sourceFileName, so we null it out.\n    options.sourceFileName = null;\n\n    function printWithComments(path) {\n        assert.ok(path instanceof FastPath);\n        return printComments(path, print);\n    }\n\n    function print(path, includeComments) {\n        if (includeComments)\n            return printWithComments(path);\n\n        assert.ok(path instanceof FastPath);\n\n        if (!explicitTabWidth) {\n            var oldTabWidth = options.tabWidth;\n            var loc = path.getNode().loc;\n            if (loc && loc.lines && loc.lines.guessTabWidth) {\n                options.tabWidth = loc.lines.guessTabWidth();\n                var lines = maybeReprint(path);\n                options.tabWidth = oldTabWidth;\n                return lines;\n            }\n        }\n\n        return maybeReprint(path);\n    }\n\n    function maybeReprint(path) {\n        var reprinter = getReprinter(path);\n        if (reprinter) {\n            // Since the print function that we pass to the reprinter will\n            // be used to print \"new\" nodes, it's tempting to think we\n            // should pass printRootGenerically instead of print, to avoid\n            // calling maybeReprint again, but that would be a mistake\n            // because the new nodes might not be entirely new, but merely\n            // moved from elsewhere in the AST. The print function is the\n            // right choice because it gives us the opportunity to reprint\n            // such nodes using their original source.\n            return maybeAddParens(path, reprinter(print));\n        }\n        return printRootGenerically(path);\n    }\n\n    // Print the root node generically, but then resume reprinting its\n    // children non-generically.\n    function printRootGenerically(path, includeComments) {\n        return includeComments\n            ? printComments(path, printRootGenerically)\n            : genericPrint(path, options, printWithComments);\n    }\n\n    // Print the entire AST generically.\n    function printGenerically(path) {\n        return genericPrint(path, options, printGenerically);\n    }\n\n    this.print = function(ast) {\n        if (!ast) {\n            return emptyPrintResult;\n        }\n\n        var lines = print(FastPath.from(ast), true);\n\n        return new PrintResult(\n            lines.toString(options),\n            util.composeSourceMaps(\n                options.inputSourceMap,\n                lines.getSourceMap(\n                    options.sourceMapName,\n                    options.sourceRoot\n                )\n            )\n        );\n    };\n\n    this.printGenerically = function(ast) {\n        if (!ast) {\n            return emptyPrintResult;\n        }\n\n        var path = FastPath.from(ast);\n        var oldReuseWhitespace = options.reuseWhitespace;\n\n        // Do not reuse whitespace (or anything else, for that matter)\n        // when printing generically.\n        options.reuseWhitespace = false;\n\n        // TODO Allow printing of comments?\n        var pr = new PrintResult(printGenerically(path).toString(options));\n        options.reuseWhitespace = oldReuseWhitespace;\n        return pr;\n    };\n}\n\nexports.Printer = Printer;\n\nfunction maybeAddParens(path, lines) {\n    return path.needsParens() ? concat([\"(\", lines, \")\"]) : lines;\n}\n\nfunction genericPrint(path, options, printPath) {\n    assert.ok(path instanceof FastPath);\n\n    var node = path.getValue();\n    var parts = [];\n    var needsParens = false;\n    var linesWithoutParens =\n        genericPrintNoParens(path, options, printPath);\n\n    if (! node || linesWithoutParens.isEmpty()) {\n        return linesWithoutParens;\n    }\n\n    if (node.decorators &&\n        node.decorators.length > 0 &&\n        // If the parent node is an export declaration, it will be\n        // responsible for printing node.decorators.\n        ! util.getParentExportDeclaration(path)) {\n\n        path.each(function(decoratorPath) {\n            parts.push(printPath(decoratorPath), \"\\n\");\n        }, \"decorators\");\n\n    } else if (util.isExportDeclaration(node) &&\n               node.declaration &&\n               node.declaration.decorators) {\n        // Export declarations are responsible for printing any decorators\n        // that logically apply to node.declaration.\n        path.each(function(decoratorPath) {\n            parts.push(printPath(decoratorPath), \"\\n\");\n        }, \"declaration\", \"decorators\");\n\n    } else {\n        // Nodes with decorators can't have parentheses, so we can avoid\n        // computing path.needsParens() except in this case.\n        needsParens = path.needsParens();\n    }\n\n    if (needsParens) {\n        parts.unshift(\"(\");\n    }\n\n    parts.push(linesWithoutParens);\n\n    if (needsParens) {\n        parts.push(\")\");\n    }\n\n    return concat(parts);\n}\n\nfunction genericPrintNoParens(path, options, print) {\n    var n = path.getValue();\n\n    if (!n) {\n        return fromString(\"\");\n    }\n\n    if (typeof n === \"string\") {\n        return fromString(n, options);\n    }\n\n    namedTypes.Printable.assert(n);\n\n    var parts = [];\n\n    switch (n.type) {\n    case \"File\":\n        return path.call(print, \"program\");\n\n    case \"Program\":\n        // Babel 6\n        if (n.directives) {\n            path.each(function(childPath) {\n                parts.push(print(childPath), \";\\n\");\n            }, \"directives\");\n        }\n\n        parts.push(path.call(function(bodyPath) {\n            return printStatementSequence(bodyPath, options, print);\n        }, \"body\"));\n\n        return concat(parts);\n\n    case \"Noop\": // Babel extension.\n    case \"EmptyStatement\":\n        return fromString(\"\");\n\n    case \"ExpressionStatement\":\n        return concat([path.call(print, \"expression\"), \";\"]);\n\n    case \"ParenthesizedExpression\": // Babel extension.\n        return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"AssignmentExpression\":\n        return fromString(\" \").join([\n            path.call(print, \"left\"),\n            n.operator,\n            path.call(print, \"right\")\n        ]);\n\n    case \"AssignmentPattern\":\n        return concat([\n            path.call(print, \"left\"),\n            \" = \",\n            path.call(print, \"right\")\n        ]);\n\n    case \"MemberExpression\":\n        parts.push(path.call(print, \"object\"));\n\n        var property = path.call(print, \"property\");\n        if (n.computed) {\n            parts.push(\"[\", property, \"]\");\n        } else {\n            parts.push(\".\", property);\n        }\n\n        return concat(parts);\n\n    case \"MetaProperty\":\n        return concat([\n            path.call(print, \"meta\"),\n            \".\",\n            path.call(print, \"property\")\n        ]);\n\n    case \"BindExpression\":\n        if (n.object) {\n            parts.push(path.call(print, \"object\"));\n        }\n\n        parts.push(\"::\", path.call(print, \"callee\"));\n\n        return concat(parts);\n\n    case \"Path\":\n        return fromString(\".\").join(n.body);\n\n    case \"Identifier\":\n        return concat([\n            fromString(n.name, options),\n            path.call(print, \"typeAnnotation\")\n        ]);\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\": // Babel 6 for ObjectPattern\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n        return concat([\"...\", path.call(print, \"argument\")]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n        if (n.async)\n            parts.push(\"async \");\n\n        parts.push(\"function\");\n\n        if (n.generator)\n            parts.push(\"*\");\n\n        if (n.id) {\n            parts.push(\n                \" \",\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\")\n            );\n        }\n\n        parts.push(\n            \"(\",\n            printFunctionParams(path, options, print),\n            \")\",\n            path.call(print, \"returnType\"),\n            \" \",\n            path.call(print, \"body\")\n        );\n\n        return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n        if (n.async)\n            parts.push(\"async \");\n\n        if (n.typeParameters) {\n            parts.push(path.call(print, \"typeParameters\"));\n        }\n\n        if (\n            !options.arrowParensAlways &&\n            n.params.length === 1 &&\n            !n.rest &&\n            n.params[0].type === 'Identifier' &&\n            !n.params[0].typeAnnotation &&\n            !n.returnType\n        ) {\n            parts.push(path.call(print, \"params\", 0));\n        } else {\n            parts.push(\n                \"(\",\n                printFunctionParams(path, options, print),\n                \")\",\n                path.call(print, \"returnType\")\n            );\n        }\n\n        parts.push(\" => \", path.call(print, \"body\"));\n\n        return concat(parts);\n\n    case \"MethodDefinition\":\n        if (n.static) {\n            parts.push(\"static \");\n        }\n\n        parts.push(printMethod(path, options, print));\n\n        return concat(parts);\n\n    case \"YieldExpression\":\n        parts.push(\"yield\");\n\n        if (n.delegate)\n            parts.push(\"*\");\n\n        if (n.argument)\n            parts.push(\" \", path.call(print, \"argument\"));\n\n        return concat(parts);\n\n    case \"AwaitExpression\":\n        parts.push(\"await\");\n\n        if (n.all)\n            parts.push(\"*\");\n\n        if (n.argument)\n            parts.push(\" \", path.call(print, \"argument\"));\n\n        return concat(parts);\n\n    case \"ModuleDeclaration\":\n        parts.push(\"module\", path.call(print, \"id\"));\n\n        if (n.source) {\n            assert.ok(!n.body);\n            parts.push(\"from\", path.call(print, \"source\"));\n        } else {\n            parts.push(path.call(print, \"body\"));\n        }\n\n        return fromString(\" \").join(parts);\n\n    case \"ImportSpecifier\":\n        if (n.imported) {\n            parts.push(path.call(print, \"imported\"));\n            if (n.local &&\n                n.local.name !== n.imported.name) {\n                parts.push(\" as \", path.call(print, \"local\"));\n            }\n        } else if (n.id) {\n            parts.push(path.call(print, \"id\"));\n            if (n.name) {\n                parts.push(\" as \", path.call(print, \"name\"));\n            }\n        }\n\n        return concat(parts);\n\n    case \"ExportSpecifier\":\n        if (n.local) {\n            parts.push(path.call(print, \"local\"));\n            if (n.exported &&\n                n.exported.name !== n.local.name) {\n                parts.push(\" as \", path.call(print, \"exported\"));\n            }\n        } else if (n.id) {\n            parts.push(path.call(print, \"id\"));\n            if (n.name) {\n                parts.push(\" as \", path.call(print, \"name\"));\n            }\n        }\n\n        return concat(parts);\n\n    case \"ExportBatchSpecifier\":\n        return fromString(\"*\");\n\n    case \"ImportNamespaceSpecifier\":\n        parts.push(\"* as \");\n        if (n.local) {\n            parts.push(path.call(print, \"local\"));\n        } else if (n.id) {\n            parts.push(path.call(print, \"id\"));\n        }\n        return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n        if (n.local) {\n            return path.call(print, \"local\");\n        }\n        return path.call(print, \"id\");\n\n    case \"ExportDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n        return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n        parts.push(\"export *\");\n\n        if (n.exported) {\n            parts.push(\" as \", path.call(print, \"exported\"));\n        }\n\n        parts.push(\n            \" from \",\n            path.call(print, \"source\")\n        );\n\n        return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n        return concat([\"* as \", path.call(print, \"exported\")]);\n\n    case \"ExportDefaultSpecifier\":\n        return path.call(print, \"exported\");\n\n    case \"Import\":\n        return fromString(\"import\", options);\n\n    case \"ImportDeclaration\":\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n            parts.push(n.importKind + \" \");\n        }\n\n        if (n.specifiers &&\n            n.specifiers.length > 0) {\n\n            var foundImportSpecifier = false;\n\n            path.each(function(specifierPath) {\n                var i = specifierPath.getName();\n                if (i > 0) {\n                    parts.push(\", \");\n                }\n\n                var value = specifierPath.getValue();\n\n                if (namedTypes.ImportDefaultSpecifier.check(value) ||\n                    namedTypes.ImportNamespaceSpecifier.check(value)) {\n                    assert.strictEqual(foundImportSpecifier, false);\n                } else {\n                    namedTypes.ImportSpecifier.assert(value);\n                    if (!foundImportSpecifier) {\n                        foundImportSpecifier = true;\n                        parts.push(\n                          options.objectCurlySpacing ? \"{ \" : \"{\"\n                        );\n                    }\n                }\n\n                parts.push(print(specifierPath));\n            }, \"specifiers\");\n\n            if (foundImportSpecifier) {\n                parts.push(\n                  options.objectCurlySpacing ? \" }\" : \"}\"\n                );\n            }\n\n            parts.push(\" from \");\n        }\n\n        parts.push(path.call(print, \"source\"), \";\");\n\n        return concat(parts);\n\n    case \"BlockStatement\":\n        var naked = path.call(function(bodyPath) {\n            return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n\n\n        if (naked.isEmpty()) {\n            if (!n.directives || n.directives.length === 0) {\n                return fromString(\"{}\");\n            }\n        }\n\n        parts.push(\"{\\n\");\n        // Babel 6\n        if (n.directives) {\n            path.each(function(childPath) {\n                parts.push(\n                    print(childPath).indent(options.tabWidth),\n                    \";\",\n                    n.directives.length > 1 || !naked.isEmpty() ? \"\\n\" : \"\"\n                );\n            }, \"directives\");\n        }\n        parts.push(naked.indent(options.tabWidth));\n        parts.push(\"\\n}\");\n\n        return concat(parts);\n\n    case \"ReturnStatement\":\n        parts.push(\"return\");\n\n        if (n.argument) {\n            var argLines = path.call(print, \"argument\");\n            if (argLines.startsWithComment() ||\n                (argLines.length > 1 &&\n                    namedTypes.JSXElement &&\n                    namedTypes.JSXElement.check(n.argument)\n                )) {\n                parts.push(\n                    \" (\\n\",\n                    argLines.indent(options.tabWidth),\n                    \"\\n)\"\n                );\n            } else {\n                parts.push(\" \", argLines);\n            }\n        }\n\n        parts.push(\";\");\n\n        return concat(parts);\n\n    case \"CallExpression\":\n        return concat([\n            path.call(print, \"callee\"),\n            printArgumentsList(path, options, print)\n        ]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n        var allowBreak = false;\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var separator = options.flowObjectCommas ? \",\" : (isTypeAnnotation ? \";\" : \",\");\n        var fields = [];\n\n        if (isTypeAnnotation) {\n            fields.push(\"indexers\", \"callProperties\");\n        }\n\n        fields.push(\"properties\");\n\n        var len = 0;\n        fields.forEach(function(field) {\n            len += n[field].length;\n        });\n\n        var oneLine = (isTypeAnnotation && len === 1) || len === 0;\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\";\n        parts.push(oneLine ? leftBrace : leftBrace + \"\\n\");\n        var leftBraceIndex = parts.length - 1;\n\n        var i = 0;\n        fields.forEach(function(field) {\n            path.each(function(childPath) {\n                var lines = print(childPath);\n\n                if (!oneLine) {\n                    lines = lines.indent(options.tabWidth);\n                }\n\n                var multiLine = !isTypeAnnotation && lines.length > 1;\n                if (multiLine && allowBreak) {\n                    // Similar to the logic for BlockStatement.\n                    parts.push(\"\\n\");\n                }\n\n                parts.push(lines);\n\n                if (i < len - 1) {\n                    // Add an extra line break if the previous object property\n                    // had a multi-line value.\n                    parts.push(separator + (multiLine ? \"\\n\\n\" : \"\\n\"));\n                    allowBreak = !multiLine;\n                } else if (len !== 1 && isTypeAnnotation) {\n                    parts.push(separator);\n                } else if (!oneLine && util.isTrailingCommaEnabled(options, \"objects\")) {\n                    parts.push(separator);\n                }\n                i++;\n            }, field);\n        });\n\n        parts.push(oneLine ? rightBrace : \"\\n\" + rightBrace);\n\n        if (i !== 0 && oneLine && options.objectCurlySpacing) {\n            parts[leftBraceIndex] = leftBrace + \" \";\n            parts[parts.length - 1] = \" \" + rightBrace;\n        }\n\n        return concat(parts);\n\n    case \"PropertyPattern\":\n        return concat([\n            path.call(print, \"key\"),\n            \": \",\n            path.call(print, \"pattern\")\n        ]);\n\n    case \"ObjectProperty\": // Babel 6\n    case \"Property\": // Non-standard AST node type.\n        if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n            return printMethod(path, options, print);\n        }\n\n        var key = path.call(print, \"key\");\n        if (n.computed) {\n            parts.push(\"[\", key, \"]\");\n        } else {\n            parts.push(key);\n        }\n\n        if (! n.shorthand) {\n            parts.push(\": \", path.call(print, \"value\"));\n        }\n\n        return concat(parts);\n\n    case \"ClassMethod\": // Babel 6\n        if (n.static) {\n            parts.push(\"static \");\n        }\n\n        return concat([parts, printObjectMethod(path, options, print)]);\n\n    case \"ObjectMethod\": // Babel 6\n        return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n        return concat([\"@\", path.call(print, \"expression\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n        var elems = n.elements,\n            len = elems.length;\n\n        var printed = path.map(print, \"elements\");\n        var joined = fromString(\", \").join(printed);\n        var oneLine = joined.getLineLength(1) <= options.wrapColumn;\n        if (oneLine) {\n          if (options.arrayBracketSpacing) {\n            parts.push(\"[ \");\n          } else {\n            parts.push(\"[\");\n          }\n        } else {\n          parts.push(\"[\\n\");\n        }\n\n        path.each(function(elemPath) {\n            var i = elemPath.getName();\n            var elem = elemPath.getValue();\n            if (!elem) {\n                // If the array expression ends with a hole, that hole\n                // will be ignored by the interpreter, but if it ends with\n                // two (or more) holes, we need to write out two (or more)\n                // commas so that the resulting code is interpreted with\n                // both (all) of the holes.\n                parts.push(\",\");\n            } else {\n                var lines = printed[i];\n                if (oneLine) {\n                    if (i > 0)\n                        parts.push(\" \");\n                } else {\n                    lines = lines.indent(options.tabWidth);\n                }\n                parts.push(lines);\n                if (i < len - 1 || (!oneLine && util.isTrailingCommaEnabled(options, \"arrays\")))\n                    parts.push(\",\");\n                if (!oneLine)\n                    parts.push(\"\\n\");\n            }\n        }, \"elements\");\n\n        if (oneLine && options.arrayBracketSpacing) {\n          parts.push(\" ]\");\n        } else {\n          parts.push(\"]\");\n        }\n\n        return concat(parts);\n\n    case \"SequenceExpression\":\n        return fromString(\", \").join(path.map(print, \"expressions\"));\n\n    case \"ThisExpression\":\n        return fromString(\"this\");\n\n    case \"Super\":\n        return fromString(\"super\");\n\n    case \"NullLiteral\": // Babel 6 Literal split\n        return fromString(\"null\");\n\n    case \"RegExpLiteral\": // Babel 6 Literal split\n        return fromString(n.extra.raw);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n    case \"NumericLiteral\": // Babel 6 Literal split\n    case \"StringLiteral\": // Babel 6 Literal split\n    case \"Literal\":\n        if (typeof n.value !== \"string\")\n            return fromString(n.value, options);\n\n        return fromString(nodeStr(n.value, options), options);\n\n    case \"Directive\": // Babel 6\n        return path.call(print, \"value\");\n\n    case \"DirectiveLiteral\": // Babel 6\n        return fromString(nodeStr(n.value, options));\n\n    case \"ModuleSpecifier\":\n        if (n.local) {\n            throw new Error(\n                \"The ESTree ModuleSpecifier type should be abstract\"\n            );\n        }\n\n        // The Esprima ModuleSpecifier type is just a string-valued\n        // Literal identifying the imported-from module.\n        return fromString(nodeStr(n.value, options), options);\n\n    case \"UnaryExpression\":\n        parts.push(n.operator);\n        if (/[a-z]$/.test(n.operator))\n            parts.push(\" \");\n        parts.push(path.call(print, \"argument\"));\n        return concat(parts);\n\n    case \"UpdateExpression\":\n        parts.push(\n            path.call(print, \"argument\"),\n            n.operator\n        );\n\n        if (n.prefix)\n            parts.reverse();\n\n        return concat(parts);\n\n    case \"ConditionalExpression\":\n        return concat([\n            \"(\", path.call(print, \"test\"),\n            \" ? \", path.call(print, \"consequent\"),\n            \" : \", path.call(print, \"alternate\"), \")\"\n        ]);\n\n    case \"NewExpression\":\n        parts.push(\"new \", path.call(print, \"callee\"));\n        var args = n.arguments;\n        if (args) {\n            parts.push(printArgumentsList(path, options, print));\n        }\n\n        return concat(parts);\n\n    case \"VariableDeclaration\":\n        parts.push(n.kind, \" \");\n        var maxLen = 0;\n        var printed = path.map(function(childPath) {\n            var lines = print(childPath);\n            maxLen = Math.max(lines.length, maxLen);\n            return lines;\n        }, \"declarations\");\n\n        if (maxLen === 1) {\n            parts.push(fromString(\", \").join(printed));\n        } else if (printed.length > 1 ) {\n            parts.push(\n                fromString(\",\\n\").join(printed)\n                    .indentTail(n.kind.length + 1)\n            );\n        } else {\n            parts.push(printed[0]);\n        }\n\n        // We generally want to terminate all variable declarations with a\n        // semicolon, except when they are children of for loops.\n        var parentNode = path.getParentNode();\n        if (!namedTypes.ForStatement.check(parentNode) &&\n            !namedTypes.ForInStatement.check(parentNode) &&\n            !(namedTypes.ForOfStatement &&\n              namedTypes.ForOfStatement.check(parentNode)) &&\n            !(namedTypes.ForAwaitStatement &&\n              namedTypes.ForAwaitStatement.check(parentNode))) {\n            parts.push(\";\");\n        }\n\n        return concat(parts);\n\n    case \"VariableDeclarator\":\n        return n.init ? fromString(\" = \").join([\n            path.call(print, \"id\"),\n            path.call(print, \"init\")\n        ]) : path.call(print, \"id\");\n\n    case \"WithStatement\":\n        return concat([\n            \"with (\",\n            path.call(print, \"object\"),\n            \") \",\n            path.call(print, \"body\")\n        ]);\n\n    case \"IfStatement\":\n        var con = adjustClause(path.call(print, \"consequent\"), options),\n            parts = [\"if (\", path.call(print, \"test\"), \")\", con];\n\n        if (n.alternate)\n            parts.push(\n                endsWithBrace(con) ? \" else\" : \"\\nelse\",\n                adjustClause(path.call(print, \"alternate\"), options));\n\n        return concat(parts);\n\n    case \"ForStatement\":\n        // TODO Get the for (;;) case right.\n        var init = path.call(print, \"init\"),\n            sep = init.length > 1 ? \";\\n\" : \"; \",\n            forParen = \"for (\",\n            indented = fromString(sep).join([\n                init,\n                path.call(print, \"test\"),\n                path.call(print, \"update\")\n            ]).indentTail(forParen.length),\n            head = concat([forParen, indented, \")\"]),\n            clause = adjustClause(path.call(print, \"body\"), options),\n            parts = [head];\n\n        if (head.length > 1) {\n            parts.push(\"\\n\");\n            clause = clause.trimLeft();\n        }\n\n        parts.push(clause);\n\n        return concat(parts);\n\n    case \"WhileStatement\":\n        return concat([\n            \"while (\",\n            path.call(print, \"test\"),\n            \")\",\n            adjustClause(path.call(print, \"body\"), options)\n        ]);\n\n    case \"ForInStatement\":\n        // Note: esprima can't actually parse \"for each (\".\n        return concat([\n            n.each ? \"for each (\" : \"for (\",\n            path.call(print, \"left\"),\n            \" in \",\n            path.call(print, \"right\"),\n            \")\",\n            adjustClause(path.call(print, \"body\"), options)\n        ]);\n\n    case \"ForOfStatement\":\n        return concat([\n            \"for (\",\n            path.call(print, \"left\"),\n            \" of \",\n            path.call(print, \"right\"),\n            \")\",\n            adjustClause(path.call(print, \"body\"), options)\n        ]);\n\n    case \"ForAwaitStatement\":\n        return concat([\n            \"for await (\",\n            path.call(print, \"left\"),\n            \" of \",\n            path.call(print, \"right\"),\n            \")\",\n            adjustClause(path.call(print, \"body\"), options)\n        ]);\n\n    case \"DoWhileStatement\":\n        var doBody = concat([\n            \"do\",\n            adjustClause(path.call(print, \"body\"), options)\n        ]), parts = [doBody];\n\n        if (endsWithBrace(doBody))\n            parts.push(\" while\");\n        else\n            parts.push(\"\\nwhile\");\n\n        parts.push(\" (\", path.call(print, \"test\"), \");\");\n\n        return concat(parts);\n\n    case \"DoExpression\":\n        var statements = path.call(function(bodyPath) {\n            return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n\n        return concat([\n            \"do {\\n\",\n            statements.indent(options.tabWidth),\n            \"\\n}\"\n        ]);\n\n    case \"BreakStatement\":\n        parts.push(\"break\");\n        if (n.label)\n            parts.push(\" \", path.call(print, \"label\"));\n        parts.push(\";\");\n        return concat(parts);\n\n    case \"ContinueStatement\":\n        parts.push(\"continue\");\n        if (n.label)\n            parts.push(\" \", path.call(print, \"label\"));\n        parts.push(\";\");\n        return concat(parts);\n\n    case \"LabeledStatement\":\n        return concat([\n            path.call(print, \"label\"),\n            \":\\n\",\n            path.call(print, \"body\")\n        ]);\n\n    case \"TryStatement\":\n        parts.push(\n            \"try \",\n            path.call(print, \"block\")\n        );\n\n        if (n.handler) {\n            parts.push(\" \", path.call(print, \"handler\"));\n        } else if (n.handlers) {\n            path.each(function(handlerPath) {\n                parts.push(\" \", print(handlerPath));\n            }, \"handlers\");\n        }\n\n        if (n.finalizer) {\n            parts.push(\" finally \", path.call(print, \"finalizer\"));\n        }\n\n        return concat(parts);\n\n    case \"CatchClause\":\n        parts.push(\"catch (\", path.call(print, \"param\"));\n\n        if (n.guard)\n            // Note: esprima does not recognize conditional catch clauses.\n            parts.push(\" if \", path.call(print, \"guard\"));\n\n        parts.push(\") \", path.call(print, \"body\"));\n\n        return concat(parts);\n\n    case \"ThrowStatement\":\n        return concat([\"throw \", path.call(print, \"argument\"), \";\"]);\n\n    case \"SwitchStatement\":\n        return concat([\n            \"switch (\",\n            path.call(print, \"discriminant\"),\n            \") {\\n\",\n            fromString(\"\\n\").join(path.map(print, \"cases\")),\n            \"\\n}\"\n        ]);\n\n        // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchCase\":\n        if (n.test)\n            parts.push(\"case \", path.call(print, \"test\"), \":\");\n        else\n            parts.push(\"default:\");\n\n        if (n.consequent.length > 0) {\n            parts.push(\"\\n\", path.call(function(consequentPath) {\n                return printStatementSequence(consequentPath, options, print);\n            }, \"consequent\").indent(options.tabWidth));\n        }\n\n        return concat(parts);\n\n    case \"DebuggerStatement\":\n        return fromString(\"debugger;\");\n\n    // JSX extensions below.\n\n    case \"JSXAttribute\":\n        parts.push(path.call(print, \"name\"));\n        if (n.value)\n            parts.push(\"=\", path.call(print, \"value\"));\n        return concat(parts);\n\n    case \"JSXIdentifier\":\n        return fromString(n.name, options);\n\n    case \"JSXNamespacedName\":\n        return fromString(\":\").join([\n            path.call(print, \"namespace\"),\n            path.call(print, \"name\")\n        ]);\n\n    case \"JSXMemberExpression\":\n        return fromString(\".\").join([\n            path.call(print, \"object\"),\n            path.call(print, \"property\")\n        ]);\n\n    case \"JSXSpreadAttribute\":\n        return concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n\n    case \"JSXExpressionContainer\":\n        return concat([\"{\", path.call(print, \"expression\"), \"}\"]);\n\n    case \"JSXElement\":\n        var openingLines = path.call(print, \"openingElement\");\n\n        if (n.openingElement.selfClosing) {\n            assert.ok(!n.closingElement);\n            return openingLines;\n        }\n\n        var childLines = concat(\n            path.map(function(childPath) {\n                var child = childPath.getValue();\n\n                if (namedTypes.Literal.check(child) &&\n                    typeof child.value === \"string\") {\n                    if (/\\S/.test(child.value)) {\n                        return child.value.replace(/^\\s+|\\s+$/g, \"\");\n                    } else if (/\\n/.test(child.value)) {\n                        return \"\\n\";\n                    }\n                }\n\n                return print(childPath);\n            }, \"children\")\n        ).indentTail(options.tabWidth);\n\n        var closingLines = path.call(print, \"closingElement\");\n\n        return concat([\n            openingLines,\n            childLines,\n            closingLines\n        ]);\n\n    case \"JSXOpeningElement\":\n        parts.push(\"<\", path.call(print, \"name\"));\n        var attrParts = [];\n\n        path.each(function(attrPath) {\n            attrParts.push(\" \", print(attrPath));\n        }, \"attributes\");\n\n        var attrLines = concat(attrParts);\n\n        var needLineWrap = (\n            attrLines.length > 1 ||\n            attrLines.getLineLength(1) > options.wrapColumn\n        );\n\n        if (needLineWrap) {\n            attrParts.forEach(function(part, i) {\n                if (part === \" \") {\n                    assert.strictEqual(i % 2, 0);\n                    attrParts[i] = \"\\n\";\n                }\n            });\n\n            attrLines = concat(attrParts).indentTail(options.tabWidth);\n        }\n\n        parts.push(attrLines, n.selfClosing ? \" />\" : \">\");\n\n        return concat(parts);\n\n    case \"JSXClosingElement\":\n        return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXText\":\n        return fromString(n.value, options);\n\n    case \"JSXEmptyExpression\":\n        return fromString(\"\");\n\n    case \"TypeAnnotatedIdentifier\":\n        return concat([\n            path.call(print, \"annotation\"),\n            \" \",\n            path.call(print, \"identifier\")\n        ]);\n\n    case \"ClassBody\":\n        if (n.body.length === 0) {\n            return fromString(\"{}\");\n        }\n\n        return concat([\n            \"{\\n\",\n            path.call(function(bodyPath) {\n                return printStatementSequence(bodyPath, options, print);\n            }, \"body\").indent(options.tabWidth),\n            \"\\n}\"\n        ]);\n\n    case \"ClassPropertyDefinition\":\n        parts.push(\"static \", path.call(print, \"definition\"));\n        if (!namedTypes.MethodDefinition.check(n.definition))\n            parts.push(\";\");\n        return concat(parts);\n\n    case \"ClassProperty\":\n        if (n.static)\n            parts.push(\"static \");\n\n        var key = path.call(print, \"key\");\n        if (n.computed) {\n            key = concat([\"[\", key, \"]\"]);\n        } else if (n.variance === \"plus\") {\n            key = concat([\"+\", key]);\n        } else if (n.variance === \"minus\") {\n            key = concat([\"-\", key]);\n        }\n        parts.push(key);\n\n        if (n.typeAnnotation)\n            parts.push(path.call(print, \"typeAnnotation\"));\n\n        if (n.value)\n            parts.push(\" = \", path.call(print, \"value\"));\n\n        parts.push(\";\");\n        return concat(parts);\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n        parts.push(\"class\");\n\n        if (n.id) {\n            parts.push(\n                \" \",\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\")\n            );\n        }\n\n        if (n.superClass) {\n            parts.push(\n                \" extends \",\n                path.call(print, \"superClass\"),\n                path.call(print, \"superTypeParameters\")\n            );\n        }\n\n        if (n[\"implements\"] && n['implements'].length > 0) {\n            parts.push(\n                \" implements \",\n                fromString(\", \").join(path.map(print, \"implements\"))\n            );\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n\n        return concat(parts);\n\n    case \"TemplateElement\":\n        return fromString(n.value.raw, options).lockIndentTail();\n\n    case \"TemplateLiteral\":\n        var expressions = path.map(print, \"expressions\");\n        parts.push(\"`\");\n\n        path.each(function(childPath) {\n            var i = childPath.getName();\n            parts.push(print(childPath));\n            if (i < expressions.length) {\n                parts.push(\"${\", expressions[i], \"}\");\n            }\n        }, \"quasis\");\n\n        parts.push(\"`\");\n\n        return concat(parts).lockIndentTail();\n\n    case \"TaggedTemplateExpression\":\n        return concat([\n            path.call(print, \"tag\"),\n            path.call(print, \"quasi\")\n        ]);\n\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\": // Supertype of Block and Line.\n    case \"MemberTypeAnnotation\": // Flow\n    case \"TupleTypeAnnotation\": // Flow\n    case \"Type\": // Flow\n        throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n\n    case \"CommentBlock\": // Babel block comment.\n    case \"Block\": // Esprima block comment.\n        return concat([\"/*\", fromString(n.value, options), \"*/\"]);\n\n    case \"CommentLine\": // Babel line comment.\n    case \"Line\": // Esprima line comment.\n        return concat([\"//\", fromString(n.value, options)]);\n\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n    case \"TypeAnnotation\":\n        if (n.typeAnnotation) {\n            if (n.typeAnnotation.type !== \"FunctionTypeAnnotation\") {\n                parts.push(\": \");\n            }\n            parts.push(path.call(print, \"typeAnnotation\"));\n            return concat(parts);\n        }\n\n        return fromString(\"\");\n\n    case \"ExistentialTypeParam\":\n    case \"ExistsTypeAnnotation\":\n        return fromString(\"*\", options);\n\n    case \"EmptyTypeAnnotation\":\n        return fromString(\"empty\", options);\n\n    case \"AnyTypeAnnotation\":\n        return fromString(\"any\", options);\n\n    case \"MixedTypeAnnotation\":\n        return fromString(\"mixed\", options);\n\n    case \"ArrayTypeAnnotation\":\n        return concat([\n            path.call(print, \"elementType\"),\n            \"[]\"\n        ]);\n\n    case \"BooleanTypeAnnotation\":\n        return fromString(\"boolean\", options);\n\n    case \"BooleanLiteralTypeAnnotation\":\n        assert.strictEqual(typeof n.value, \"boolean\");\n        return fromString(\"\" + n.value, options);\n\n    case \"DeclareClass\":\n        return printFlowDeclaration(path, [\n            \"class \",\n            path.call(print, \"id\"),\n            \" \",\n            path.call(print, \"body\"),\n        ]);\n\n    case \"DeclareFunction\":\n        return printFlowDeclaration(path, [\n            \"function \",\n            path.call(print, \"id\"),\n            \";\"\n        ]);\n\n    case \"DeclareModule\":\n        return printFlowDeclaration(path, [\n            \"module \",\n            path.call(print, \"id\"),\n            \" \",\n            path.call(print, \"body\"),\n        ]);\n\n    case \"DeclareModuleExports\":\n        return printFlowDeclaration(path, [\n            \"module.exports\",\n            path.call(print, \"typeAnnotation\"),\n        ]);\n\n    case \"DeclareVariable\":\n        return printFlowDeclaration(path, [\n            \"var \",\n            path.call(print, \"id\"),\n            \";\"\n        ]);\n\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n        return concat([\n            \"declare \",\n            printExportDeclaration(path, options, print)\n        ]);\n\n    case \"FunctionTypeAnnotation\":\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function(a: B): void; OR\n        // var A: (a: B) => void;\n        var parent = path.getParentNode(0);\n        var isArrowFunctionTypeAnnotation = !(\n            namedTypes.ObjectTypeCallProperty.check(parent) ||\n            namedTypes.DeclareFunction.check(path.getParentNode(2))\n        );\n\n        var needsColon =\n            isArrowFunctionTypeAnnotation &&\n            !namedTypes.FunctionTypeParam.check(parent);\n\n        if (needsColon) {\n            parts.push(\": \");\n        }\n\n        parts.push(\n            \"(\",\n            fromString(\", \").join(path.map(print, \"params\")),\n            \")\"\n        );\n\n        // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n        if (n.returnType) {\n            parts.push(\n                isArrowFunctionTypeAnnotation ? \" => \" : \": \",\n                path.call(print, \"returnType\")\n            );\n        }\n\n        return concat(parts);\n\n    case \"FunctionTypeParam\":\n        return concat([\n            path.call(print, \"name\"),\n            n.optional ? '?' : '',\n            \": \",\n            path.call(print, \"typeAnnotation\"),\n        ]);\n\n    case \"GenericTypeAnnotation\":\n        return concat([\n            path.call(print, \"id\"),\n            path.call(print, \"typeParameters\")\n        ]);\n\n    case \"DeclareInterface\":\n        parts.push(\"declare \");\n\n    case \"InterfaceDeclaration\":\n        parts.push(\n            fromString(\"interface \", options),\n            path.call(print, \"id\"),\n            path.call(print, \"typeParameters\"),\n            \" \"\n        );\n\n        if (n[\"extends\"]) {\n            parts.push(\n                \"extends \",\n                fromString(\", \").join(path.map(print, \"extends\"))\n            );\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n\n        return concat(parts);\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n        return concat([\n            path.call(print, \"id\"),\n            path.call(print, \"typeParameters\")\n        ]);\n\n    case \"IntersectionTypeAnnotation\":\n        return fromString(\" & \").join(path.map(print, \"types\"));\n\n    case \"NullableTypeAnnotation\":\n        return concat([\n            \"?\",\n            path.call(print, \"typeAnnotation\")\n        ]);\n\n    case \"NullLiteralTypeAnnotation\":\n        return fromString(\"null\", options);\n\n    case \"ThisTypeAnnotation\":\n        return fromString(\"this\", options);\n\n    case \"NumberTypeAnnotation\":\n        return fromString(\"number\", options);\n\n    case \"ObjectTypeCallProperty\":\n        return path.call(print, \"value\");\n\n    case \"ObjectTypeIndexer\":\n        var variance =\n            n.variance === \"plus\" ? \"+\" :\n            n.variance === \"minus\" ? \"-\" : \"\";\n\n        return concat([\n            variance,\n            \"[\",\n            path.call(print, \"id\"),\n            \": \",\n            path.call(print, \"key\"),\n            \"]: \",\n            path.call(print, \"value\")\n        ]);\n\n    case \"ObjectTypeProperty\":\n        var variance =\n            n.variance === \"plus\" ? \"+\" :\n            n.variance === \"minus\" ? \"-\" : \"\";\n\n        return concat([\n            variance,\n            path.call(print, \"key\"),\n            n.optional ? \"?\" : \"\",\n            \": \",\n            path.call(print, \"value\")\n        ]);\n\n    case \"QualifiedTypeIdentifier\":\n        return concat([\n            path.call(print, \"qualification\"),\n            \".\",\n            path.call(print, \"id\")\n        ]);\n\n    case \"StringLiteralTypeAnnotation\":\n        return fromString(nodeStr(n.value, options), options);\n\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumericLiteralTypeAnnotation\":\n        assert.strictEqual(typeof n.value, \"number\");\n        return fromString(JSON.stringify(n.value), options);\n\n    case \"StringTypeAnnotation\":\n        return fromString(\"string\", options);\n\n    case \"DeclareTypeAlias\":\n        parts.push(\"declare \");\n\n    case \"TypeAlias\":\n        return concat([\n            \"type \",\n            path.call(print, \"id\"),\n            path.call(print, \"typeParameters\"),\n            \" = \",\n            path.call(print, \"right\"),\n            \";\"\n        ]);\n\n    case \"TypeCastExpression\":\n        return concat([\n            \"(\",\n            path.call(print, \"expression\"),\n            path.call(print, \"typeAnnotation\"),\n            \")\"\n        ]);\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n        return concat([\n            \"<\",\n            fromString(\", \").join(path.map(print, \"params\")),\n            \">\"\n        ]);\n    case \"TypeParameter\":\n        switch (n.variance) {\n            case 'plus':\n                parts.push('+');\n                break;\n            case 'minus':\n                parts.push('-');\n                break;\n            default:\n        }\n\n        parts.push(path.call(print, 'name'));\n\n        if (n.bound) {\n            parts.push(path.call(print, 'bound'));\n        }\n\n        if (n['default']) {\n            parts.push('=', path.call(print, 'default'));\n        }\n\n        return concat(parts);\n\n    case \"TypeofTypeAnnotation\":\n        return concat([\n            fromString(\"typeof \", options),\n            path.call(print, \"argument\")\n        ]);\n\n    case \"UnionTypeAnnotation\":\n        return fromString(\" | \").join(path.map(print, \"types\"));\n\n    case \"VoidTypeAnnotation\":\n        return fromString(\"void\", options);\n\n    case \"NullTypeAnnotation\":\n        return fromString(\"null\", options);\n\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n    case \"ClassHeritage\": // TODO\n    case \"ComprehensionBlock\": // TODO\n    case \"ComprehensionExpression\": // TODO\n    case \"Glob\": // TODO\n    case \"GeneratorExpression\": // TODO\n    case \"LetStatement\": // TODO\n    case \"LetExpression\": // TODO\n    case \"GraphExpression\": // TODO\n    case \"GraphIndexExpression\": // TODO\n\n    // XML types that nobody cares about or needs to print.\n    case \"XMLDefaultDeclaration\":\n    case \"XMLAnyName\":\n    case \"XMLQualifiedIdentifier\":\n    case \"XMLFunctionQualifiedIdentifier\":\n    case \"XMLAttributeSelector\":\n    case \"XMLFilterExpression\":\n    case \"XML\":\n    case \"XMLElement\":\n    case \"XMLList\":\n    case \"XMLEscape\":\n    case \"XMLText\":\n    case \"XMLStartTag\":\n    case \"XMLEndTag\":\n    case \"XMLPointTag\":\n    case \"XMLName\":\n    case \"XMLAttribute\":\n    case \"XMLCdata\":\n    case \"XMLComment\":\n    case \"XMLProcessingInstruction\":\n    default:\n        debugger;\n        throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n    }\n\n    return p;\n}\n\nfunction printStatementSequence(path, options, print) {\n    var inClassBody =\n        namedTypes.ClassBody &&\n        namedTypes.ClassBody.check(path.getParentNode());\n\n    var filtered = [];\n    var sawComment = false;\n    var sawStatement = false;\n\n    path.each(function(stmtPath) {\n        var i = stmtPath.getName();\n        var stmt = stmtPath.getValue();\n\n        // Just in case the AST has been modified to contain falsy\n        // \"statements,\" it's safer simply to skip them.\n        if (!stmt) {\n            return;\n        }\n\n        // Skip printing EmptyStatement nodes to avoid leaving stray\n        // semicolons lying around.\n        if (stmt.type === \"EmptyStatement\") {\n            return;\n        }\n\n        if (namedTypes.Comment.check(stmt)) {\n            // The pretty printer allows a dangling Comment node to act as\n            // a Statement when the Comment can't be attached to any other\n            // non-Comment node in the tree.\n            sawComment = true;\n        } else if (namedTypes.Statement.check(stmt)) {\n            sawStatement = true;\n        } else {\n            // When the pretty printer encounters a string instead of an\n            // AST node, it just prints the string. This behavior can be\n            // useful for fine-grained formatting decisions like inserting\n            // blank lines.\n            isString.assert(stmt);\n        }\n\n        // We can't hang onto stmtPath outside of this function, because\n        // it's just a reference to a mutable FastPath object, so we have\n        // to go ahead and print it here.\n        filtered.push({\n            node: stmt,\n            printed: print(stmtPath)\n        });\n    });\n\n    if (sawComment) {\n        assert.strictEqual(\n            sawStatement, false,\n            \"Comments may appear as statements in otherwise empty statement \" +\n                \"lists, but may not coexist with non-Comment nodes.\"\n        );\n    }\n\n    var prevTrailingSpace = null;\n    var len = filtered.length;\n    var parts = [];\n\n    filtered.forEach(function(info, i) {\n        var printed = info.printed;\n        var stmt = info.node;\n        var multiLine = printed.length > 1;\n        var notFirst = i > 0;\n        var notLast = i < len - 1;\n        var leadingSpace;\n        var trailingSpace;\n        var lines = stmt && stmt.loc && stmt.loc.lines;\n        var trueLoc = lines && options.reuseWhitespace &&\n            util.getTrueLoc(stmt, lines);\n\n        if (notFirst) {\n            if (trueLoc) {\n                var beforeStart = lines.skipSpaces(trueLoc.start, true);\n                var beforeStartLine = beforeStart ? beforeStart.line : 1;\n                var leadingGap = trueLoc.start.line - beforeStartLine;\n                leadingSpace = Array(leadingGap + 1).join(\"\\n\");\n            } else {\n                leadingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n            }\n        } else {\n            leadingSpace = \"\";\n        }\n\n        if (notLast) {\n            if (trueLoc) {\n                var afterEnd = lines.skipSpaces(trueLoc.end);\n                var afterEndLine = afterEnd ? afterEnd.line : lines.length;\n                var trailingGap = afterEndLine - trueLoc.end.line;\n                trailingSpace = Array(trailingGap + 1).join(\"\\n\");\n            } else {\n                trailingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n            }\n        } else {\n            trailingSpace = \"\";\n        }\n\n        parts.push(\n            maxSpace(prevTrailingSpace, leadingSpace),\n            printed\n        );\n\n        if (notLast) {\n            prevTrailingSpace = trailingSpace;\n        } else if (trailingSpace) {\n            parts.push(trailingSpace);\n        }\n    });\n\n    return concat(parts);\n}\n\nfunction maxSpace(s1, s2) {\n    if (!s1 && !s2) {\n        return fromString(\"\");\n    }\n\n    if (!s1) {\n        return fromString(s2);\n    }\n\n    if (!s2) {\n        return fromString(s1);\n    }\n\n    var spaceLines1 = fromString(s1);\n    var spaceLines2 = fromString(s2);\n\n    if (spaceLines2.length > spaceLines1.length) {\n        return spaceLines2;\n    }\n\n    return spaceLines1;\n}\n\nfunction printMethod(path, options, print) {\n    var node = path.getNode();\n    var kind = node.kind;\n    var parts = [];\n\n    if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\") {\n        node.value = node;\n    } else {\n        namedTypes.FunctionExpression.assert(node.value);\n    }\n\n    if (node.value.async) {\n        parts.push(\"async \");\n    }\n\n    if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n        if (node.value.generator) {\n            parts.push(\"*\");\n        }\n    } else {\n        assert.ok(kind === \"get\" || kind === \"set\");\n        parts.push(kind, \" \");\n    }\n\n    var key = path.call(print, \"key\");\n    if (node.computed) {\n        key = concat([\"[\", key, \"]\"]);\n    }\n\n    parts.push(\n        key,\n        path.call(print, \"value\", \"typeParameters\"),\n        \"(\",\n        path.call(function(valuePath) {\n            return printFunctionParams(valuePath, options, print);\n        }, \"value\"),\n        \")\",\n        path.call(print, \"value\", \"returnType\"),\n        \" \",\n        path.call(print, \"value\", \"body\")\n    );\n\n    return concat(parts);\n}\n\nfunction printArgumentsList(path, options, print) {\n    var printed = path.map(print, \"arguments\");\n    var trailingComma = util.isTrailingCommaEnabled(options, \"parameters\");\n\n    var joined = fromString(\", \").join(printed);\n    if (joined.getLineLength(1) > options.wrapColumn) {\n        joined = fromString(\",\\n\").join(printed);\n        return concat([\n            \"(\\n\",\n            joined.indent(options.tabWidth),\n            trailingComma ? \",\\n)\" : \"\\n)\"\n        ]);\n    }\n\n    return concat([\"(\", joined, \")\"]);\n}\n\nfunction printFunctionParams(path, options, print) {\n    var fun = path.getValue();\n\n    namedTypes.Function.assert(fun);\n\n    var printed = path.map(print, \"params\");\n\n    if (fun.defaults) {\n        path.each(function(defExprPath) {\n            var i = defExprPath.getName();\n            var p = printed[i];\n            if (p && defExprPath.getValue()) {\n                printed[i] = concat([p, \" = \", print(defExprPath)]);\n            }\n        }, \"defaults\");\n    }\n\n    if (fun.rest) {\n        printed.push(concat([\"...\", path.call(print, \"rest\")]));\n    }\n\n    var joined = fromString(\", \").join(printed);\n    if (joined.length > 1 ||\n        joined.getLineLength(1) > options.wrapColumn) {\n        joined = fromString(\",\\n\").join(printed);\n        if (util.isTrailingCommaEnabled(options, \"parameters\") &&\n            !fun.rest &&\n            fun.params[fun.params.length - 1].type !== 'RestElement') {\n            joined = concat([joined, \",\\n\"]);\n        } else {\n            joined = concat([joined, \"\\n\"]);\n        }\n        return concat([\"\\n\", joined.indent(options.tabWidth)]);\n    }\n\n    return joined;\n}\n\nfunction printObjectMethod(path, options, print) {\n    var objMethod = path.getValue();\n    var parts = [];\n\n    if (objMethod.async)\n        parts.push(\"async \");\n\n    if (objMethod.generator)\n        parts.push(\"*\");\n\n    if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n        return printMethod(path, options, print);\n    }\n\n    var key = path.call(print, \"key\");\n    if (objMethod.computed) {\n        parts.push(\"[\", key, \"]\");\n    } else {\n        parts.push(key);\n    }\n\n    parts.push(\n        \"(\",\n        printFunctionParams(path, options, print),\n        \")\",\n        path.call(print, \"returnType\"),\n        \" \",\n        path.call(print, \"body\")\n    );\n\n    return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n    var decl = path.getValue();\n    var parts = [\"export \"];\n    var shouldPrintSpaces = options.objectCurlySpacing;\n\n    namedTypes.Declaration.assert(decl);\n\n    if (decl[\"default\"] ||\n        decl.type === \"ExportDefaultDeclaration\") {\n        parts.push(\"default \");\n    }\n\n    if (decl.declaration) {\n        parts.push(path.call(print, \"declaration\"));\n\n    } else if (decl.specifiers &&\n               decl.specifiers.length > 0) {\n\n        if (decl.specifiers.length === 1 &&\n            decl.specifiers[0].type === \"ExportBatchSpecifier\") {\n            parts.push(\"*\");\n        } else {\n            parts.push(\n                shouldPrintSpaces ? \"{ \" : \"{\",\n                fromString(\", \").join(path.map(print, \"specifiers\")),\n                shouldPrintSpaces ? \" }\" : \"}\"\n            );\n        }\n\n        if (decl.source) {\n            parts.push(\" from \", path.call(print, \"source\"));\n        }\n    }\n\n    var lines = concat(parts);\n\n    if (lastNonSpaceCharacter(lines) !== \";\" &&\n        ! (decl.declaration &&\n           (decl.declaration.type === \"FunctionDeclaration\" ||\n            decl.declaration.type === \"ClassDeclaration\"))) {\n        lines = concat([lines, \";\"]);\n    }\n\n    return lines;\n}\n\nfunction printFlowDeclaration(path, parts) {\n    var parentExportDecl = util.getParentExportDeclaration(path);\n\n    if (parentExportDecl) {\n        assert.strictEqual(\n            parentExportDecl.type,\n            \"DeclareExportDeclaration\"\n        );\n    } else {\n        // If the parent node has type DeclareExportDeclaration, then it\n        // will be responsible for printing the \"declare\" token. Otherwise\n        // it needs to be printed with this non-exported declaration node.\n        parts.unshift(\"declare \");\n    }\n\n    return concat(parts);\n}\n\nfunction adjustClause(clause, options) {\n    if (clause.length > 1)\n        return concat([\" \", clause]);\n\n    return concat([\n        \"\\n\",\n        maybeAddSemicolon(clause).indent(options.tabWidth)\n    ]);\n}\n\nfunction lastNonSpaceCharacter(lines) {\n    var pos = lines.lastPos();\n    do {\n        var ch = lines.charAt(pos);\n        if (/\\S/.test(ch))\n            return ch;\n    } while (lines.prevPos(pos));\n}\n\nfunction endsWithBrace(lines) {\n    return lastNonSpaceCharacter(lines) === \"}\";\n}\n\nfunction swapQuotes(str) {\n    return str.replace(/['\"]/g, function(m) {\n        return m === '\"' ? '\\'' : '\"';\n    });\n}\n\nfunction nodeStr(str, options) {\n    isString.assert(str);\n    switch (options.quote) {\n    case \"auto\":\n        var double = JSON.stringify(str);\n        var single = swapQuotes(JSON.stringify(swapQuotes(str)));\n        return double.length > single.length ? single : double;\n    case \"single\":\n        return swapQuotes(JSON.stringify(swapQuotes(str)));\n    case \"double\":\n    default:\n        return JSON.stringify(str);\n    }\n}\n\nfunction maybeAddSemicolon(lines) {\n    var eoc = lastNonSpaceCharacter(lines);\n    if (!eoc || \"\\n};\".indexOf(eoc) < 0)\n        return concat([lines, \";\"]);\n    return lines;\n}\n"]}