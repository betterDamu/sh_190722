{"version":3,"sources":["index.js","visit.js","hoist.js","util.js","emit.js","leap.js","meta.js","replaceShorthandObjectMethod.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;AGRA,AFMA,AFMA,AGTA,AFMA;AGRA,AFMA,AFMA,AGTA,AFMA;AGRA,AFMA,AFMA,AGTA,AFMA;AGRA,AFMA,AFMA,AKfA,AFMA,AFMA;AGRA,AFMA,AFMA,AKfA,AFMA,AFMA;AGRA,AFMA,AFMA,AKfA,AFMA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,AHSA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AFMA,AKfA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,AJYA,AFMA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ACHA,ANkBA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,ACHA,ALeA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,AFMA,AGTA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,ACHA,AJYA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\nexports.default = _default;\n\nvar _visit = require(\"./visit\");\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction _default(context) {\n  var plugin = {\n    visitor: (0, _visit.getVisitor)(context)\n  }; // Some presets manually call child presets, but fail to pass along the\n  // context object. Out of an abundance of caution, we verify that it\n  // exists first to avoid causing unnecessary breaking changes.\n\n  var version = context && context.version; // The \"name\" property is not allowed in older versions of Babel (6.x)\n  // and will cause the plugin validator to throw an exception.\n\n  if (version && parseInt(version, 10) >= 7) {\n    plugin.name = \"regenerator-transform\";\n  }\n\n  return plugin;\n}","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nvar _private = require(\"private\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n\n        if (node.generator) {\n          if (node.async) {\n            // Async generator\n            if (state.opts.asyncGenerators === false) return;\n          } else {\n            // Plain generator\n            if (state.opts.generators === false) return;\n          }\n        } else if (node.async) {\n          // Async function\n          if (state.opts.async === false) return;\n        } else {\n          // Not a generator or async function.\n          return;\n        } // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n\n        path = (0, _replaceShorthandObjectMethod.default)(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          var argumentIdentifier = t.identifier(\"arguments\"); // we need to do this as otherwise arguments in arrow functions gets hoisted\n\n          argumentIdentifier._shadowedFunctionLiteral = path;\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), argumentIdentifier));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody);\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar getMarkInfo = (0, _private.makeAccessor)();\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert.default.ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert.default.strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert.default.strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration\": function FunctionExpressionFunctionDeclaration(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasOwn = Object.prototype.hasOwnProperty; // The hoist function takes a FunctionExpression or FunctionDeclaration\n// and replaces any Declaration nodes in its body with assignments, then\n// returns a VariableDeclaration containing just the names of the removed\n// declarations.\n\nexports.hoist = function (funPath) {\n  var t = util.getTypes();\n  t.assertFunction(funPath.node);\n  var vars = {};\n\n  function varDeclToExpr(vdec, includeIdentifiers) {\n    t.assertVariableDeclaration(vdec); // TODO assert.equal(vdec.kind, \"var\");\n\n    var exprs = [];\n    vdec.declarations.forEach(function (dec) {\n      // Note: We duplicate 'dec.id' here to ensure that the variable declaration IDs don't\n      // have the same 'loc' value, since that can make sourcemaps and retainLines behave poorly.\n      vars[dec.id.name] = t.identifier(dec.id.name);\n\n      if (dec.init) {\n        exprs.push(t.assignmentExpression(\"=\", dec.id, dec.init));\n      } else if (includeIdentifiers) {\n        exprs.push(dec.id);\n      }\n    });\n    if (exprs.length === 0) return null;\n    if (exprs.length === 1) return exprs[0];\n    return t.sequenceExpression(exprs);\n  }\n\n  funPath.get(\"body\").traverse({\n    VariableDeclaration: {\n      exit: function exit(path) {\n        var expr = varDeclToExpr(path.node, false);\n\n        if (expr === null) {\n          path.remove();\n        } else {\n          // We don't need to traverse this expression any further because\n          // there can't be any new declarations inside an expression.\n          util.replaceWithOrRemove(path, t.expressionStatement(expr));\n        } // Since the original node has been either removed or replaced,\n        // avoid traversing it any further.\n\n\n        path.skip();\n      }\n    },\n    ForStatement: function ForStatement(path) {\n      var init = path.node.init;\n\n      if (t.isVariableDeclaration(init)) {\n        util.replaceWithOrRemove(path.get(\"init\"), varDeclToExpr(init, false));\n      }\n    },\n    ForXStatement: function ForXStatement(path) {\n      var left = path.get(\"left\");\n\n      if (left.isVariableDeclaration()) {\n        util.replaceWithOrRemove(left, varDeclToExpr(left.node, true));\n      }\n    },\n    FunctionDeclaration: function FunctionDeclaration(path) {\n      var node = path.node;\n      vars[node.id.name] = node.id;\n      var assignment = t.expressionStatement(t.assignmentExpression(\"=\", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));\n\n      if (path.parentPath.isBlockStatement()) {\n        // Insert the assignment form before the first statement in the\n        // enclosing block.\n        path.parentPath.unshiftContainer(\"body\", assignment); // Remove the function declaration now that we've inserted the\n        // equivalent assignment form at the beginning of the block.\n\n        path.remove();\n      } else {\n        // If the parent node is not a block statement, then we can just\n        // replace the declaration with the equivalent assignment form\n        // without worrying about hoisting it.\n        util.replaceWithOrRemove(path, assignment);\n      } // Don't hoist variables out of inner functions.\n\n\n      path.skip();\n    },\n    FunctionExpression: function FunctionExpression(path) {\n      // Don't descend into nested function expressions.\n      path.skip();\n    },\n    ArrowFunctionExpression: function ArrowFunctionExpression(path) {\n      // Don't descend into nested function expressions.\n      path.skip();\n    }\n  });\n  var paramNames = {};\n  funPath.get(\"params\").forEach(function (paramPath) {\n    var param = paramPath.node;\n\n    if (t.isIdentifier(param)) {\n      paramNames[param.name] = param;\n    } else {// Variables declared by destructuring parameter patterns will be\n      // harmlessly re-declared.\n    }\n  });\n  var declarations = [];\n  Object.keys(vars).forEach(function (name) {\n    if (!hasOwn.call(paramNames, name)) {\n      declarations.push(t.variableDeclarator(vars[name], null));\n    }\n  });\n\n  if (declarations.length === 0) {\n    return null; // Be sure to handle this case!\n  }\n\n  return t.variableDeclaration(\"var\", declarations);\n};","\n\nexports.__esModule = true;\nexports.wrapWithTypes = wrapWithTypes;\nexports.getTypes = getTypes;\nexports.runtimeProperty = runtimeProperty;\nexports.isReference = isReference;\nexports.replaceWithOrRemove = replaceWithOrRemove;\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar currentTypes = null;\n\nfunction wrapWithTypes(types, fn) {\n  return function () {\n    var oldTypes = currentTypes;\n    currentTypes = types;\n\n    try {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return fn.apply(this, args);\n    } finally {\n      currentTypes = oldTypes;\n    }\n  };\n}\n\nfunction getTypes() {\n  return currentTypes;\n}\n\nfunction runtimeProperty(name) {\n  var t = getTypes();\n  return t.memberExpression(t.identifier(\"regeneratorRuntime\"), t.identifier(name), false);\n}\n\nfunction isReference(path) {\n  return path.isReferenced() || path.parentPath.isAssignmentExpression({\n    left: path.node\n  });\n}\n\nfunction replaceWithOrRemove(path, replacement) {\n  if (replacement) {\n    path.replaceWith(replacement);\n  } else {\n    path.remove();\n  }\n}","\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar leap = _interopRequireWildcard(require(\"./leap\"));\n\nvar meta = _interopRequireWildcard(require(\"./meta\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  _assert.default.ok(this instanceof Emitter);\n\n  util.getTypes().assertIdentifier(contextId); // Used to generate unique temporary names.\n\n  this.nextTempId = 0; // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n\n  this.contextId = contextId; // An append-only list of Statements that grows each time this.emit is\n  // called.\n\n  this.listing = []; // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n\n  this.marked = [true];\n  this.insertedLocs = new Set(); // The last location will be marked when this.getDispatchLoop is\n  // called.\n\n  this.finalLoc = this.loc(); // A list of all leap.TryEntry statements emitted.\n\n  this.tryEntries = []; // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n\n  this.leapManager = new leap.LeapManager(this);\n}\n\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter; // Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n\nEp.loc = function () {\n  var l = util.getTypes().numericLiteral(-1);\n  this.insertedLocs.add(l);\n  return l;\n};\n\nEp.getInsertedLocs = function () {\n  return this.insertedLocs;\n};\n\nEp.getContextId = function () {\n  return util.getTypes().clone(this.contextId);\n}; // Sets the exact value of the given location to the offset of the next\n// Statement emitted.\n\n\nEp.mark = function (loc) {\n  util.getTypes().assertLiteral(loc);\n  var index = this.listing.length;\n\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    _assert.default.strictEqual(loc.value, index);\n  }\n\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function (node) {\n  var t = util.getTypes();\n\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n}; // Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\n\n\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n}; // Shorthand for an assignment statement.\n\n\nEp.assign = function (lhs, rhs) {\n  var t = util.getTypes();\n  return t.expressionStatement(t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n}; // Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\n\n\nEp.contextProperty = function (name, computed) {\n  var t = util.getTypes();\n  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n}; // Shorthand for setting context.rval and jumping to `context.stop()`.\n\n\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function (valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\n\nEp.clearPendingException = function (tryLoc, assignee) {\n  var t = util.getTypes();\n  t.assertLiteral(tryLoc);\n  var catchCall = t.callExpression(this.contextProperty(\"catch\", true), [t.clone(tryLoc)]);\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n}; // Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\n\n\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n}; // Conditional jump.\n\n\nEp.jumpIf = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Conditional jump, with the condition negated.\n\n\nEp.jumpIfNot = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  var negatedTest;\n\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\n\n\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function (id) {\n  var t = util.getTypes();\n  return t.functionExpression(id || null\n  /*Anonymous*/\n  , [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, // Not a generator anymore!\n  false // Nor an expression.\n  );\n}; // Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\n\n\nEp.getDispatchLoop = function () {\n  var self = this;\n  var t = util.getTypes();\n  var cases = [];\n  var current; // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n\n  var alreadyEnded = false;\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  }); // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n\n  this.finalLoc.value = this.listing.length;\n  cases.push(t.switchCase(this.finalLoc, [// Intentionally fall through to the \"end\" case...\n  ]), // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [// This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\n\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  var t = util.getTypes();\n  var lastLocValue = 0;\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    var thisLocValue = tryEntry.firstLoc.value;\n\n    _assert.default.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n\n    lastLocValue = thisLocValue;\n    var ce = tryEntry.catchEntry;\n    var fe = tryEntry.finallyEntry;\n    var locs = [tryEntry.firstLoc, // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n\n    return t.arrayExpression(locs.map(function (loc) {\n      return loc && t.clone(loc);\n    }));\n  }));\n}; // All side effects must be realized in order.\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n// No destructive modification of AST nodes.\n\n\nEp.explode = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var node = path.node;\n  var self = this;\n  t.assertNode(node);\n  if (t.isDeclaration(node)) throw getDeclError(node);\n  if (t.isStatement(node)) return self.explodeStatement(path);\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n\n    default:\n      throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\n\nEp.explodeStatement = function (path, labelId) {\n  var t = util.getTypes();\n  var stmt = path.node;\n  var self = this;\n  var before, after, head;\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  } // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n\n\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n\n    case \"LabeledStatement\":\n      after = this.loc(); // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n      self.mark(after);\n      break;\n\n    case \"WhileStatement\":\n      before = this.loc();\n      after = this.loc();\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n      break;\n\n    case \"DoWhileStatement\":\n      var first = this.loc();\n      var test = this.loc();\n      after = this.loc();\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n      break;\n\n    case \"ForStatement\":\n      head = this.loc();\n      var update = this.loc();\n      after = this.loc();\n\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n\n      self.mark(head);\n\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {// No test means continue unconditionally.\n      }\n\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.mark(update);\n\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n\n    case \"ForInStatement\":\n      head = this.loc();\n      after = this.loc();\n      var keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n      self.mark(head);\n      var keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier(\"done\"), false), after);\n      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier(\"value\"), false));\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n      break;\n\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n      break;\n\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n      after = this.loc();\n      var defaultLoc = this.loc();\n      var condition = defaultLoc;\n      var caseLocs = []; // If there are no cases, .cases might be undefined.\n\n      var cases = stmt.cases || [];\n\n      for (var i = cases.length - 1; i >= 0; --i) {\n        var c = cases[i];\n        t.assertSwitchCase(c);\n\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n\n      var discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          var i = casePath.key;\n          self.mark(caseLocs[i]);\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n      self.mark(after);\n\n      if (defaultLoc.value === -1) {\n        self.mark(defaultLoc);\n\n        _assert.default.strictEqual(after.value, defaultLoc.value);\n      }\n\n      break;\n\n    case \"IfStatement\":\n      var elseLoc = stmt.alternate && this.loc();\n      after = this.loc();\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n      self.explodeStatement(path.get(\"consequent\"));\n\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n\n      self.mark(after);\n      break;\n\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n      break;\n\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n\n    case \"TryStatement\":\n      after = this.loc();\n      var handler = stmt.handler;\n      var catchLoc = handler && this.loc();\n      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n      var finallyLoc = stmt.finalizer && this.loc();\n      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n\n          self.updateContextPrevLoc(self.mark(catchLoc));\n          var bodyPath = path.get(\"handler.body\");\n          var safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n          bodyPath.traverse(catchParamVisitor, {\n            getSafeParam: function getSafeParam() {\n              return t.cloneDeep(safeParam);\n            },\n            catchParamName: handler.param.name\n          });\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n      self.mark(after);\n      break;\n\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n      break;\n\n    default:\n      throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n  }\n};\n\nvar catchParamVisitor = {\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    _assert.default.ok(false, \"invalid completion record: \" + JSON.stringify(record));\n  }\n\n  _assert.default.notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n\n  var t = util.getTypes();\n  var abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);\n    }\n  }\n\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\n\nfunction isValidCompletion(record) {\n  var type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && util.getTypes().isLiteral(record.target);\n  }\n\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n} // Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\n\n\nEp.getUnmarkedCurrentLoc = function () {\n  return util.getTypes().numericLiteral(this.listing.length);\n}; // The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\n\n\nEp.updateContextPrevLoc = function (loc) {\n  var t = util.getTypes();\n\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      _assert.default.strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  } // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n\n\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var expr = path.node;\n\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  var self = this;\n  var result; // Used optionally by several cases below.\n\n  var after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  } // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n\n\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  } // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n\n\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr); // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    _assert.default.ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n\n    var result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {// Side effects already emitted above.\n    } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(tempVar || self.makeTempVar(), result);\n    }\n\n    return result;\n  } // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? explodeViaTempVar(null, path.get(\"property\")) : expr.property, expr.computed));\n\n    case \"CallExpression\":\n      var calleePath = path.get(\"callee\");\n      var argsPath = path.get(\"arguments\");\n      var newCallee;\n      var newArgs = [];\n      var hasLeapingArgs = false;\n      argsPath.forEach(function (argPath) {\n        hasLeapingArgs = hasLeapingArgs || meta.containsLeap(argPath.node);\n      });\n\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n          var newObject = explodeViaTempVar( // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"));\n          var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get(\"property\")) : calleePath.node.property;\n          newArgs.unshift(newObject);\n          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = explodeViaTempVar(null, calleePath);\n\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);\n        }\n      }\n\n      argsPath.forEach(function (argPath) {\n        newArgs.push(explodeViaTempVar(null, argPath));\n      });\n      return finish(t.callExpression(newCallee, newArgs.map(function (arg) {\n        return t.cloneDeep(arg);\n      })));\n\n    case \"NewExpression\":\n      return finish(t.newExpression(explodeViaTempVar(null, path.get(\"callee\")), path.get(\"arguments\").map(function (argPath) {\n        return explodeViaTempVar(null, argPath);\n      })));\n\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get(\"value\")), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        return explodeViaTempVar(null, elemPath);\n      })));\n\n    case \"SequenceExpression\":\n      var lastIndex = expr.expressions.length - 1;\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n      return result;\n\n    case \"LogicalExpression\":\n      after = this.loc();\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      var left = explodeViaTempVar(result, path.get(\"left\"));\n\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        _assert.default.strictEqual(expr.operator, \"||\");\n\n        self.jumpIf(left, after);\n      }\n\n      explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"ConditionalExpression\":\n      var elseLoc = this.loc();\n      after = this.loc();\n      var test = self.explodeExpression(path.get(\"test\"));\n      self.jumpIfNot(test, elseLoc);\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n      self.jump(after);\n      self.mark(elseLoc);\n      explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator, // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get(\"left\")), explodeViaTempVar(null, path.get(\"right\"))));\n\n    case \"AssignmentExpression\":\n      if (expr.operator === \"=\") {\n        // If this is a simple assignment, the left hand side does not need\n        // to be read before the right hand side is evaluated, so we can\n        // avoid the more complicated logic below.\n        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n      }\n\n      var lhs = self.explodeExpression(path.get(\"left\"));\n      var temp = self.emitAssign(self.makeTempVar(), lhs); // For example,\n      //\n      //   x += yield y\n      //\n      // becomes\n      //\n      //   context.t0 = x\n      //   x = context.t0 += yield y\n      //\n      // so that the left-hand side expression is read before the yield.\n      // Fixes https://github.com/facebook/regenerator/issues/345.\n\n      return finish(t.assignmentExpression(\"=\", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get(\"right\")))));\n\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n\n    case \"YieldExpression\":\n      after = this.loc();\n      var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n      if (arg && expr.delegate) {\n        var _result = self.makeTempVar();\n\n        var _ret = t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(_result.property.name), after]));\n\n        _ret.loc = expr.loc;\n        self.emit(_ret);\n        self.mark(after);\n        return _result;\n      }\n\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      var ret = t.returnStatement(t.cloneDeep(arg) || null); // Preserve the `yield` location so that source mappings for the statements\n      // link back to the yield properly.\n\n      ret.loc = expr.loc;\n      self.emit(ret);\n      self.mark(after);\n      return self.contextProperty(\"sent\");\n\n    default:\n      throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n  }\n};","\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _emit = require(\"./emit\");\n\nvar _util = require(\"util\");\n\nvar _util2 = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction Entry() {\n  _assert.default.ok(this instanceof Entry);\n}\n\nfunction FunctionEntry(returnLoc) {\n  Entry.call(this);\n  (0, _util2.getTypes)().assertLiteral(returnLoc);\n  this.returnLoc = returnLoc;\n}\n\n(0, _util.inherits)(FunctionEntry, Entry);\nexports.FunctionEntry = FunctionEntry;\n\nfunction LoopEntry(breakLoc, continueLoc, label) {\n  Entry.call(this);\n  var t = (0, _util2.getTypes)();\n  t.assertLiteral(breakLoc);\n  t.assertLiteral(continueLoc);\n\n  if (label) {\n    t.assertIdentifier(label);\n  } else {\n    label = null;\n  }\n\n  this.breakLoc = breakLoc;\n  this.continueLoc = continueLoc;\n  this.label = label;\n}\n\n(0, _util.inherits)(LoopEntry, Entry);\nexports.LoopEntry = LoopEntry;\n\nfunction SwitchEntry(breakLoc) {\n  Entry.call(this);\n  (0, _util2.getTypes)().assertLiteral(breakLoc);\n  this.breakLoc = breakLoc;\n}\n\n(0, _util.inherits)(SwitchEntry, Entry);\nexports.SwitchEntry = SwitchEntry;\n\nfunction TryEntry(firstLoc, catchEntry, finallyEntry) {\n  Entry.call(this);\n  var t = (0, _util2.getTypes)();\n  t.assertLiteral(firstLoc);\n\n  if (catchEntry) {\n    _assert.default.ok(catchEntry instanceof CatchEntry);\n  } else {\n    catchEntry = null;\n  }\n\n  if (finallyEntry) {\n    _assert.default.ok(finallyEntry instanceof FinallyEntry);\n  } else {\n    finallyEntry = null;\n  } // Have to have one or the other (or both).\n\n\n  _assert.default.ok(catchEntry || finallyEntry);\n\n  this.firstLoc = firstLoc;\n  this.catchEntry = catchEntry;\n  this.finallyEntry = finallyEntry;\n}\n\n(0, _util.inherits)(TryEntry, Entry);\nexports.TryEntry = TryEntry;\n\nfunction CatchEntry(firstLoc, paramId) {\n  Entry.call(this);\n  var t = (0, _util2.getTypes)();\n  t.assertLiteral(firstLoc);\n  t.assertIdentifier(paramId);\n  this.firstLoc = firstLoc;\n  this.paramId = paramId;\n}\n\n(0, _util.inherits)(CatchEntry, Entry);\nexports.CatchEntry = CatchEntry;\n\nfunction FinallyEntry(firstLoc, afterLoc) {\n  Entry.call(this);\n  var t = (0, _util2.getTypes)();\n  t.assertLiteral(firstLoc);\n  t.assertLiteral(afterLoc);\n  this.firstLoc = firstLoc;\n  this.afterLoc = afterLoc;\n}\n\n(0, _util.inherits)(FinallyEntry, Entry);\nexports.FinallyEntry = FinallyEntry;\n\nfunction LabeledEntry(breakLoc, label) {\n  Entry.call(this);\n  var t = (0, _util2.getTypes)();\n  t.assertLiteral(breakLoc);\n  t.assertIdentifier(label);\n  this.breakLoc = breakLoc;\n  this.label = label;\n}\n\n(0, _util.inherits)(LabeledEntry, Entry);\nexports.LabeledEntry = LabeledEntry;\n\nfunction LeapManager(emitter) {\n  _assert.default.ok(this instanceof LeapManager);\n\n  _assert.default.ok(emitter instanceof _emit.Emitter);\n\n  this.emitter = emitter;\n  this.entryStack = [new FunctionEntry(emitter.finalLoc)];\n}\n\nvar LMp = LeapManager.prototype;\nexports.LeapManager = LeapManager;\n\nLMp.withEntry = function (entry, callback) {\n  _assert.default.ok(entry instanceof Entry);\n\n  this.entryStack.push(entry);\n\n  try {\n    callback.call(this.emitter);\n  } finally {\n    var popped = this.entryStack.pop();\n\n    _assert.default.strictEqual(popped, entry);\n  }\n};\n\nLMp._findLeapLocation = function (property, label) {\n  for (var i = this.entryStack.length - 1; i >= 0; --i) {\n    var entry = this.entryStack[i];\n    var loc = entry[property];\n\n    if (loc) {\n      if (label) {\n        if (entry.label && entry.label.name === label.name) {\n          return loc;\n        }\n      } else if (entry instanceof LabeledEntry) {// Ignore LabeledEntry entries unless we are actually breaking to\n        // a label.\n      } else {\n        return loc;\n      }\n    }\n  }\n\n  return null;\n};\n\nLMp.getBreakLoc = function (label) {\n  return this._findLeapLocation(\"breakLoc\", label);\n};\n\nLMp.getContinueLoc = function (label) {\n  return this._findLeapLocation(\"continueLoc\", label);\n};","\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _util = require(\"./util.js\");\n\nvar _private = require(\"private\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar m = (0, _private.makeAccessor)();\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    var t = (0, _util.getTypes)();\n    t.assertNode(node); // Assume no side effects until we find out otherwise.\n\n    var result = false;\n\n    function check(child) {\n      if (result) {// Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        _assert.default.strictEqual(result, false);\n\n        result = predicate(child);\n      }\n\n      return result;\n    }\n\n    var keys = t.VISITOR_KEYS[node.type];\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    (0, _util.getTypes)().assertNode(node);\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName]; // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\n\nvar opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n}; // These types potentially have side effects regardless of what side\n// effects their subexpressions have.\n\nvar sideEffectTypes = {\n  CallExpression: true,\n  // Anything could happen!\n  ForInStatement: true,\n  // Modifies the key variable.\n  UnaryExpression: true,\n  // Think delete.\n  BinaryExpression: true,\n  // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true,\n  // Side-effecting by definition.\n  UpdateExpression: true,\n  // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n\n}; // These types are the direct cause of all leaps in control flow.\n\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n}; // All leap types are also side effect types.\n\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);","\n\nexports.__esModule = true;\nexports.default = replaceShorthandObjectMethod;\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// this function converts a shorthand object generator method into a normal\n// (non-shorthand) object property which is a generator function expression. for\n// example, this:\n//\n//  var foo = {\n//    *bar(baz) { return 5; }\n//  }\n//\n// should be replaced with:\n//\n//  var foo = {\n//    bar: function*(baz) { return 5; }\n//  }\n//\n// to do this, it clones the parameter array and the body of the object generator\n// method into a new FunctionExpression.\n//\n// this method can be passed any Function AST node path, and it will return\n// either:\n//   a) the path that was passed in (iff the path did not need to be replaced) or\n//   b) the path of the new FunctionExpression that was created as a replacement\n//     (iff the path did need to be replaced)\n//\n// In either case, though, the caller can count on the fact that the return value\n// is a Function AST node path.\n//\n// If this function is called with an AST node path that is not a Function (or with an\n// argument that isn't an AST node path), it will throw an error.\nfunction replaceShorthandObjectMethod(path) {\n  var t = util.getTypes();\n\n  if (!path.node || !t.isFunction(path.node)) {\n    throw new Error(\"replaceShorthandObjectMethod can only be called on Function AST node paths.\");\n  } // this function only replaces shorthand object methods (called ObjectMethod\n  // in Babel-speak).\n\n\n  if (!t.isObjectMethod(path.node)) {\n    return path;\n  } // this function only replaces generators.\n\n\n  if (!path.node.generator) {\n    return path;\n  }\n\n  var parameters = path.node.params.map(function (param) {\n    return t.cloneDeep(param);\n  });\n  var functionExpression = t.functionExpression(null, // id\n  parameters, // params\n  t.cloneDeep(path.node.body), // body\n  path.node.generator, path.node.async);\n  util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), // key\n  functionExpression, //value\n  path.node.computed, // computed\n  false // shorthand\n  )); // path now refers to the ObjectProperty AST node path, but we want to return a\n  // Function AST node path for the function expression we created. we know that\n  // the FunctionExpression we just created is the value of the ObjectProperty,\n  // so return the \"value\" path off of this path.\n\n  return path.get(\"value\");\n}"]}