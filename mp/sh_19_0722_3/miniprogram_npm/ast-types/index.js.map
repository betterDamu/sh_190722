{"version":3,"sources":["main.js","fork.js","lib\\types.js","lib\\equiv.js","lib\\path.js","lib\\node-path.js","lib\\scope.js","lib\\path-visitor.js","def\\core.js","lib\\shared.js","def\\es6.js","def\\es7.js","def\\mozilla.js","def\\e4x.js","def\\jsx.js","def\\flow.js","def\\esprima.js","def\\babel.js","def\\babel6.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ACHA,AFMA,AFMA;ACFA,AENA,ACHA,AFMA,AFMA;ACFA,AENA,ACHA,AFMA,AFMA;ACFA,AENA,AENA,ADGA,AFMA,AFMA;ACFA,AENA,AENA,ADGA,AFMA,AFMA;ACFA,AENA,AENA,ADGA,AFMA,AFMA;ACFA,AENA,AENA,ADGA,AENA,AJYA;ADIA,AENA,AENA,ADGA,AENA,AJYA;ADIA,AENA,AENA,ADGA,AENA,AJYA;ADIA,AENA,AENA,AENA,AHSA,AENA,AJYA;ADIA,AENA,AENA,AENA,AHSA,AENA,AJYA;ADIA,AENA,AENA,AENA,AHSA,AENA,AJYA;AMjBA,APqBA,AENA,AENA,AENA,AHSA,AENA,AJYA;AMjBA,APqBA,AENA,AENA,AENA,AHSA,AENA,AJYA;AMjBA,APqBA,AENA,AENA,AENA,AHSA,AENA,AJYA;AMjBA,APqBA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,APqBA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,APqBA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,AT2BA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,AT2BA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,AT2BA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,ACHA,AV8BA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,ACHA,AV8BA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,ACHA,AV8BA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,ACHA,ACHA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,ACHA,ACHA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AENA,ACHA,ACHA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,ACHA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,ACHA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,ACHA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AGTA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AGTA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AGTA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AIZA,ADGA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AIZA,ADGA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AIZA,ADGA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AXiCA,AENA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;AMjBA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,AT2BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,AT2BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,AT2BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,ACHA,AKfA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AGTA,APqBA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AFMA,AT2BA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AKfA,AHSA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,ADGA,AXiCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AMlBA,ADGA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;Ae5CA,ACHA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AZoCA,AENA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AgB/CA,AV8BA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AENA,AKfA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AENA,AJYA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AFMA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AFMA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AFMA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AFMA;AMjBA,AOrBA,AV8BA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,AHSA,AFMA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AMjBA,AHSA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./fork')([\n    // This core module of AST types captures ES5 as it is parsed today by\n    // git://github.com/ariya/esprima.git#master.\n    require(\"./def/core\"),\n\n    // Feel free to add to or remove from this list of extension modules to\n    // configure the precise type hierarchy that you need.\n    require(\"./def/es6\"),\n    require(\"./def/es7\"),\n    require(\"./def/mozilla\"),\n    require(\"./def/e4x\"),\n    require(\"./def/jsx\"),\n    require(\"./def/flow\"),\n    require(\"./def/esprima\"),\n    require(\"./def/babel\"),\n    require(\"./def/babel6\")\n]);\n","module.exports = function (defs) {\n    var used = [];\n    var usedResult = [];\n    var fork = {};\n\n    function use(plugin) {\n        var idx = used.indexOf(plugin);\n        if (idx === -1) {\n            idx = used.length;\n            used.push(plugin);\n            usedResult[idx] = plugin(fork);\n        }\n        return usedResult[idx];\n    }\n\n    fork.use = use;\n\n    var types = use(require('./lib/types'));\n\n    defs.forEach(use);\n\n    types.finalize();\n\n    var exports = {\n        Type: types.Type,\n        builtInTypes: types.builtInTypes,\n        namedTypes: types.namedTypes,\n        builders: types.builders,\n        defineMethod: types.defineMethod,\n        getFieldNames: types.getFieldNames,\n        getFieldValue: types.getFieldValue,\n        eachField: types.eachField,\n        someField: types.someField,\n        getSupertypeNames: types.getSupertypeNames,\n        astNodesAreEquivalent: use(require(\"./lib/equiv\")),\n        finalize: types.finalize,\n        Path: use(require('./lib/path')),\n        NodePath: use(require(\"./lib/node-path\")),\n        PathVisitor: use(require(\"./lib/path-visitor\")),\n        use: use\n    };\n\n    exports.visit = exports.PathVisitor.visit;\n\n    return exports;\n};","var Ap = Array.prototype;\nvar slice = Ap.slice;\nvar map = Ap.map;\nvar each = Ap.forEach;\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar funObjStr = objToStr.call(function(){});\nvar strObjStr = objToStr.call(\"\");\nvar hasOwn = Op.hasOwnProperty;\n\nmodule.exports = function () {\n\n    var exports = {};\n\n    // A type is an object with a .check method that takes a value and returns\n    // true or false according to whether the value matches the type.\n\n    function Type(check, name) {\n        var self = this;\n        if (!(self instanceof Type)) {\n            throw new Error(\"Type constructor cannot be invoked without 'new'\");\n        }\n\n        // Unfortunately we can't elegantly reuse isFunction and isString,\n        // here, because this code is executed while defining those types.\n        if (objToStr.call(check) !== funObjStr) {\n            throw new Error(check + \" is not a function\");\n        }\n\n        // The `name` parameter can be either a function or a string.\n        var nameObjStr = objToStr.call(name);\n        if (!(nameObjStr === funObjStr ||\n          nameObjStr === strObjStr)) {\n            throw new Error(name + \" is neither a function nor a string\");\n        }\n\n        Object.defineProperties(self, {\n            name: {value: name},\n            check: {\n                value: function (value, deep) {\n                    var result = check.call(self, value, deep);\n                    if (!result && deep && objToStr.call(deep) === funObjStr)\n                        deep(self, value);\n                    return result;\n                }\n            }\n        });\n    }\n\n    var Tp = Type.prototype;\n\n    // Throughout this file we use Object.defineProperty to prevent\n    // redefinition of exported properties.\n    exports.Type = Type;\n\n    // Like .check, except that failure triggers an AssertionError.\n    Tp.assert = function (value, deep) {\n        if (!this.check(value, deep)) {\n            var str = shallowStringify(value);\n            throw new Error(str + \" does not match type \" + this);\n        }\n        return true;\n    };\n\n    function shallowStringify(value) {\n        if (isObject.check(value))\n            return \"{\" + Object.keys(value).map(function (key) {\n                  return key + \": \" + value[key];\n              }).join(\", \") + \"}\";\n\n        if (isArray.check(value))\n            return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n\n        return JSON.stringify(value);\n    }\n\n    Tp.toString = function () {\n        var name = this.name;\n\n        if (isString.check(name))\n            return name;\n\n        if (isFunction.check(name))\n            return name.call(this) + \"\";\n\n        return name + \" type\";\n    };\n\n    var builtInCtorFns = [];\n    var builtInCtorTypes = [];\n    var builtInTypes = {};\n    exports.builtInTypes = builtInTypes;\n\n    function defBuiltInType(example, name) {\n        var objStr = objToStr.call(example);\n\n        var type = new Type(function (value) {\n            return objToStr.call(value) === objStr;\n        }, name);\n\n        builtInTypes[name] = type;\n\n        if (example && typeof example.constructor === \"function\") {\n            builtInCtorFns.push(example.constructor);\n            builtInCtorTypes.push(type);\n        }\n\n        return type;\n    }\n\n    // These types check the underlying [[Class]] attribute of the given\n    // value, rather than using the problematic typeof operator. Note however\n    // that no subtyping is considered; so, for instance, isObject.check\n    // returns false for [], /./, new Date, and null.\n    var isString = defBuiltInType(\"truthy\", \"string\");\n    var isFunction = defBuiltInType(function () {}, \"function\");\n    var isArray = defBuiltInType([], \"array\");\n    var isObject = defBuiltInType({}, \"object\");\n    var isRegExp = defBuiltInType(/./, \"RegExp\");\n    var isDate = defBuiltInType(new Date, \"Date\");\n    var isNumber = defBuiltInType(3, \"number\");\n    var isBoolean = defBuiltInType(true, \"boolean\");\n    var isNull = defBuiltInType(null, \"null\");\n    var isUndefined = defBuiltInType(void 0, \"undefined\");\n\n    // There are a number of idiomatic ways of expressing types, so this\n    // function serves to coerce them all to actual Type objects. Note that\n    // providing the name argument is not necessary in most cases.\n    function toType(from, name) {\n        // The toType function should of course be idempotent.\n        if (from instanceof Type)\n            return from;\n\n        // The Def type is used as a helper for constructing compound\n        // interface types for AST nodes.\n        if (from instanceof Def)\n            return from.type;\n\n        // Support [ElemType] syntax.\n        if (isArray.check(from))\n            return Type.fromArray(from);\n\n        // Support { someField: FieldType, ... } syntax.\n        if (isObject.check(from))\n            return Type.fromObject(from);\n\n        if (isFunction.check(from)) {\n            var bicfIndex = builtInCtorFns.indexOf(from);\n            if (bicfIndex >= 0) {\n                return builtInCtorTypes[bicfIndex];\n            }\n\n            // If isFunction.check(from), and from is not a built-in\n            // constructor, assume from is a binary predicate function we can\n            // use to define the type.\n            return new Type(from, name);\n        }\n\n        // As a last resort, toType returns a type that matches any value that\n        // is === from. This is primarily useful for literal values like\n        // toType(null), but it has the additional advantage of allowing\n        // toType to be a total function.\n        return new Type(function (value) {\n            return value === from;\n        }, isUndefined.check(name) ? function () {\n            return from + \"\";\n        } : name);\n    }\n\n    // Returns a type that matches the given value iff any of type1, type2,\n    // etc. match the value.\n    Type.or = function (/* type1, type2, ... */) {\n        var types = [];\n        var len = arguments.length;\n        for (var i = 0; i < len; ++i)\n            types.push(toType(arguments[i]));\n\n        return new Type(function (value, deep) {\n            for (var i = 0; i < len; ++i)\n                if (types[i].check(value, deep))\n                    return true;\n            return false;\n        }, function () {\n            return types.join(\" | \");\n        });\n    };\n\n    Type.fromArray = function (arr) {\n        if (!isArray.check(arr)) {\n            throw new Error(\"\");\n        }\n        if (arr.length !== 1) {\n            throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n        return toType(arr[0]).arrayOf();\n    };\n\n    Tp.arrayOf = function () {\n        var elemType = this;\n        return new Type(function (value, deep) {\n            return isArray.check(value) && value.every(function (elem) {\n                  return elemType.check(elem, deep);\n              });\n        }, function () {\n            return \"[\" + elemType + \"]\";\n        });\n    };\n\n    Type.fromObject = function (obj) {\n        var fields = Object.keys(obj).map(function (name) {\n            return new Field(name, obj[name]);\n        });\n\n        return new Type(function (value, deep) {\n            return isObject.check(value) && fields.every(function (field) {\n                  return field.type.check(value[field.name], deep);\n              });\n        }, function () {\n            return \"{ \" + fields.join(\", \") + \" }\";\n        });\n    };\n\n    function Field(name, type, defaultFn, hidden) {\n        var self = this;\n\n        if (!(self instanceof Field)) {\n            throw new Error(\"Field constructor cannot be invoked without 'new'\");\n        }\n        isString.assert(name);\n\n        type = toType(type);\n\n        var properties = {\n            name: {value: name},\n            type: {value: type},\n            hidden: {value: !!hidden}\n        };\n\n        if (isFunction.check(defaultFn)) {\n            properties.defaultFn = {value: defaultFn};\n        }\n\n        Object.defineProperties(self, properties);\n    }\n\n    var Fp = Field.prototype;\n\n    Fp.toString = function () {\n        return JSON.stringify(this.name) + \": \" + this.type;\n    };\n\n    Fp.getValue = function (obj) {\n        var value = obj[this.name];\n\n        if (!isUndefined.check(value))\n            return value;\n\n        if (this.defaultFn)\n            value = this.defaultFn.call(obj);\n\n        return value;\n    };\n\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    Type.def = function (typeName) {\n        isString.assert(typeName);\n        return hasOwn.call(defCache, typeName)\n          ? defCache[typeName]\n          : defCache[typeName] = new Def(typeName);\n    };\n\n    // In order to return the same Def instance every time Type.def is called\n    // with a particular name, those instances need to be stored in a cache.\n    var defCache = Object.create(null);\n\n    function Def(typeName) {\n        var self = this;\n        if (!(self instanceof Def)) {\n            throw new Error(\"Def constructor cannot be invoked without 'new'\");\n        }\n\n        Object.defineProperties(self, {\n            typeName: {value: typeName},\n            baseNames: {value: []},\n            ownFields: {value: Object.create(null)},\n\n            // These two are populated during finalization.\n            allSupertypes: {value: Object.create(null)}, // Includes own typeName.\n            supertypeList: {value: []}, // Linear inheritance hierarchy.\n            allFields: {value: Object.create(null)}, // Includes inherited fields.\n            fieldNames: {value: []}, // Non-hidden keys of allFields.\n\n            type: {\n                value: new Type(function (value, deep) {\n                    return self.check(value, deep);\n                }, typeName)\n            }\n        });\n    }\n\n    Def.fromValue = function (value) {\n        if (value && typeof value === \"object\") {\n            var type = value.type;\n            if (typeof type === \"string\" &&\n              hasOwn.call(defCache, type)) {\n                var d = defCache[type];\n                if (d.finalized) {\n                    return d;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    var Dp = Def.prototype;\n\n    Dp.isSupertypeOf = function (that) {\n        if (that instanceof Def) {\n            if (this.finalized !== true ||\n              that.finalized !== true) {\n                throw new Error(\"\");\n            }\n            return hasOwn.call(that.allSupertypes, this.typeName);\n        } else {\n            throw new Error(that + \" is not a Def\");\n        }\n    };\n\n    // Note that the list returned by this function is a copy of the internal\n    // supertypeList, *without* the typeName itself as the first element.\n    exports.getSupertypeNames = function (typeName) {\n        if (!hasOwn.call(defCache, typeName)) {\n            throw new Error(\"\");\n        }\n        var d = defCache[typeName];\n        if (d.finalized !== true) {\n            throw new Error(\"\");\n        }\n        return d.supertypeList.slice(1);\n    };\n\n    // Returns an object mapping from every known type in the defCache to the\n    // most specific supertype whose name is an own property of the candidates\n    // object.\n    exports.computeSupertypeLookupTable = function (candidates) {\n        var table = {};\n        var typeNames = Object.keys(defCache);\n        var typeNameCount = typeNames.length;\n\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNames[i];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\" + typeName);\n            }\n            for (var j = 0; j < d.supertypeList.length; ++j) {\n                var superTypeName = d.supertypeList[j];\n                if (hasOwn.call(candidates, superTypeName)) {\n                    table[typeName] = superTypeName;\n                    break;\n                }\n            }\n        }\n\n        return table;\n    };\n\n    Dp.checkAllFields = function (value, deep) {\n        var allFields = this.allFields;\n        if (this.finalized !== true) {\n            throw new Error(\"\" + this.typeName);\n        }\n\n        function checkFieldByName(name) {\n            var field = allFields[name];\n            var type = field.type;\n            var child = field.getValue(value);\n            return type.check(child, deep);\n        }\n\n        return isObject.check(value)\n          && Object.keys(allFields).every(checkFieldByName);\n    };\n\n    Dp.check = function (value, deep) {\n        if (this.finalized !== true) {\n            throw new Error(\n              \"prematurely checking unfinalized type \" + this.typeName\n            );\n        }\n\n        // A Def type can only match an object value.\n        if (!isObject.check(value))\n            return false;\n\n        var vDef = Def.fromValue(value);\n        if (!vDef) {\n            // If we couldn't infer the Def associated with the given value,\n            // and we expected it to be a SourceLocation or a Position, it was\n            // probably just missing a \"type\" field (because Esprima does not\n            // assign a type property to such nodes). Be optimistic and let\n            // this.checkAllFields make the final decision.\n            if (this.typeName === \"SourceLocation\" ||\n              this.typeName === \"Position\") {\n                return this.checkAllFields(value, deep);\n            }\n\n            // Calling this.checkAllFields for any other type of node is both\n            // bad for performance and way too forgiving.\n            return false;\n        }\n\n        // If checking deeply and vDef === this, then we only need to call\n        // checkAllFields once. Calling checkAllFields is too strict when deep\n        // is false, because then we only care about this.isSupertypeOf(vDef).\n        if (deep && vDef === this)\n            return this.checkAllFields(value, deep);\n\n        // In most cases we rely exclusively on isSupertypeOf to make O(1)\n        // subtyping determinations. This suffices in most situations outside\n        // of unit tests, since interface conformance is checked whenever new\n        // instances are created using builder functions.\n        if (!this.isSupertypeOf(vDef))\n            return false;\n\n        // The exception is when deep is true; then, we recursively check all\n        // fields.\n        if (!deep)\n            return true;\n\n        // Use the more specific Def (vDef) to perform the deep check, but\n        // shallow-check fields defined by the less specific Def (this).\n        return vDef.checkAllFields(value, deep)\n          && this.checkAllFields(value, false);\n    };\n\n    Dp.bases = function () {\n        var args = slice.call(arguments);\n        var bases = this.baseNames;\n\n        if (this.finalized) {\n            if (args.length !== bases.length) {\n                throw new Error(\"\");\n            }\n            for (var i = 0; i < args.length; i++) {\n                if (args[i] !== bases[i]) {\n                    throw new Error(\"\");\n                }\n            }\n            return this;\n        }\n\n        args.forEach(function (baseName) {\n            isString.assert(baseName);\n\n            // This indexOf lookup may be O(n), but the typical number of base\n            // names is very small, and indexOf is a native Array method.\n            if (bases.indexOf(baseName) < 0)\n                bases.push(baseName);\n        });\n\n        return this; // For chaining.\n    };\n\n    // False by default until .build(...) is called on an instance.\n    Object.defineProperty(Dp, \"buildable\", {value: false});\n\n    var builders = {};\n    exports.builders = builders;\n\n    // This object is used as prototype for any node created by a builder.\n    var nodePrototype = {};\n\n    // Call this function to define a new method to be shared by all AST\n     // nodes. The replaced method (if any) is returned for easy wrapping.\n    exports.defineMethod = function (name, func) {\n        var old = nodePrototype[name];\n\n        // Pass undefined as func to delete nodePrototype[name].\n        if (isUndefined.check(func)) {\n            delete nodePrototype[name];\n\n        } else {\n            isFunction.assert(func);\n\n            Object.defineProperty(nodePrototype, name, {\n                enumerable: true, // For discoverability.\n                configurable: true, // For delete proto[name].\n                value: func\n            });\n        }\n\n        return old;\n    };\n\n    var isArrayOfString = isString.arrayOf();\n\n    // Calling the .build method of a Def simultaneously marks the type as\n    // buildable (by defining builders[getBuilderName(typeName)]) and\n    // specifies the order of arguments that should be passed to the builder\n    // function to create an instance of the type.\n    Dp.build = function (/* param1, param2, ... */) {\n        var self = this;\n\n        var newBuildParams = slice.call(arguments);\n        isArrayOfString.assert(newBuildParams);\n\n        // Calling Def.prototype.build multiple times has the effect of merely\n        // redefining this property.\n        Object.defineProperty(self, \"buildParams\", {\n            value: newBuildParams,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n\n        if (self.buildable) {\n            // If this Def is already buildable, update self.buildParams and\n            // continue using the old builder function.\n            return self;\n        }\n\n        // Every buildable type will have its \"type\" field filled in\n        // automatically. This includes types that are not subtypes of Node,\n        // like SourceLocation, but that seems harmless (TODO?).\n        self.field(\"type\", String, function () { return self.typeName });\n\n        // Override Dp.buildable for this Def instance.\n        Object.defineProperty(self, \"buildable\", {value: true});\n\n        Object.defineProperty(builders, getBuilderName(self.typeName), {\n            enumerable: true,\n\n            value: function () {\n                var args = arguments;\n                var argc = args.length;\n                var built = Object.create(nodePrototype);\n\n                if (!self.finalized) {\n                    throw new Error(\n                      \"attempting to instantiate unfinalized type \" +\n                      self.typeName\n                    );\n                }\n\n                function add(param, i) {\n                    if (hasOwn.call(built, param))\n                        return;\n\n                    var all = self.allFields;\n                    if (!hasOwn.call(all, param)) {\n                        throw new Error(\"\" + param);\n                    }\n\n                    var field = all[param];\n                    var type = field.type;\n                    var value;\n\n                    if (isNumber.check(i) && i < argc) {\n                        value = args[i];\n                    } else if (field.defaultFn) {\n                        // Expose the partially-built object to the default\n                        // function as its `this` object.\n                        value = field.defaultFn.call(built);\n                    } else {\n                        var message = \"no value or default function given for field \" +\n                          JSON.stringify(param) + \" of \" + self.typeName + \"(\" +\n                          self.buildParams.map(function (name) {\n                              return all[name];\n                          }).join(\", \") + \")\";\n                        throw new Error(message);\n                    }\n\n                    if (!type.check(value)) {\n                        throw new Error(\n                          shallowStringify(value) +\n                          \" does not match field \" + field +\n                          \" of type \" + self.typeName\n                        );\n                    }\n\n                    // TODO Could attach getters and setters here to enforce\n                    // dynamic type safety.\n                    built[param] = value;\n                }\n\n                self.buildParams.forEach(function (param, i) {\n                    add(param, i);\n                });\n\n                Object.keys(self.allFields).forEach(function (param) {\n                    add(param); // Use the default value.\n                });\n\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== self.typeName) {\n                    throw new Error(\"\");\n                }\n\n                return built;\n            }\n        });\n\n        return self; // For chaining.\n    };\n\n    function getBuilderName(typeName) {\n        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n            var len = upperCasePrefix.length;\n            switch (len) {\n                case 0: return \"\";\n                // If there's only one initial capital letter, just lower-case it.\n                case 1: return upperCasePrefix.toLowerCase();\n                default:\n                    // If there's more than one initial capital letter, lower-case\n                    // all but the last one, so that XMLDefaultDeclaration (for\n                    // example) becomes xmlDefaultDeclaration.\n                    return upperCasePrefix.slice(\n                        0, len - 1).toLowerCase() +\n                      upperCasePrefix.charAt(len - 1);\n            }\n        });\n    }\n    exports.getBuilderName = getBuilderName;\n\n    function getStatementBuilderName(typeName) {\n        typeName = getBuilderName(typeName);\n        return typeName.replace(/(Expression)?$/, \"Statement\");\n    }\n    exports.getStatementBuilderName = getStatementBuilderName;\n\n    // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n    Dp.field = function (name, type, defaultFn, hidden) {\n        if (this.finalized) {\n            console.error(\"Ignoring attempt to redefine field \" +\n              JSON.stringify(name) + \" of finalized type \" +\n              JSON.stringify(this.typeName));\n            return this;\n        }\n        this.ownFields[name] = new Field(name, type, defaultFn, hidden);\n        return this; // For chaining.\n    };\n\n    var namedTypes = {};\n    exports.namedTypes = namedTypes;\n\n    // Like Object.keys, but aware of what fields each AST type should have.\n    function getFieldNames(object) {\n        var d = Def.fromValue(object);\n        if (d) {\n            return d.fieldNames.slice(0);\n        }\n\n        if (\"type\" in object) {\n            throw new Error(\n              \"did not recognize object of type \" +\n              JSON.stringify(object.type)\n            );\n        }\n\n        return Object.keys(object);\n    }\n    exports.getFieldNames = getFieldNames;\n\n    // Get the value of an object property, taking object.type and default\n    // functions into account.\n    function getFieldValue(object, fieldName) {\n        var d = Def.fromValue(object);\n        if (d) {\n            var field = d.allFields[fieldName];\n            if (field) {\n                return field.getValue(object);\n            }\n        }\n\n        return object && object[fieldName];\n    }\n    exports.getFieldValue = getFieldValue;\n\n    // Iterate over all defined fields of an object, including those missing\n    // or undefined, passing each field name and effective value (as returned\n    // by getFieldValue) to the callback. If the object has no corresponding\n    // Def, the callback will never be called.\n    exports.eachField = function (object, callback, context) {\n        getFieldNames(object).forEach(function (name) {\n            callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    };\n\n    // Similar to eachField, except that iteration stops as soon as the\n    // callback returns a truthy value. Like Array.prototype.some, the final\n    // result is either true or false to indicates whether the callback\n    // returned true for any element or not.\n    exports.someField = function (object, callback, context) {\n        return getFieldNames(object).some(function (name) {\n            return callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    };\n\n    // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n    Object.defineProperty(Dp, \"finalized\", {value: false});\n\n    Dp.finalize = function () {\n        var self = this;\n\n        // It's not an error to finalize a type more than once, but only the\n        // first call to .finalize does anything.\n        if (!self.finalized) {\n            var allFields = self.allFields;\n            var allSupertypes = self.allSupertypes;\n\n            self.baseNames.forEach(function (name) {\n                var def = defCache[name];\n                if (def instanceof Def) {\n                    def.finalize();\n                    extend(allFields, def.allFields);\n                    extend(allSupertypes, def.allSupertypes);\n                } else {\n                    var message = \"unknown supertype name \" +\n                      JSON.stringify(name) +\n                      \" for subtype \" +\n                      JSON.stringify(self.typeName);\n                    throw new Error(message);\n                }\n            });\n\n            // TODO Warn if fields are overridden with incompatible types.\n            extend(allFields, self.ownFields);\n            allSupertypes[self.typeName] = self;\n\n            self.fieldNames.length = 0;\n            for (var fieldName in allFields) {\n                if (hasOwn.call(allFields, fieldName) &&\n                    !allFields[fieldName].hidden) {\n                        self.fieldNames.push(fieldName);\n                }\n            }\n\n            // Types are exported only once they have been finalized.\n            Object.defineProperty(namedTypes, self.typeName, {\n                enumerable: true,\n                value: self.type\n            });\n\n            Object.defineProperty(self, \"finalized\", {value: true});\n\n            // A linearization of the inheritance hierarchy.\n            populateSupertypeList(self.typeName, self.supertypeList);\n\n            if (self.buildable && self.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n                wrapExpressionBuilderWithStatement(self.typeName);\n            }\n        }\n    };\n\n    // Adds an additional builder for Expression subtypes\n    // that wraps the built Expression in an ExpressionStatements.\n    function wrapExpressionBuilderWithStatement(typeName) {\n        var wrapperName = getStatementBuilderName(typeName);\n\n        // skip if the builder already exists\n        if (builders[wrapperName]) return;\n\n        // the builder function to wrap with builders.ExpressionStatement\n        var wrapped = builders[getBuilderName(typeName)];\n\n        // skip if there is nothing to wrap\n        if (!wrapped) return;\n\n        builders[wrapperName] = function () {\n            return builders.expressionStatement(wrapped.apply(builders, arguments));\n        };\n    }\n\n    function populateSupertypeList(typeName, list) {\n        list.length = 0;\n        list.push(typeName);\n\n        var lastSeen = Object.create(null);\n\n        for (var pos = 0; pos < list.length; ++pos) {\n            typeName = list[pos];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\");\n            }\n\n            // If we saw typeName earlier in the breadth-first traversal,\n            // delete the last-seen occurrence.\n            if (hasOwn.call(lastSeen, typeName)) {\n                delete list[lastSeen[typeName]];\n            }\n\n            // Record the new index of the last-seen occurrence of typeName.\n            lastSeen[typeName] = pos;\n\n            // Enqueue the base names of this type.\n            list.push.apply(list, d.baseNames);\n        }\n\n        // Compaction loop to remove array holes.\n        for (var to = 0, from = to, len = list.length; from < len; ++from) {\n            if (hasOwn.call(list, from)) {\n                list[to++] = list[from];\n            }\n        }\n\n        list.length = to;\n    }\n\n    function extend(into, from) {\n        Object.keys(from).forEach(function (name) {\n            into[name] = from[name];\n        });\n\n        return into;\n    };\n\n    exports.finalize = function () {\n        Object.keys(defCache).forEach(function (name) {\n            defCache[name].finalize();\n        });\n    };\n\n    return exports;\n};\n","module.exports = function (fork) {\n    var types = fork.use(require('../lib/types'));\n    var getFieldNames = types.getFieldNames;\n    var getFieldValue = types.getFieldValue;\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isDate = types.builtInTypes.Date;\n    var isRegExp = types.builtInTypes.RegExp;\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    function astNodesAreEquivalent(a, b, problemPath) {\n        if (isArray.check(problemPath)) {\n            problemPath.length = 0;\n        } else {\n            problemPath = null;\n        }\n\n        return areEquivalent(a, b, problemPath);\n    }\n\n    astNodesAreEquivalent.assert = function (a, b) {\n        var problemPath = [];\n        if (!astNodesAreEquivalent(a, b, problemPath)) {\n            if (problemPath.length === 0) {\n                if (a !== b) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n            } else {\n                throw new Error(\n                  \"Nodes differ in the following path: \" +\n                  problemPath.map(subscriptForProperty).join(\"\")\n                );\n            }\n        }\n    };\n\n    function subscriptForProperty(property) {\n        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n            return \".\" + property;\n        }\n        return \"[\" + JSON.stringify(property) + \"]\";\n    }\n\n    function areEquivalent(a, b, problemPath) {\n        if (a === b) {\n            return true;\n        }\n\n        if (isArray.check(a)) {\n            return arraysAreEquivalent(a, b, problemPath);\n        }\n\n        if (isObject.check(a)) {\n            return objectsAreEquivalent(a, b, problemPath);\n        }\n\n        if (isDate.check(a)) {\n            return isDate.check(b) && (+a === +b);\n        }\n\n        if (isRegExp.check(a)) {\n            return isRegExp.check(b) && (\n                a.source === b.source &&\n                a.global === b.global &&\n                a.multiline === b.multiline &&\n                a.ignoreCase === b.ignoreCase\n              );\n        }\n\n        return a == b;\n    }\n\n    function arraysAreEquivalent(a, b, problemPath) {\n        isArray.assert(a);\n        var aLength = a.length;\n\n        if (!isArray.check(b) || b.length !== aLength) {\n            if (problemPath) {\n                problemPath.push(\"length\");\n            }\n            return false;\n        }\n\n        for (var i = 0; i < aLength; ++i) {\n            if (problemPath) {\n                problemPath.push(i);\n            }\n\n            if (i in a !== i in b) {\n                return false;\n            }\n\n            if (!areEquivalent(a[i], b[i], problemPath)) {\n                return false;\n            }\n\n            if (problemPath) {\n                var problemPathTail = problemPath.pop();\n                if (problemPathTail !== i) {\n                    throw new Error(\"\" + problemPathTail);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function objectsAreEquivalent(a, b, problemPath) {\n        isObject.assert(a);\n        if (!isObject.check(b)) {\n            return false;\n        }\n\n        // Fast path for a common property of AST nodes.\n        if (a.type !== b.type) {\n            if (problemPath) {\n                problemPath.push(\"type\");\n            }\n            return false;\n        }\n\n        var aNames = getFieldNames(a);\n        var aNameCount = aNames.length;\n\n        var bNames = getFieldNames(b);\n        var bNameCount = bNames.length;\n\n        if (aNameCount === bNameCount) {\n            for (var i = 0; i < aNameCount; ++i) {\n                var name = aNames[i];\n                var aChild = getFieldValue(a, name);\n                var bChild = getFieldValue(b, name);\n\n                if (problemPath) {\n                    problemPath.push(name);\n                }\n\n                if (!areEquivalent(aChild, bChild, problemPath)) {\n                    return false;\n                }\n\n                if (problemPath) {\n                    var problemPathTail = problemPath.pop();\n                    if (problemPathTail !== name) {\n                        throw new Error(\"\" + problemPathTail);\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        if (!problemPath) {\n            return false;\n        }\n\n        // Since aNameCount !== bNameCount, we need to find some name that's\n        // missing in aNames but present in bNames, or vice-versa.\n\n        var seenNames = Object.create(null);\n\n        for (i = 0; i < aNameCount; ++i) {\n            seenNames[aNames[i]] = true;\n        }\n\n        for (i = 0; i < bNameCount; ++i) {\n            name = bNames[i];\n\n            if (!hasOwn.call(seenNames, name)) {\n                problemPath.push(name);\n                return false;\n            }\n\n            delete seenNames[name];\n        }\n\n        for (name in seenNames) {\n            problemPath.push(name);\n            break;\n        }\n\n        return false;\n    }\n    \n    return astNodesAreEquivalent;\n};\n","var Ap = Array.prototype;\nvar slice = Ap.slice;\nvar map = Ap.map;\nvar Op = Object.prototype;\nvar hasOwn = Op.hasOwnProperty;\n\nmodule.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var isArray = types.builtInTypes.array;\n    var isNumber = types.builtInTypes.number;\n\n    function Path(value, parentPath, name) {\n        if (!(this instanceof Path)) {\n            throw new Error(\"Path constructor cannot be invoked without 'new'\");\n        }\n\n        if (parentPath) {\n            if (!(parentPath instanceof Path)) {\n                throw new Error(\"\");\n            }\n        } else {\n            parentPath = null;\n            name = null;\n        }\n\n        // The value encapsulated by this Path, generally equal to\n        // parentPath.value[name] if we have a parentPath.\n        this.value = value;\n\n        // The immediate parent Path of this Path.\n        this.parentPath = parentPath;\n\n        // The name of the property of parentPath.value through which this\n        // Path's value was reached.\n        this.name = name;\n\n        // Calling path.get(\"child\") multiple times always returns the same\n        // child Path object, for both performance and consistency reasons.\n        this.__childCache = null;\n    }\n\n    var Pp = Path.prototype;\n\n    function getChildCache(path) {\n        // Lazily create the child cache. This also cheapens cache\n        // invalidation, since you can just reset path.__childCache to null.\n        return path.__childCache || (path.__childCache = Object.create(null));\n    }\n\n    function getChildPath(path, name) {\n        var cache = getChildCache(path);\n        var actualChildValue = path.getValueProperty(name);\n        var childPath = cache[name];\n        if (!hasOwn.call(cache, name) ||\n          // Ensure consistency between cache and reality.\n          childPath.value !== actualChildValue) {\n            childPath = cache[name] = new path.constructor(\n              actualChildValue, path, name\n            );\n        }\n        return childPath;\n    }\n\n// This method is designed to be overridden by subclasses that need to\n// handle missing properties, etc.\n    Pp.getValueProperty = function getValueProperty(name) {\n        return this.value[name];\n    };\n\n    Pp.get = function get(name) {\n        var path = this;\n        var names = arguments;\n        var count = names.length;\n\n        for (var i = 0; i < count; ++i) {\n            path = getChildPath(path, names[i]);\n        }\n\n        return path;\n    };\n\n    Pp.each = function each(callback, context) {\n        var childPaths = [];\n        var len = this.value.length;\n        var i = 0;\n\n        // Collect all the original child paths before invoking the callback.\n        for (var i = 0; i < len; ++i) {\n            if (hasOwn.call(this.value, i)) {\n                childPaths[i] = this.get(i);\n            }\n        }\n\n        // Invoke the callback on just the original child paths, regardless of\n        // any modifications made to the array by the callback. I chose these\n        // semantics over cleverly invoking the callback on new elements because\n        // this way is much easier to reason about.\n        context = context || this;\n        for (i = 0; i < len; ++i) {\n            if (hasOwn.call(childPaths, i)) {\n                callback.call(context, childPaths[i]);\n            }\n        }\n    };\n\n    Pp.map = function map(callback, context) {\n        var result = [];\n\n        this.each(function (childPath) {\n            result.push(callback.call(this, childPath));\n        }, context);\n\n        return result;\n    };\n\n    Pp.filter = function filter(callback, context) {\n        var result = [];\n\n        this.each(function (childPath) {\n            if (callback.call(this, childPath)) {\n                result.push(childPath);\n            }\n        }, context);\n\n        return result;\n    };\n\n    function emptyMoves() {}\n    function getMoves(path, offset, start, end) {\n        isArray.assert(path.value);\n\n        if (offset === 0) {\n            return emptyMoves;\n        }\n\n        var length = path.value.length;\n        if (length < 1) {\n            return emptyMoves;\n        }\n\n        var argc = arguments.length;\n        if (argc === 2) {\n            start = 0;\n            end = length;\n        } else if (argc === 3) {\n            start = Math.max(start, 0);\n            end = length;\n        } else {\n            start = Math.max(start, 0);\n            end = Math.min(end, length);\n        }\n\n        isNumber.assert(start);\n        isNumber.assert(end);\n\n        var moves = Object.create(null);\n        var cache = getChildCache(path);\n\n        for (var i = start; i < end; ++i) {\n            if (hasOwn.call(path.value, i)) {\n                var childPath = path.get(i);\n                if (childPath.name !== i) {\n                    throw new Error(\"\");\n                }\n                var newIndex = i + offset;\n                childPath.name = newIndex;\n                moves[newIndex] = childPath;\n                delete cache[i];\n            }\n        }\n\n        delete cache.length;\n\n        return function () {\n            for (var newIndex in moves) {\n                var childPath = moves[newIndex];\n                if (childPath.name !== +newIndex) {\n                    throw new Error(\"\");\n                }\n                cache[newIndex] = childPath;\n                path.value[newIndex] = childPath.value;\n            }\n        };\n    }\n\n    Pp.shift = function shift() {\n        var move = getMoves(this, -1);\n        var result = this.value.shift();\n        move();\n        return result;\n    };\n\n    Pp.unshift = function unshift(node) {\n        var move = getMoves(this, arguments.length);\n        var result = this.value.unshift.apply(this.value, arguments);\n        move();\n        return result;\n    };\n\n    Pp.push = function push(node) {\n        isArray.assert(this.value);\n        delete getChildCache(this).length\n        return this.value.push.apply(this.value, arguments);\n    };\n\n    Pp.pop = function pop() {\n        isArray.assert(this.value);\n        var cache = getChildCache(this);\n        delete cache[this.value.length - 1];\n        delete cache.length;\n        return this.value.pop();\n    };\n\n    Pp.insertAt = function insertAt(index, node) {\n        var argc = arguments.length;\n        var move = getMoves(this, argc - 1, index);\n        if (move === emptyMoves) {\n            return this;\n        }\n\n        index = Math.max(index, 0);\n\n        for (var i = 1; i < argc; ++i) {\n            this.value[index + i - 1] = arguments[i];\n        }\n\n        move();\n\n        return this;\n    };\n\n    Pp.insertBefore = function insertBefore(node) {\n        var pp = this.parentPath;\n        var argc = arguments.length;\n        var insertAtArgs = [this.name];\n        for (var i = 0; i < argc; ++i) {\n            insertAtArgs.push(arguments[i]);\n        }\n        return pp.insertAt.apply(pp, insertAtArgs);\n    };\n\n    Pp.insertAfter = function insertAfter(node) {\n        var pp = this.parentPath;\n        var argc = arguments.length;\n        var insertAtArgs = [this.name + 1];\n        for (var i = 0; i < argc; ++i) {\n            insertAtArgs.push(arguments[i]);\n        }\n        return pp.insertAt.apply(pp, insertAtArgs);\n    };\n\n    function repairRelationshipWithParent(path) {\n        if (!(path instanceof Path)) {\n            throw new Error(\"\");\n        }\n\n        var pp = path.parentPath;\n        if (!pp) {\n            // Orphan paths have no relationship to repair.\n            return path;\n        }\n\n        var parentValue = pp.value;\n        var parentCache = getChildCache(pp);\n\n        // Make sure parentCache[path.name] is populated.\n        if (parentValue[path.name] === path.value) {\n            parentCache[path.name] = path;\n        } else if (isArray.check(parentValue)) {\n            // Something caused path.name to become out of date, so attempt to\n            // recover by searching for path.value in parentValue.\n            var i = parentValue.indexOf(path.value);\n            if (i >= 0) {\n                parentCache[path.name = i] = path;\n            }\n        } else {\n            // If path.value disagrees with parentValue[path.name], and\n            // path.name is not an array index, let path.value become the new\n            // parentValue[path.name] and update parentCache accordingly.\n            parentValue[path.name] = path.value;\n            parentCache[path.name] = path;\n        }\n\n        if (parentValue[path.name] !== path.value) {\n            throw new Error(\"\");\n        }\n        if (path.parentPath.get(path.name) !== path) {\n            throw new Error(\"\");\n        }\n\n        return path;\n    }\n\n    Pp.replace = function replace(replacement) {\n        var results = [];\n        var parentValue = this.parentPath.value;\n        var parentCache = getChildCache(this.parentPath);\n        var count = arguments.length;\n\n        repairRelationshipWithParent(this);\n\n        if (isArray.check(parentValue)) {\n            var originalLength = parentValue.length;\n            var move = getMoves(this.parentPath, count - 1, this.name + 1);\n\n            var spliceArgs = [this.name, 1];\n            for (var i = 0; i < count; ++i) {\n                spliceArgs.push(arguments[i]);\n            }\n\n            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n\n            if (splicedOut[0] !== this.value) {\n                throw new Error(\"\");\n            }\n            if (parentValue.length !== (originalLength - 1 + count)) {\n                throw new Error(\"\");\n            }\n\n            move();\n\n            if (count === 0) {\n                delete this.value;\n                delete parentCache[this.name];\n                this.__childCache = null;\n\n            } else {\n                if (parentValue[this.name] !== replacement) {\n                    throw new Error(\"\");\n                }\n\n                if (this.value !== replacement) {\n                    this.value = replacement;\n                    this.__childCache = null;\n                }\n\n                for (i = 0; i < count; ++i) {\n                    results.push(this.parentPath.get(this.name + i));\n                }\n\n                if (results[0] !== this) {\n                    throw new Error(\"\");\n                }\n            }\n\n        } else if (count === 1) {\n            if (this.value !== replacement) {\n                this.__childCache = null;\n            }\n            this.value = parentValue[this.name] = replacement;\n            results.push(this);\n\n        } else if (count === 0) {\n            delete parentValue[this.name];\n            delete this.value;\n            this.__childCache = null;\n\n            // Leave this path cached as parentCache[this.name], even though\n            // it no longer has a value defined.\n\n        } else {\n            throw new Error(\"Could not replace path\");\n        }\n\n        return results;\n    };\n\n    return Path;\n};\n","module.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var n = types.namedTypes;\n    var b = types.builders;\n    var isNumber = types.builtInTypes.number;\n    var isArray = types.builtInTypes.array;\n    var Path = fork.use(require(\"./path\"));\n    var Scope = fork.use(require(\"./scope\"));\n\n    function NodePath(value, parentPath, name) {\n        if (!(this instanceof NodePath)) {\n            throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n        }\n        Path.call(this, value, parentPath, name);\n    }\n\n    var NPp = NodePath.prototype = Object.create(Path.prototype, {\n        constructor: {\n            value: NodePath,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n\n    Object.defineProperties(NPp, {\n        node: {\n            get: function () {\n                Object.defineProperty(this, \"node\", {\n                    configurable: true, // Enable deletion.\n                    value: this._computeNode()\n                });\n\n                return this.node;\n            }\n        },\n\n        parent: {\n            get: function () {\n                Object.defineProperty(this, \"parent\", {\n                    configurable: true, // Enable deletion.\n                    value: this._computeParent()\n                });\n\n                return this.parent;\n            }\n        },\n\n        scope: {\n            get: function () {\n                Object.defineProperty(this, \"scope\", {\n                    configurable: true, // Enable deletion.\n                    value: this._computeScope()\n                });\n\n                return this.scope;\n            }\n        }\n    });\n\n    NPp.replace = function () {\n        delete this.node;\n        delete this.parent;\n        delete this.scope;\n        return Path.prototype.replace.apply(this, arguments);\n    };\n\n    NPp.prune = function () {\n        var remainingNodePath = this.parent;\n\n        this.replace();\n\n        return cleanUpNodesAfterPrune(remainingNodePath);\n    };\n\n    // The value of the first ancestor Path whose value is a Node.\n    NPp._computeNode = function () {\n        var value = this.value;\n        if (n.Node.check(value)) {\n            return value;\n        }\n\n        var pp = this.parentPath;\n        return pp && pp.node || null;\n    };\n\n    // The first ancestor Path whose value is a Node distinct from this.node.\n    NPp._computeParent = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n\n        if (!n.Node.check(value)) {\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n\n            if (pp) {\n                pp = pp.parentPath;\n            }\n        }\n\n        while (pp && !n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n        }\n\n        return pp || null;\n    };\n\n    // The closest enclosing scope that governs this node.\n    NPp._computeScope = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        var scope = pp && pp.scope;\n\n        if (n.Node.check(value) &&\n          Scope.isEstablishedBy(value)) {\n            scope = new Scope(this, scope);\n        }\n\n        return scope || null;\n    };\n\n    NPp.getValueProperty = function (name) {\n        return types.getFieldValue(this.value, name);\n    };\n\n    /**\n     * Determine whether this.node needs to be wrapped in parentheses in order\n     * for a parser to reproduce the same local AST structure.\n     *\n     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n     * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n     * parse differently.\n     *\n     * If assumeExpressionContext === true, we don't worry about edge cases\n     * like an anonymous FunctionExpression appearing lexically first in its\n     * enclosing statement and thus needing parentheses to avoid being parsed\n     * as a FunctionDeclaration with a missing name.\n     */\n    NPp.needsParens = function (assumeExpressionContext) {\n        var pp = this.parentPath;\n        if (!pp) {\n            return false;\n        }\n\n        var node = this.value;\n\n        // Only expressions need parentheses.\n        if (!n.Expression.check(node)) {\n            return false;\n        }\n\n        // Identifiers never need parentheses.\n        if (node.type === \"Identifier\") {\n            return false;\n        }\n\n        while (!n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n            if (!pp) {\n                return false;\n            }\n        }\n\n        var parent = pp.value;\n\n        switch (node.type) {\n            case \"UnaryExpression\":\n            case \"SpreadElement\":\n            case \"SpreadProperty\":\n                return parent.type === \"MemberExpression\"\n                  && this.name === \"object\"\n                  && parent.object === node;\n\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n                switch (parent.type) {\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                          && parent.callee === node;\n\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                        return true;\n\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                          && parent.object === node;\n\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        var po = parent.operator;\n                        var pp = PRECEDENCE[po];\n                        var no = node.operator;\n                        var np = PRECEDENCE[no];\n\n                        if (pp > np) {\n                            return true;\n                        }\n\n                        if (pp === np && this.name === \"right\") {\n                            if (parent.right !== node) {\n                                throw new Error(\"Nodes must be equal\");\n                            }\n                            return true;\n                        }\n\n                    default:\n                        return false;\n                }\n\n            case \"SequenceExpression\":\n                switch (parent.type) {\n                    case \"ForStatement\":\n                        // Although parentheses wouldn't hurt around sequence\n                        // expressions in the head of for loops, traditional style\n                        // dictates that e.g. i++, j++ should not be wrapped with\n                        // parentheses.\n                        return false;\n\n                    case \"ExpressionStatement\":\n                        return this.name !== \"expression\";\n\n                    default:\n                        // Otherwise err on the side of overparenthesization, adding\n                        // explicit exceptions above if this proves overzealous.\n                        return true;\n                }\n\n            case \"YieldExpression\":\n                switch (parent.type) {\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"CallExpression\":\n                    case \"MemberExpression\":\n                    case \"NewExpression\":\n                    case \"ConditionalExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        return false;\n                }\n\n            case \"Literal\":\n                return parent.type === \"MemberExpression\"\n                  && isNumber.check(node.value)\n                  && this.name === \"object\"\n                  && parent.object === node;\n\n            case \"AssignmentExpression\":\n            case \"ConditionalExpression\":\n                switch (parent.type) {\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        return true;\n\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                          && parent.callee === node;\n\n                    case \"ConditionalExpression\":\n                        return this.name === \"test\"\n                          && parent.test === node;\n\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                          && parent.object === node;\n\n                    default:\n                        return false;\n                }\n\n            default:\n                if (parent.type === \"NewExpression\" &&\n                  this.name === \"callee\" &&\n                  parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n        }\n\n        if (assumeExpressionContext !== true &&\n          !this.canBeFirstInStatement() &&\n          this.firstInStatement())\n            return true;\n\n        return false;\n    };\n\n    function isBinary(node) {\n        return n.BinaryExpression.check(node)\n          || n.LogicalExpression.check(node);\n    }\n\n    function isUnaryLike(node) {\n        return n.UnaryExpression.check(node)\n          // I considered making SpreadElement and SpreadProperty subtypes\n          // of UnaryExpression, but they're not really Expression nodes.\n          || (n.SpreadElement && n.SpreadElement.check(node))\n          || (n.SpreadProperty && n.SpreadProperty.check(node));\n    }\n\n    var PRECEDENCE = {};\n    [[\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ].forEach(function (tier, i) {\n        tier.forEach(function (op) {\n            PRECEDENCE[op] = i;\n        });\n    });\n\n    function containsCallExpression(node) {\n        if (n.CallExpression.check(node)) {\n            return true;\n        }\n\n        if (isArray.check(node)) {\n            return node.some(containsCallExpression);\n        }\n\n        if (n.Node.check(node)) {\n            return types.someField(node, function (name, child) {\n                return containsCallExpression(child);\n            });\n        }\n\n        return false;\n    }\n\n    NPp.canBeFirstInStatement = function () {\n        var node = this.node;\n        return !n.FunctionExpression.check(node)\n          && !n.ObjectExpression.check(node);\n    };\n\n    NPp.firstInStatement = function () {\n        return firstInStatement(this);\n    };\n\n    function firstInStatement(path) {\n        for (var node, parent; path.parent; path = path.parent) {\n            node = path.node;\n            parent = path.parent.node;\n\n            if (n.BlockStatement.check(parent) &&\n              path.parent.name === \"body\" &&\n              path.name === 0) {\n                if (parent.body[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n\n            if (n.ExpressionStatement.check(parent) &&\n              path.name === \"expression\") {\n                if (parent.expression !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n\n            if (n.SequenceExpression.check(parent) &&\n              path.parent.name === \"expressions\" &&\n              path.name === 0) {\n                if (parent.expressions[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.CallExpression.check(parent) &&\n              path.name === \"callee\") {\n                if (parent.callee !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.MemberExpression.check(parent) &&\n              path.name === \"object\") {\n                if (parent.object !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.ConditionalExpression.check(parent) &&\n              path.name === \"test\") {\n                if (parent.test !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (isBinary(parent) &&\n              path.name === \"left\") {\n                if (parent.left !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.UnaryExpression.check(parent) &&\n              !parent.prefix &&\n              path.name === \"argument\") {\n                if (parent.argument !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n     */\n    function cleanUpNodesAfterPrune(remainingNodePath) {\n        if (n.VariableDeclaration.check(remainingNodePath.node)) {\n            var declarations = remainingNodePath.get('declarations').value;\n            if (!declarations || declarations.length === 0) {\n                return remainingNodePath.prune();\n            }\n        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n            if (!remainingNodePath.get('expression').value) {\n                return remainingNodePath.prune();\n            }\n        } else if (n.IfStatement.check(remainingNodePath.node)) {\n            cleanUpIfStatementAfterPrune(remainingNodePath);\n        }\n\n        return remainingNodePath;\n    }\n\n    function cleanUpIfStatementAfterPrune(ifStatement) {\n        var testExpression = ifStatement.get('test').value;\n        var alternate = ifStatement.get('alternate').value;\n        var consequent = ifStatement.get('consequent').value;\n\n        if (!consequent && !alternate) {\n            var testExpressionStatement = b.expressionStatement(testExpression);\n\n            ifStatement.replace(testExpressionStatement);\n        } else if (!consequent && alternate) {\n            var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n\n            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                negatedTestExpression = testExpression.argument;\n            }\n\n            ifStatement.get(\"test\").replace(negatedTestExpression);\n            ifStatement.get(\"consequent\").replace(alternate);\n            ifStatement.get(\"alternate\").replace();\n        }\n    }\n\n    return NodePath;\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var Type = types.Type;\n    var namedTypes = types.namedTypes;\n    var Node = namedTypes.Node;\n    var Expression = namedTypes.Expression;\n    var isArray = types.builtInTypes.array;\n    var b = types.builders;\n\n    function Scope(path, parentScope) {\n        if (!(this instanceof Scope)) {\n            throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n        }\n        if (!(path instanceof fork.use(require(\"./node-path\")))) {\n            throw new Error(\"\");\n        }\n        ScopeType.assert(path.value);\n\n        var depth;\n\n        if (parentScope) {\n            if (!(parentScope instanceof Scope)) {\n                throw new Error(\"\");\n            }\n            depth = parentScope.depth + 1;\n        } else {\n            parentScope = null;\n            depth = 0;\n        }\n\n        Object.defineProperties(this, {\n            path: { value: path },\n            node: { value: path.value },\n            isGlobal: { value: !parentScope, enumerable: true },\n            depth: { value: depth },\n            parent: { value: parentScope },\n            bindings: { value: {} },\n            types: { value: {} },\n        });\n    }\n\n    var scopeTypes = [\n        // Program nodes introduce global scopes.\n        namedTypes.Program,\n\n        // Function is the supertype of FunctionExpression,\n        // FunctionDeclaration, ArrowExpression, etc.\n        namedTypes.Function,\n\n        // In case you didn't know, the caught parameter shadows any variable\n        // of the same name in an outer scope.\n        namedTypes.CatchClause\n    ];\n\n    var ScopeType = Type.or.apply(Type, scopeTypes);\n\n    Scope.isEstablishedBy = function(node) {\n        return ScopeType.check(node);\n    };\n\n    var Sp = Scope.prototype;\n\n// Will be overridden after an instance lazily calls scanScope.\n    Sp.didScan = false;\n\n    Sp.declares = function(name) {\n        this.scan();\n        return hasOwn.call(this.bindings, name);\n    };\n\n    Sp.declaresType = function(name) {\n        this.scan();\n        return hasOwn.call(this.types, name);\n    };\n\n    Sp.declareTemporary = function(prefix) {\n        if (prefix) {\n            if (!/^[a-z$_]/i.test(prefix)) {\n                throw new Error(\"\");\n            }\n        } else {\n            prefix = \"t$\";\n        }\n\n        // Include this.depth in the name to make sure the name does not\n        // collide with any variables in nested/enclosing scopes.\n        prefix += this.depth.toString(36) + \"$\";\n\n        this.scan();\n\n        var index = 0;\n        while (this.declares(prefix + index)) {\n            ++index;\n        }\n\n        var name = prefix + index;\n        return this.bindings[name] = types.builders.identifier(name);\n    };\n\n    Sp.injectTemporary = function(identifier, init) {\n        identifier || (identifier = this.declareTemporary());\n\n        var bodyPath = this.path.get(\"body\");\n        if (namedTypes.BlockStatement.check(bodyPath.value)) {\n            bodyPath = bodyPath.get(\"body\");\n        }\n\n        bodyPath.unshift(\n          b.variableDeclaration(\n            \"var\",\n            [b.variableDeclarator(identifier, init || null)]\n          )\n        );\n\n        return identifier;\n    };\n\n    Sp.scan = function(force) {\n        if (force || !this.didScan) {\n            for (var name in this.bindings) {\n                // Empty out this.bindings, just in cases.\n                delete this.bindings[name];\n            }\n            scanScope(this.path, this.bindings, this.types);\n            this.didScan = true;\n        }\n    };\n\n    Sp.getBindings = function () {\n        this.scan();\n        return this.bindings;\n    };\n\n    Sp.getTypes = function () {\n        this.scan();\n        return this.types;\n    };\n\n    function scanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        ScopeType.assert(node);\n\n        if (namedTypes.CatchClause.check(node)) {\n            // A catch clause establishes a new scope but the only variable\n            // bound in that scope is the catch parameter. Any other\n            // declarations create bindings in the outer scope.\n            addPattern(path.get(\"param\"), bindings);\n\n        } else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n\n    function recursiveScanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n\n        if (path.parent &&\n          namedTypes.FunctionExpression.check(path.parent.node) &&\n          path.parent.node.id) {\n            addPattern(path.parent.get(\"id\"), bindings);\n        }\n\n        if (!node) {\n            // None of the remaining cases matter if node is falsy.\n\n        } else if (isArray.check(node)) {\n            path.each(function(childPath) {\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n\n        } else if (namedTypes.Function.check(node)) {\n            path.get(\"params\").each(function(paramPath) {\n                addPattern(paramPath, bindings);\n            });\n\n            recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n\n        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {\n            addTypePattern(path.get(\"id\"), scopeTypes);\n\n        } else if (namedTypes.VariableDeclarator.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n            recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n\n        } else if (node.type === \"ImportSpecifier\" ||\n          node.type === \"ImportNamespaceSpecifier\" ||\n          node.type === \"ImportDefaultSpecifier\") {\n            addPattern(\n              // Esprima used to use the .name field to refer to the local\n              // binding identifier for ImportSpecifier nodes, but .id for\n              // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n              // ESTree/Acorn/ESpree use .local for all three node types.\n              path.get(node.local ? \"local\" :\n                node.name ? \"name\" : \"id\"),\n              bindings\n            );\n\n        } else if (Node.check(node) && !Expression.check(node)) {\n            types.eachField(node, function(name, child) {\n                var childPath = path.get(name);\n                if (!pathHasValue(childPath, child)) {\n                    throw new Error(\"\");\n                }\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n    }\n\n    function pathHasValue(path, value) {\n        if (path.value === value) {\n            return true;\n        }\n\n        // Empty arrays are probably produced by defaults.emptyArray, in which\n        // case is makes sense to regard them as equivalent, if not ===.\n        if (Array.isArray(path.value) &&\n          path.value.length === 0 &&\n          Array.isArray(value) &&\n          value.length === 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function recursiveScanChild(path, bindings, scopeTypes) {\n        var node = path.value;\n\n        if (!node || Expression.check(node)) {\n            // Ignore falsy values and Expressions.\n\n        } else if (namedTypes.FunctionDeclaration.check(node) &&\n                   node.id !== null) {\n            addPattern(path.get(\"id\"), bindings);\n\n        } else if (namedTypes.ClassDeclaration &&\n          namedTypes.ClassDeclaration.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n\n        } else if (ScopeType.check(node)) {\n            if (namedTypes.CatchClause.check(node)) {\n                var catchParamName = node.param.name;\n                var hadBinding = hasOwn.call(bindings, catchParamName);\n\n                // Any declarations that occur inside the catch body that do\n                // not have the same name as the catch parameter should count\n                // as bindings in the outer scope.\n                recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n\n                // If a new binding matching the catch parameter name was\n                // created while scanning the catch body, ignore it because it\n                // actually refers to the catch parameter and not the outer\n                // scope that we're currently scanning.\n                if (!hadBinding) {\n                    delete bindings[catchParamName];\n                }\n            }\n\n        } else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n\n    function addPattern(patternPath, bindings) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(bindings, pattern.name)) {\n                bindings[pattern.name].push(patternPath);\n            } else {\n                bindings[pattern.name] = [patternPath];\n            }\n\n        } else if (namedTypes.ObjectPattern &&\n          namedTypes.ObjectPattern.check(pattern)) {\n            patternPath.get('properties').each(function(propertyPath) {\n                var property = propertyPath.value;\n                if (namedTypes.Pattern.check(property)) {\n                    addPattern(propertyPath, bindings);\n                } else  if (namedTypes.Property.check(property)) {\n                    addPattern(propertyPath.get('value'), bindings);\n                } else if (namedTypes.SpreadProperty &&\n                  namedTypes.SpreadProperty.check(property)) {\n                    addPattern(propertyPath.get('argument'), bindings);\n                }\n            });\n\n        } else if (namedTypes.ArrayPattern &&\n          namedTypes.ArrayPattern.check(pattern)) {\n            patternPath.get('elements').each(function(elementPath) {\n                var element = elementPath.value;\n                if (namedTypes.Pattern.check(element)) {\n                    addPattern(elementPath, bindings);\n                } else if (namedTypes.SpreadElement &&\n                  namedTypes.SpreadElement.check(element)) {\n                    addPattern(elementPath.get(\"argument\"), bindings);\n                }\n            });\n\n        } else if (namedTypes.PropertyPattern &&\n          namedTypes.PropertyPattern.check(pattern)) {\n            addPattern(patternPath.get('pattern'), bindings);\n\n        } else if ((namedTypes.SpreadElementPattern &&\n          namedTypes.SpreadElementPattern.check(pattern)) ||\n          (namedTypes.SpreadPropertyPattern &&\n          namedTypes.SpreadPropertyPattern.check(pattern))) {\n            addPattern(patternPath.get('argument'), bindings);\n        }\n    }\n\n    function addTypePattern(patternPath, types) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(types, pattern.name)) {\n                types[pattern.name].push(patternPath);\n            } else {\n                types[pattern.name] = [patternPath];\n            }\n\n        }\n    }\n\n    Sp.lookup = function(name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declares(name))\n                break;\n        return scope;\n    };\n\n    Sp.lookupType = function(name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declaresType(name))\n                break;\n        return scope;\n    };\n\n    Sp.getGlobalScope = function() {\n        var scope = this;\n        while (!scope.isGlobal)\n            scope = scope.parent;\n        return scope;\n    };\n\n    return Scope;\n};\n","var hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var NodePath = fork.use(require(\"./node-path\"));\n    var Printable = types.namedTypes.Printable;\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isFunction = types.builtInTypes.function;\n    var undefined;\n\n    function PathVisitor() {\n        if (!(this instanceof PathVisitor)) {\n            throw new Error(\n              \"PathVisitor constructor cannot be invoked without 'new'\"\n            );\n        }\n\n        // Permanent state.\n        this._reusableContextStack = [];\n\n        this._methodNameTable = computeMethodNameTable(this);\n        this._shouldVisitComments =\n          hasOwn.call(this._methodNameTable, \"Block\") ||\n          hasOwn.call(this._methodNameTable, \"Line\");\n\n        this.Context = makeContextConstructor(this);\n\n        // State reset every time PathVisitor.prototype.visit is called.\n        this._visiting = false;\n        this._changeReported = false;\n    }\n\n    function computeMethodNameTable(visitor) {\n        var typeNames = Object.create(null);\n\n        for (var methodName in visitor) {\n            if (/^visit[A-Z]/.test(methodName)) {\n                typeNames[methodName.slice(\"visit\".length)] = true;\n            }\n        }\n\n        var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n        var methodNameTable = Object.create(null);\n\n        var typeNames = Object.keys(supertypeTable);\n        var typeNameCount = typeNames.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNames[i];\n            methodName = \"visit\" + supertypeTable[typeName];\n            if (isFunction.check(visitor[methodName])) {\n                methodNameTable[typeName] = methodName;\n            }\n        }\n\n        return methodNameTable;\n    }\n\n    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n        if (methods instanceof PathVisitor) {\n            return methods;\n        }\n\n        if (!isObject.check(methods)) {\n            // An empty visitor?\n            return new PathVisitor;\n        }\n\n        function Visitor() {\n            if (!(this instanceof Visitor)) {\n                throw new Error(\n                  \"Visitor constructor cannot be invoked without 'new'\"\n                );\n            }\n            PathVisitor.call(this);\n        }\n\n        var Vp = Visitor.prototype = Object.create(PVp);\n        Vp.constructor = Visitor;\n\n        extend(Vp, methods);\n        extend(Visitor, PathVisitor);\n\n        isFunction.assert(Visitor.fromMethodsObject);\n        isFunction.assert(Visitor.visit);\n\n        return new Visitor;\n    };\n\n    function extend(target, source) {\n        for (var property in source) {\n            if (hasOwn.call(source, property)) {\n                target[property] = source[property];\n            }\n        }\n\n        return target;\n    }\n\n    PathVisitor.visit = function visit(node, methods) {\n        return PathVisitor.fromMethodsObject(methods).visit(node);\n    };\n\n    var PVp = PathVisitor.prototype;\n\n    PVp.visit = function () {\n        if (this._visiting) {\n            throw new Error(\n              \"Recursively calling visitor.visit(path) resets visitor state. \" +\n              \"Try this.visit(path) or this.traverse(path) instead.\"\n            );\n        }\n\n        // Private state that needs to be reset before every traversal.\n        this._visiting = true;\n        this._changeReported = false;\n        this._abortRequested = false;\n\n        var argc = arguments.length;\n        var args = new Array(argc)\n        for (var i = 0; i < argc; ++i) {\n            args[i] = arguments[i];\n        }\n\n        if (!(args[0] instanceof NodePath)) {\n            args[0] = new NodePath({root: args[0]}).get(\"root\");\n        }\n\n        // Called with the same arguments as .visit.\n        this.reset.apply(this, args);\n\n        try {\n            var root = this.visitWithoutReset(args[0]);\n            var didNotThrow = true;\n        } finally {\n            this._visiting = false;\n\n            if (!didNotThrow && this._abortRequested) {\n                // If this.visitWithoutReset threw an exception and\n                // this._abortRequested was set to true, return the root of\n                // the AST instead of letting the exception propagate, so that\n                // client code does not have to provide a try-catch block to\n                // intercept the AbortRequest exception.  Other kinds of\n                // exceptions will propagate without being intercepted and\n                // rethrown by a catch block, so their stacks will accurately\n                // reflect the original throwing context.\n                return args[0].value;\n            }\n        }\n\n        return root;\n    };\n\n    PVp.AbortRequest = function AbortRequest() {};\n    PVp.abort = function () {\n        var visitor = this;\n        visitor._abortRequested = true;\n        var request = new visitor.AbortRequest();\n\n        // If you decide to catch this exception and stop it from propagating,\n        // make sure to call its cancel method to avoid silencing other\n        // exceptions that might be thrown later in the traversal.\n        request.cancel = function () {\n            visitor._abortRequested = false;\n        };\n\n        throw request;\n    };\n\n    PVp.reset = function (path/*, additional arguments */) {\n        // Empty stub; may be reassigned or overridden by subclasses.\n    };\n\n    PVp.visitWithoutReset = function (path) {\n        if (this instanceof this.Context) {\n            // Since this.Context.prototype === this, there's a chance we\n            // might accidentally call context.visitWithoutReset. If that\n            // happens, re-invoke the method against context.visitor.\n            return this.visitor.visitWithoutReset(path);\n        }\n\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n\n        var value = path.value;\n\n        var methodName = value &&\n          typeof value === \"object\" &&\n          typeof value.type === \"string\" &&\n          this._methodNameTable[value.type];\n\n        if (methodName) {\n            var context = this.acquireContext(path);\n            try {\n                return context.invokeVisitorMethod(methodName);\n            } finally {\n                this.releaseContext(context);\n            }\n\n        } else {\n            // If there was no visitor method to call, visit the children of\n            // this node generically.\n            return visitChildren(path, this);\n        }\n    };\n\n    function visitChildren(path, visitor) {\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n\n        var value = path.value;\n\n        if (isArray.check(value)) {\n            path.each(visitor.visitWithoutReset, visitor);\n        } else if (!isObject.check(value)) {\n            // No children to visit.\n        } else {\n            var childNames = types.getFieldNames(value);\n\n            // The .comments field of the Node type is hidden, so we only\n            // visit it if the visitor defines visitBlock or visitLine, and\n            // value.comments is defined.\n            if (visitor._shouldVisitComments &&\n              value.comments &&\n              childNames.indexOf(\"comments\") < 0) {\n                childNames.push(\"comments\");\n            }\n\n            var childCount = childNames.length;\n            var childPaths = [];\n\n            for (var i = 0; i < childCount; ++i) {\n                var childName = childNames[i];\n                if (!hasOwn.call(value, childName)) {\n                    value[childName] = types.getFieldValue(value, childName);\n                }\n                childPaths.push(path.get(childName));\n            }\n\n            for (var i = 0; i < childCount; ++i) {\n                visitor.visitWithoutReset(childPaths[i]);\n            }\n        }\n\n        return path.value;\n    }\n\n    PVp.acquireContext = function (path) {\n        if (this._reusableContextStack.length === 0) {\n            return new this.Context(path);\n        }\n        return this._reusableContextStack.pop().reset(path);\n    };\n\n    PVp.releaseContext = function (context) {\n        if (!(context instanceof this.Context)) {\n            throw new Error(\"\");\n        }\n        this._reusableContextStack.push(context);\n        context.currentPath = null;\n    };\n\n    PVp.reportChanged = function () {\n        this._changeReported = true;\n    };\n\n    PVp.wasChangeReported = function () {\n        return this._changeReported;\n    };\n\n    function makeContextConstructor(visitor) {\n        function Context(path) {\n            if (!(this instanceof Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this instanceof PathVisitor)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n\n            Object.defineProperty(this, \"visitor\", {\n                value: visitor,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            });\n\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n\n            Object.seal(this);\n        }\n\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n\n        // Note that the visitor object is the prototype of Context.prototype,\n        // so all visitor methods are inherited by context objects.\n        var Cp = Context.prototype = Object.create(visitor);\n\n        Cp.constructor = Context;\n        extend(Cp, sharedContextProtoMethods);\n\n        return Context;\n    }\n\n// Every PathVisitor has a different this.Context constructor and\n// this.Context.prototype object, but those prototypes can all use the\n// same reset, invokeVisitorMethod, and traverse function objects.\n    var sharedContextProtoMethods = Object.create(null);\n\n    sharedContextProtoMethods.reset =\n      function reset(path) {\n          if (!(this instanceof this.Context)) {\n              throw new Error(\"\");\n          }\n          if (!(path instanceof NodePath)) {\n              throw new Error(\"\");\n          }\n\n          this.currentPath = path;\n          this.needToCallTraverse = true;\n\n          return this;\n      };\n\n    sharedContextProtoMethods.invokeVisitorMethod =\n      function invokeVisitorMethod(methodName) {\n          if (!(this instanceof this.Context)) {\n              throw new Error(\"\");\n          }\n          if (!(this.currentPath instanceof NodePath)) {\n              throw new Error(\"\");\n          }\n\n          var result = this.visitor[methodName].call(this, this.currentPath);\n\n          if (result === false) {\n              // Visitor methods return false to indicate that they have handled\n              // their own traversal needs, and we should not complain if\n              // this.needToCallTraverse is still true.\n              this.needToCallTraverse = false;\n\n          } else if (result !== undefined) {\n              // Any other non-undefined value returned from the visitor method\n              // is interpreted as a replacement value.\n              this.currentPath = this.currentPath.replace(result)[0];\n\n              if (this.needToCallTraverse) {\n                  // If this.traverse still hasn't been called, visit the\n                  // children of the replacement node.\n                  this.traverse(this.currentPath);\n              }\n          }\n\n          if (this.needToCallTraverse !== false) {\n              throw new Error(\n                \"Must either call this.traverse or return false in \" + methodName\n              );\n          }\n\n          var path = this.currentPath;\n          return path && path.value;\n      };\n\n    sharedContextProtoMethods.traverse =\n      function traverse(path, newVisitor) {\n          if (!(this instanceof this.Context)) {\n              throw new Error(\"\");\n          }\n          if (!(path instanceof NodePath)) {\n              throw new Error(\"\");\n          }\n          if (!(this.currentPath instanceof NodePath)) {\n              throw new Error(\"\");\n          }\n\n          this.needToCallTraverse = false;\n\n          return visitChildren(path, PathVisitor.fromMethodsObject(\n            newVisitor || this.visitor\n          ));\n      };\n\n    sharedContextProtoMethods.visit =\n      function visit(path, newVisitor) {\n          if (!(this instanceof this.Context)) {\n              throw new Error(\"\");\n          }\n          if (!(path instanceof NodePath)) {\n              throw new Error(\"\");\n          }\n          if (!(this.currentPath instanceof NodePath)) {\n              throw new Error(\"\");\n          }\n\n          this.needToCallTraverse = false;\n\n          return PathVisitor.fromMethodsObject(\n            newVisitor || this.visitor\n          ).visitWithoutReset(path);\n      };\n\n    sharedContextProtoMethods.reportChanged = function reportChanged() {\n        this.visitor.reportChanged();\n    };\n\n    sharedContextProtoMethods.abort = function abort() {\n        this.needToCallTraverse = false;\n        this.visitor.abort();\n    };\n\n    return PathVisitor;\n};\n","module.exports = function (fork) {\n    var types = fork.use(require(\"../lib/types\"));\n    var Type = types.Type;\n    var def = Type.def;\n    var or = Type.or;\n    var shared = fork.use(require(\"../lib/shared\"));\n    var defaults = shared.defaults;\n    var geq = shared.geq;\n\n    // Abstract supertype of all syntactic entities that are allowed to have a\n    // .loc field.\n    def(\"Printable\")\n        .field(\"loc\", or(\n            def(\"SourceLocation\"),\n            null\n        ), defaults[\"null\"], true);\n\n    def(\"Node\")\n        .bases(\"Printable\")\n        .field(\"type\", String)\n        .field(\"comments\", or(\n            [def(\"Comment\")],\n            null\n        ), defaults[\"null\"], true);\n\n    def(\"SourceLocation\")\n        .build(\"start\", \"end\", \"source\")\n        .field(\"start\", def(\"Position\"))\n        .field(\"end\", def(\"Position\"))\n        .field(\"source\", or(String, null), defaults[\"null\"]);\n\n    def(\"Position\")\n        .build(\"line\", \"column\")\n        .field(\"line\", geq(1))\n        .field(\"column\", geq(0));\n\n    def(\"File\")\n        .bases(\"Node\")\n        .build(\"program\", \"name\")\n        .field(\"program\", def(\"Program\"))\n        .field(\"name\", or(String, null), defaults[\"null\"]);\n\n    def(\"Program\")\n        .bases(\"Node\")\n        .build(\"body\")\n        .field(\"body\", [def(\"Statement\")]);\n\n    def(\"Function\")\n        .bases(\"Node\")\n        .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"])\n        .field(\"params\", [def(\"Pattern\")])\n        .field(\"body\", def(\"BlockStatement\"));\n\n    def(\"Statement\").bases(\"Node\");\n\n// The empty .build() here means that an EmptyStatement can be constructed\n// (i.e. it's not abstract) but that it needs no arguments.\n    def(\"EmptyStatement\").bases(\"Statement\").build();\n\n    def(\"BlockStatement\")\n        .bases(\"Statement\")\n        .build(\"body\")\n        .field(\"body\", [def(\"Statement\")]);\n\n    // TODO Figure out how to silently coerce Expressions to\n    // ExpressionStatements where a Statement was expected.\n    def(\"ExpressionStatement\")\n        .bases(\"Statement\")\n        .build(\"expression\")\n        .field(\"expression\", def(\"Expression\"));\n\n    def(\"IfStatement\")\n        .bases(\"Statement\")\n        .build(\"test\", \"consequent\", \"alternate\")\n        .field(\"test\", def(\"Expression\"))\n        .field(\"consequent\", def(\"Statement\"))\n        .field(\"alternate\", or(def(\"Statement\"), null), defaults[\"null\"]);\n\n    def(\"LabeledStatement\")\n        .bases(\"Statement\")\n        .build(\"label\", \"body\")\n        .field(\"label\", def(\"Identifier\"))\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"BreakStatement\")\n        .bases(\"Statement\")\n        .build(\"label\")\n        .field(\"label\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n\n    def(\"ContinueStatement\")\n        .bases(\"Statement\")\n        .build(\"label\")\n        .field(\"label\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n\n    def(\"WithStatement\")\n        .bases(\"Statement\")\n        .build(\"object\", \"body\")\n        .field(\"object\", def(\"Expression\"))\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"SwitchStatement\")\n        .bases(\"Statement\")\n        .build(\"discriminant\", \"cases\", \"lexical\")\n        .field(\"discriminant\", def(\"Expression\"))\n        .field(\"cases\", [def(\"SwitchCase\")])\n        .field(\"lexical\", Boolean, defaults[\"false\"]);\n\n    def(\"ReturnStatement\")\n        .bases(\"Statement\")\n        .build(\"argument\")\n        .field(\"argument\", or(def(\"Expression\"), null));\n\n    def(\"ThrowStatement\")\n        .bases(\"Statement\")\n        .build(\"argument\")\n        .field(\"argument\", def(\"Expression\"));\n\n    def(\"TryStatement\")\n        .bases(\"Statement\")\n        .build(\"block\", \"handler\", \"finalizer\")\n        .field(\"block\", def(\"BlockStatement\"))\n        .field(\"handler\", or(def(\"CatchClause\"), null), function () {\n            return this.handlers && this.handlers[0] || null;\n        })\n        .field(\"handlers\", [def(\"CatchClause\")], function () {\n            return this.handler ? [this.handler] : [];\n        }, true) // Indicates this field is hidden from eachField iteration.\n        .field(\"guardedHandlers\", [def(\"CatchClause\")], defaults.emptyArray)\n        .field(\"finalizer\", or(def(\"BlockStatement\"), null), defaults[\"null\"]);\n\n    def(\"CatchClause\")\n        .bases(\"Node\")\n        .build(\"param\", \"guard\", \"body\")\n        .field(\"param\", def(\"Pattern\"))\n        .field(\"guard\", or(def(\"Expression\"), null), defaults[\"null\"])\n        .field(\"body\", def(\"BlockStatement\"));\n\n    def(\"WhileStatement\")\n        .bases(\"Statement\")\n        .build(\"test\", \"body\")\n        .field(\"test\", def(\"Expression\"))\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"DoWhileStatement\")\n        .bases(\"Statement\")\n        .build(\"body\", \"test\")\n        .field(\"body\", def(\"Statement\"))\n        .field(\"test\", def(\"Expression\"));\n\n    def(\"ForStatement\")\n        .bases(\"Statement\")\n        .build(\"init\", \"test\", \"update\", \"body\")\n        .field(\"init\", or(\n            def(\"VariableDeclaration\"),\n            def(\"Expression\"),\n            null))\n        .field(\"test\", or(def(\"Expression\"), null))\n        .field(\"update\", or(def(\"Expression\"), null))\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"ForInStatement\")\n        .bases(\"Statement\")\n        .build(\"left\", \"right\", \"body\")\n        .field(\"left\", or(\n            def(\"VariableDeclaration\"),\n            def(\"Expression\")))\n        .field(\"right\", def(\"Expression\"))\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"DebuggerStatement\").bases(\"Statement\").build();\n\n    def(\"Declaration\").bases(\"Statement\");\n\n    def(\"FunctionDeclaration\")\n        .bases(\"Function\", \"Declaration\")\n        .build(\"id\", \"params\", \"body\")\n        .field(\"id\", def(\"Identifier\"));\n\n    def(\"FunctionExpression\")\n        .bases(\"Function\", \"Expression\")\n        .build(\"id\", \"params\", \"body\");\n\n    def(\"VariableDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"kind\", \"declarations\")\n        .field(\"kind\", or(\"var\", \"let\", \"const\"))\n        .field(\"declarations\", [def(\"VariableDeclarator\")]);\n\n    def(\"VariableDeclarator\")\n        .bases(\"Node\")\n        .build(\"id\", \"init\")\n        .field(\"id\", def(\"Pattern\"))\n        .field(\"init\", or(def(\"Expression\"), null));\n\n    // TODO Are all Expressions really Patterns?\n    def(\"Expression\").bases(\"Node\", \"Pattern\");\n\n    def(\"ThisExpression\").bases(\"Expression\").build();\n\n    def(\"ArrayExpression\")\n        .bases(\"Expression\")\n        .build(\"elements\")\n        .field(\"elements\", [or(def(\"Expression\"), null)]);\n\n    def(\"ObjectExpression\")\n        .bases(\"Expression\")\n        .build(\"properties\")\n        .field(\"properties\", [def(\"Property\")]);\n\n    // TODO Not in the Mozilla Parser API, but used by Esprima.\n    def(\"Property\")\n        .bases(\"Node\") // Want to be able to visit Property Nodes.\n        .build(\"kind\", \"key\", \"value\")\n        .field(\"kind\", or(\"init\", \"get\", \"set\"))\n        .field(\"key\", or(def(\"Literal\"), def(\"Identifier\")))\n        .field(\"value\", def(\"Expression\"));\n\n    def(\"SequenceExpression\")\n        .bases(\"Expression\")\n        .build(\"expressions\")\n        .field(\"expressions\", [def(\"Expression\")]);\n\n    var UnaryOperator = or(\n        \"-\", \"+\", \"!\", \"~\",\n        \"typeof\", \"void\", \"delete\");\n\n    def(\"UnaryExpression\")\n        .bases(\"Expression\")\n        .build(\"operator\", \"argument\", \"prefix\")\n        .field(\"operator\", UnaryOperator)\n        .field(\"argument\", def(\"Expression\"))\n        // Esprima doesn't bother with this field, presumably because it's\n        // always true for unary operators.\n        .field(\"prefix\", Boolean, defaults[\"true\"]);\n\n    var BinaryOperator = or(\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">\", \">=\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\", \"*\", \"/\", \"%\",\n        \"&\", // TODO Missing from the Parser API.\n        \"|\", \"^\", \"in\",\n        \"instanceof\", \"..\");\n\n    def(\"BinaryExpression\")\n        .bases(\"Expression\")\n        .build(\"operator\", \"left\", \"right\")\n        .field(\"operator\", BinaryOperator)\n        .field(\"left\", def(\"Expression\"))\n        .field(\"right\", def(\"Expression\"));\n\n    var AssignmentOperator = or(\n        \"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\",\n        \"<<=\", \">>=\", \">>>=\",\n        \"|=\", \"^=\", \"&=\");\n\n    def(\"AssignmentExpression\")\n        .bases(\"Expression\")\n        .build(\"operator\", \"left\", \"right\")\n        .field(\"operator\", AssignmentOperator)\n        .field(\"left\", def(\"Pattern\"))\n        .field(\"right\", def(\"Expression\"));\n\n    var UpdateOperator = or(\"++\", \"--\");\n\n    def(\"UpdateExpression\")\n        .bases(\"Expression\")\n        .build(\"operator\", \"argument\", \"prefix\")\n        .field(\"operator\", UpdateOperator)\n        .field(\"argument\", def(\"Expression\"))\n        .field(\"prefix\", Boolean);\n\n    var LogicalOperator = or(\"||\", \"&&\");\n\n    def(\"LogicalExpression\")\n        .bases(\"Expression\")\n        .build(\"operator\", \"left\", \"right\")\n        .field(\"operator\", LogicalOperator)\n        .field(\"left\", def(\"Expression\"))\n        .field(\"right\", def(\"Expression\"));\n\n    def(\"ConditionalExpression\")\n        .bases(\"Expression\")\n        .build(\"test\", \"consequent\", \"alternate\")\n        .field(\"test\", def(\"Expression\"))\n        .field(\"consequent\", def(\"Expression\"))\n        .field(\"alternate\", def(\"Expression\"));\n\n    def(\"NewExpression\")\n        .bases(\"Expression\")\n        .build(\"callee\", \"arguments\")\n        .field(\"callee\", def(\"Expression\"))\n        // The Mozilla Parser API gives this type as [or(def(\"Expression\"),\n        // null)], but null values don't really make sense at the call site.\n        // TODO Report this nonsense.\n        .field(\"arguments\", [def(\"Expression\")]);\n\n    def(\"CallExpression\")\n        .bases(\"Expression\")\n        .build(\"callee\", \"arguments\")\n        .field(\"callee\", def(\"Expression\"))\n        // See comment for NewExpression above.\n        .field(\"arguments\", [def(\"Expression\")]);\n\n    def(\"MemberExpression\")\n        .bases(\"Expression\")\n        .build(\"object\", \"property\", \"computed\")\n        .field(\"object\", def(\"Expression\"))\n        .field(\"property\", or(def(\"Identifier\"), def(\"Expression\")))\n        .field(\"computed\", Boolean, function () {\n            var type = this.property.type;\n            if (type === 'Literal' ||\n                type === 'MemberExpression' ||\n                type === 'BinaryExpression') {\n                return true;\n            }\n            return false;\n        });\n\n    def(\"Pattern\").bases(\"Node\");\n\n    def(\"SwitchCase\")\n        .bases(\"Node\")\n        .build(\"test\", \"consequent\")\n        .field(\"test\", or(def(\"Expression\"), null))\n        .field(\"consequent\", [def(\"Statement\")]);\n\n    def(\"Identifier\")\n        // But aren't Expressions and Patterns already Nodes? TODO Report this.\n        .bases(\"Node\", \"Expression\", \"Pattern\")\n        .build(\"name\")\n        .field(\"name\", String);\n\n    def(\"Literal\")\n        // But aren't Expressions already Nodes? TODO Report this.\n        .bases(\"Node\", \"Expression\")\n        .build(\"value\")\n        .field(\"value\", or(String, Boolean, null, Number, RegExp))\n        .field(\"regex\", or({\n            pattern: String,\n            flags: String\n        }, null), function () {\n            if (this.value instanceof RegExp) {\n                var flags = \"\";\n\n                if (this.value.ignoreCase) flags += \"i\";\n                if (this.value.multiline) flags += \"m\";\n                if (this.value.global) flags += \"g\";\n\n                return {\n                    pattern: this.value.source,\n                    flags: flags\n                };\n            }\n\n            return null;\n        });\n\n    // Abstract (non-buildable) comment supertype. Not a Node.\n    def(\"Comment\")\n        .bases(\"Printable\")\n        .field(\"value\", String)\n        // A .leading comment comes before the node, whereas a .trailing\n        // comment comes after it. These two fields should not both be true,\n        // but they might both be false when the comment falls inside a node\n        // and the node has no children for the comment to lead or trail,\n        // e.g. { /*dangling*/ }.\n        .field(\"leading\", Boolean, defaults[\"true\"])\n        .field(\"trailing\", Boolean, defaults[\"false\"]);\n};","module.exports = function (fork) {\n    var exports = {};\n    var types = fork.use(require(\"../lib/types\"));\n    var Type = types.Type;\n    var builtin = types.builtInTypes;\n    var isNumber = builtin.number;\n\n    // An example of constructing a new type with arbitrary constraints from\n    // an existing type.\n    exports.geq = function (than) {\n        return new Type(function (value) {\n            return isNumber.check(value) && value >= than;\n        }, isNumber + \" >= \" + than);\n    };\n\n    // Default value-returning functions that may optionally be passed as a\n    // third argument to Def.prototype.field.\n    exports.defaults = {\n        // Functions were used because (among other reasons) that's the most\n        // elegant way to allow for the emptyArray one always to give a new\n        // array instance.\n        \"null\": function () { return null },\n        \"emptyArray\": function () { return [] },\n        \"false\": function () { return false },\n        \"true\": function () { return true },\n        \"undefined\": function () {}\n    };\n\n    var naiveIsPrimitive = Type.or(\n      builtin.string,\n      builtin.number,\n      builtin.boolean,\n      builtin.null,\n      builtin.undefined\n    );\n\n    exports.isPrimitive = new Type(function (value) {\n        if (value === null)\n            return true;\n        var type = typeof value;\n        return !(type === \"object\" ||\n        type === \"function\");\n    }, naiveIsPrimitive.toString());\n\n    return exports;\n};","module.exports = function (fork) {\n    fork.use(require(\"./core\"));\n    var types = fork.use(require(\"../lib/types\"));\n    var def = types.Type.def;\n    var or = types.Type.or;\n    var defaults = fork.use(require(\"../lib/shared\")).defaults;\n\n    def(\"Function\")\n      .field(\"generator\", Boolean, defaults[\"false\"])\n      .field(\"expression\", Boolean, defaults[\"false\"])\n      .field(\"defaults\", [or(def(\"Expression\"), null)], defaults.emptyArray)\n      // TODO This could be represented as a RestElement in .params.\n      .field(\"rest\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n\n    // The ESTree way of representing a ...rest parameter.\n    def(\"RestElement\")\n      .bases(\"Pattern\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Pattern\"));\n\n    def(\"SpreadElementPattern\")\n      .bases(\"Pattern\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Pattern\"));\n\n    def(\"FunctionDeclaration\")\n      .build(\"id\", \"params\", \"body\", \"generator\", \"expression\");\n\n    def(\"FunctionExpression\")\n      .build(\"id\", \"params\", \"body\", \"generator\", \"expression\");\n\n    // The Parser API calls this ArrowExpression, but Esprima and all other\n    // actual parsers use ArrowFunctionExpression.\n    def(\"ArrowFunctionExpression\")\n      .bases(\"Function\", \"Expression\")\n      .build(\"params\", \"body\", \"expression\")\n      // The forced null value here is compatible with the overridden\n      // definition of the \"id\" field in the Function interface.\n      .field(\"id\", null, defaults[\"null\"])\n      // Arrow function bodies are allowed to be expressions.\n      .field(\"body\", or(def(\"BlockStatement\"), def(\"Expression\")))\n      // The current spec forbids arrow generators, so I have taken the\n      // liberty of enforcing that. TODO Report this.\n      .field(\"generator\", false, defaults[\"false\"]);\n\n    def(\"YieldExpression\")\n      .bases(\"Expression\")\n      .build(\"argument\", \"delegate\")\n      .field(\"argument\", or(def(\"Expression\"), null))\n      .field(\"delegate\", Boolean, defaults[\"false\"]);\n\n    def(\"GeneratorExpression\")\n      .bases(\"Expression\")\n      .build(\"body\", \"blocks\", \"filter\")\n      .field(\"body\", def(\"Expression\"))\n      .field(\"blocks\", [def(\"ComprehensionBlock\")])\n      .field(\"filter\", or(def(\"Expression\"), null));\n\n    def(\"ComprehensionExpression\")\n      .bases(\"Expression\")\n      .build(\"body\", \"blocks\", \"filter\")\n      .field(\"body\", def(\"Expression\"))\n      .field(\"blocks\", [def(\"ComprehensionBlock\")])\n      .field(\"filter\", or(def(\"Expression\"), null));\n\n    def(\"ComprehensionBlock\")\n      .bases(\"Node\")\n      .build(\"left\", \"right\", \"each\")\n      .field(\"left\", def(\"Pattern\"))\n      .field(\"right\", def(\"Expression\"))\n      .field(\"each\", Boolean);\n\n    def(\"Property\")\n      .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n      .field(\"value\", or(def(\"Expression\"), def(\"Pattern\")))\n      .field(\"method\", Boolean, defaults[\"false\"])\n      .field(\"shorthand\", Boolean, defaults[\"false\"])\n      .field(\"computed\", Boolean, defaults[\"false\"]);\n\n    def(\"PropertyPattern\")\n      .bases(\"Pattern\")\n      .build(\"key\", \"pattern\")\n      .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n      .field(\"pattern\", def(\"Pattern\"))\n      .field(\"computed\", Boolean, defaults[\"false\"]);\n\n    def(\"ObjectPattern\")\n      .bases(\"Pattern\")\n      .build(\"properties\")\n      .field(\"properties\", [or(def(\"PropertyPattern\"), def(\"Property\"))]);\n\n    def(\"ArrayPattern\")\n      .bases(\"Pattern\")\n      .build(\"elements\")\n      .field(\"elements\", [or(def(\"Pattern\"), null)]);\n\n    def(\"MethodDefinition\")\n      .bases(\"Declaration\")\n      .build(\"kind\", \"key\", \"value\", \"static\")\n      .field(\"kind\", or(\"constructor\", \"method\", \"get\", \"set\"))\n      .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n      .field(\"value\", def(\"Function\"))\n      .field(\"computed\", Boolean, defaults[\"false\"])\n      .field(\"static\", Boolean, defaults[\"false\"]);\n\n    def(\"SpreadElement\")\n      .bases(\"Node\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Expression\"));\n\n    def(\"ArrayExpression\")\n      .field(\"elements\", [or(\n        def(\"Expression\"),\n        def(\"SpreadElement\"),\n        def(\"RestElement\"),\n        null\n      )]);\n\n    def(\"NewExpression\")\n      .field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n\n    def(\"CallExpression\")\n      .field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n\n    // Note: this node type is *not* an AssignmentExpression with a Pattern on\n    // the left-hand side! The existing AssignmentExpression type already\n    // supports destructuring assignments. AssignmentPattern nodes may appear\n    // wherever a Pattern is allowed, and the right-hand side represents a\n    // default value to be destructured against the left-hand side, if no\n    // value is otherwise provided. For example: default parameter values.\n    def(\"AssignmentPattern\")\n      .bases(\"Pattern\")\n      .build(\"left\", \"right\")\n      .field(\"left\", def(\"Pattern\"))\n      .field(\"right\", def(\"Expression\"));\n\n    var ClassBodyElement = or(\n      def(\"MethodDefinition\"),\n      def(\"VariableDeclarator\"),\n      def(\"ClassPropertyDefinition\"),\n      def(\"ClassProperty\")\n    );\n\n    def(\"ClassProperty\")\n      .bases(\"Declaration\")\n      .build(\"key\")\n      .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n      .field(\"computed\", Boolean, defaults[\"false\"]);\n\n    def(\"ClassPropertyDefinition\") // static property\n      .bases(\"Declaration\")\n      .build(\"definition\")\n      // Yes, Virginia, circular definitions are permitted.\n      .field(\"definition\", ClassBodyElement);\n\n    def(\"ClassBody\")\n      .bases(\"Declaration\")\n      .build(\"body\")\n      .field(\"body\", [ClassBodyElement]);\n\n    def(\"ClassDeclaration\")\n      .bases(\"Declaration\")\n      .build(\"id\", \"body\", \"superClass\")\n      .field(\"id\", or(def(\"Identifier\"), null))\n      .field(\"body\", def(\"ClassBody\"))\n      .field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n\n    def(\"ClassExpression\")\n      .bases(\"Expression\")\n      .build(\"id\", \"body\", \"superClass\")\n      .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"])\n      .field(\"body\", def(\"ClassBody\"))\n      .field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"])\n      .field(\"implements\", [def(\"ClassImplements\")], defaults.emptyArray);\n\n    def(\"ClassImplements\")\n      .bases(\"Node\")\n      .build(\"id\")\n      .field(\"id\", def(\"Identifier\"))\n      .field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n\n    // Specifier and ModuleSpecifier are abstract non-standard types\n    // introduced for definitional convenience.\n    def(\"Specifier\").bases(\"Node\");\n\n    // This supertype is shared/abused by both def/babel.js and\n    // def/esprima.js. In the future, it will be possible to load only one set\n    // of definitions appropriate for a given parser, but until then we must\n    // rely on default functions to reconcile the conflicting AST formats.\n    def(\"ModuleSpecifier\")\n      .bases(\"Specifier\")\n      // This local field is used by Babel/Acorn. It should not technically\n      // be optional in the Babel/Acorn AST format, but it must be optional\n      // in the Esprima AST format.\n      .field(\"local\", or(def(\"Identifier\"), null), defaults[\"null\"])\n      // The id and name fields are used by Esprima. The id field should not\n      // technically be optional in the Esprima AST format, but it must be\n      // optional in the Babel/Acorn AST format.\n      .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"])\n      .field(\"name\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n\n    def(\"TaggedTemplateExpression\")\n      .bases(\"Expression\")\n      .build(\"tag\", \"quasi\")\n      .field(\"tag\", def(\"Expression\"))\n      .field(\"quasi\", def(\"TemplateLiteral\"));\n\n    def(\"TemplateLiteral\")\n      .bases(\"Expression\")\n      .build(\"quasis\", \"expressions\")\n      .field(\"quasis\", [def(\"TemplateElement\")])\n      .field(\"expressions\", [def(\"Expression\")]);\n\n    def(\"TemplateElement\")\n      .bases(\"Node\")\n      .build(\"value\", \"tail\")\n      .field(\"value\", {\"cooked\": String, \"raw\": String})\n      .field(\"tail\", Boolean);\n};\n","module.exports = function (fork) {\n    fork.use(require('./es6'));\n\n    var types = fork.use(require(\"../lib/types\"));\n    var def = types.Type.def;\n    var or = types.Type.or;\n    var builtin = types.builtInTypes;\n    var defaults = fork.use(require(\"../lib/shared\")).defaults;\n\n    def(\"Function\")\n      .field(\"async\", Boolean, defaults[\"false\"]);\n\n    def(\"SpreadProperty\")\n      .bases(\"Node\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Expression\"));\n\n    def(\"ObjectExpression\")\n      .field(\"properties\", [or(def(\"Property\"), def(\"SpreadProperty\"))]);\n\n    def(\"SpreadPropertyPattern\")\n      .bases(\"Pattern\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Pattern\"));\n\n    def(\"ObjectPattern\")\n      .field(\"properties\", [or(\n        def(\"Property\"),\n        def(\"PropertyPattern\"),\n        def(\"SpreadPropertyPattern\")\n      )]);\n\n    def(\"AwaitExpression\")\n      .bases(\"Expression\")\n      .build(\"argument\", \"all\")\n      .field(\"argument\", or(def(\"Expression\"), null))\n      .field(\"all\", Boolean, defaults[\"false\"]);\n};","module.exports = function (fork) {\n    fork.use(require(\"./core\"));\n    var types = fork.use(require(\"../lib/types\"));\n    var def = types.Type.def;\n    var or = types.Type.or;\n    var shared = fork.use(require(\"../lib/shared\"));\n    var geq = shared.geq;\n    var defaults = shared.defaults;\n\n    def(\"Function\")\n        // SpiderMonkey allows expression closures: function(x) x+1\n        .field(\"body\", or(def(\"BlockStatement\"), def(\"Expression\")));\n\n    def(\"ForInStatement\")\n        .build(\"left\", \"right\", \"body\", \"each\")\n        .field(\"each\", Boolean, defaults[\"false\"]);\n\n    def(\"ForOfStatement\")\n        .bases(\"Statement\")\n        .build(\"left\", \"right\", \"body\")\n        .field(\"left\", or(\n            def(\"VariableDeclaration\"),\n            def(\"Expression\")))\n        .field(\"right\", def(\"Expression\"))\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"LetStatement\")\n        .bases(\"Statement\")\n        .build(\"head\", \"body\")\n        // TODO Deviating from the spec by reusing VariableDeclarator here.\n        .field(\"head\", [def(\"VariableDeclarator\")])\n        .field(\"body\", def(\"Statement\"));\n\n    def(\"LetExpression\")\n        .bases(\"Expression\")\n        .build(\"head\", \"body\")\n        // TODO Deviating from the spec by reusing VariableDeclarator here.\n        .field(\"head\", [def(\"VariableDeclarator\")])\n        .field(\"body\", def(\"Expression\"));\n\n    def(\"GraphExpression\")\n        .bases(\"Expression\")\n        .build(\"index\", \"expression\")\n        .field(\"index\", geq(0))\n        .field(\"expression\", def(\"Literal\"));\n\n    def(\"GraphIndexExpression\")\n        .bases(\"Expression\")\n        .build(\"index\")\n        .field(\"index\", geq(0));\n};","module.exports = function (fork) {\n    fork.use(require(\"./core\"));\n    var types = fork.use(require(\"../lib/types\"));\n    var def = types.Type.def;\n    var or = types.Type.or;\n\n    // Note that none of these types are buildable because the Mozilla Parser\n    // API doesn't specify any builder functions, and nobody uses E4X anymore.\n\n    def(\"XMLDefaultDeclaration\")\n        .bases(\"Declaration\")\n        .field(\"namespace\", def(\"Expression\"));\n\n    def(\"XMLAnyName\").bases(\"Expression\");\n\n    def(\"XMLQualifiedIdentifier\")\n        .bases(\"Expression\")\n        .field(\"left\", or(def(\"Identifier\"), def(\"XMLAnyName\")))\n        .field(\"right\", or(def(\"Identifier\"), def(\"Expression\")))\n        .field(\"computed\", Boolean);\n\n    def(\"XMLFunctionQualifiedIdentifier\")\n        .bases(\"Expression\")\n        .field(\"right\", or(def(\"Identifier\"), def(\"Expression\")))\n        .field(\"computed\", Boolean);\n\n    def(\"XMLAttributeSelector\")\n        .bases(\"Expression\")\n        .field(\"attribute\", def(\"Expression\"));\n\n    def(\"XMLFilterExpression\")\n        .bases(\"Expression\")\n        .field(\"left\", def(\"Expression\"))\n        .field(\"right\", def(\"Expression\"));\n\n    def(\"XMLElement\")\n        .bases(\"XML\", \"Expression\")\n        .field(\"contents\", [def(\"XML\")]);\n\n    def(\"XMLList\")\n        .bases(\"XML\", \"Expression\")\n        .field(\"contents\", [def(\"XML\")]);\n\n    def(\"XML\").bases(\"Node\");\n\n    def(\"XMLEscape\")\n        .bases(\"XML\")\n        .field(\"expression\", def(\"Expression\"));\n\n    def(\"XMLText\")\n        .bases(\"XML\")\n        .field(\"text\", String);\n\n    def(\"XMLStartTag\")\n        .bases(\"XML\")\n        .field(\"contents\", [def(\"XML\")]);\n\n    def(\"XMLEndTag\")\n        .bases(\"XML\")\n        .field(\"contents\", [def(\"XML\")]);\n\n    def(\"XMLPointTag\")\n        .bases(\"XML\")\n        .field(\"contents\", [def(\"XML\")]);\n\n    def(\"XMLName\")\n        .bases(\"XML\")\n        .field(\"contents\", or(String, [def(\"XML\")]));\n\n    def(\"XMLAttribute\")\n        .bases(\"XML\")\n        .field(\"value\", String);\n\n    def(\"XMLCdata\")\n        .bases(\"XML\")\n        .field(\"contents\", String);\n\n    def(\"XMLComment\")\n        .bases(\"XML\")\n        .field(\"contents\", String);\n\n    def(\"XMLProcessingInstruction\")\n        .bases(\"XML\")\n        .field(\"target\", String)\n        .field(\"contents\", or(String, null));\n};","module.exports = function (fork) {\n    fork.use(require(\"./es7\"));\n\n    var types = fork.use(require(\"../lib/types\"));\n    var def = types.Type.def;\n    var or = types.Type.or;\n    var defaults = fork.use(require(\"../lib/shared\")).defaults;\n\n    def(\"JSXAttribute\")\n      .bases(\"Node\")\n      .build(\"name\", \"value\")\n      .field(\"name\", or(def(\"JSXIdentifier\"), def(\"JSXNamespacedName\")))\n      .field(\"value\", or(\n        def(\"Literal\"), // attr=\"value\"\n        def(\"JSXExpressionContainer\"), // attr={value}\n        null // attr= or just attr\n      ), defaults[\"null\"]);\n\n    def(\"JSXIdentifier\")\n      .bases(\"Identifier\")\n      .build(\"name\")\n      .field(\"name\", String);\n\n    def(\"JSXNamespacedName\")\n      .bases(\"Node\")\n      .build(\"namespace\", \"name\")\n      .field(\"namespace\", def(\"JSXIdentifier\"))\n      .field(\"name\", def(\"JSXIdentifier\"));\n\n    def(\"JSXMemberExpression\")\n      .bases(\"MemberExpression\")\n      .build(\"object\", \"property\")\n      .field(\"object\", or(def(\"JSXIdentifier\"), def(\"JSXMemberExpression\")))\n      .field(\"property\", def(\"JSXIdentifier\"))\n      .field(\"computed\", Boolean, defaults.false);\n\n    var JSXElementName = or(\n      def(\"JSXIdentifier\"),\n      def(\"JSXNamespacedName\"),\n      def(\"JSXMemberExpression\")\n    );\n\n    def(\"JSXSpreadAttribute\")\n      .bases(\"Node\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Expression\"));\n\n    var JSXAttributes = [or(\n      def(\"JSXAttribute\"),\n      def(\"JSXSpreadAttribute\")\n    )];\n\n    def(\"JSXExpressionContainer\")\n      .bases(\"Expression\")\n      .build(\"expression\")\n      .field(\"expression\", def(\"Expression\"));\n\n    def(\"JSXElement\")\n      .bases(\"Expression\")\n      .build(\"openingElement\", \"closingElement\", \"children\")\n      .field(\"openingElement\", def(\"JSXOpeningElement\"))\n      .field(\"closingElement\", or(def(\"JSXClosingElement\"), null), defaults[\"null\"])\n      .field(\"children\", [or(\n        def(\"JSXElement\"),\n        def(\"JSXExpressionContainer\"),\n        def(\"JSXText\"),\n        def(\"Literal\") // TODO Esprima should return JSXText instead.\n      )], defaults.emptyArray)\n      .field(\"name\", JSXElementName, function () {\n          // Little-known fact: the `this` object inside a default function\n          // is none other than the partially-built object itself, and any\n          // fields initialized directly from builder function arguments\n          // (like openingElement, closingElement, and children) are\n          // guaranteed to be available.\n          return this.openingElement.name;\n      }, true) // hidden from traversal\n      .field(\"selfClosing\", Boolean, function () {\n          return this.openingElement.selfClosing;\n      }, true) // hidden from traversal\n      .field(\"attributes\", JSXAttributes, function () {\n          return this.openingElement.attributes;\n      }, true); // hidden from traversal\n\n    def(\"JSXOpeningElement\")\n      .bases(\"Node\") // TODO Does this make sense? Can't really be an JSXElement.\n      .build(\"name\", \"attributes\", \"selfClosing\")\n      .field(\"name\", JSXElementName)\n      .field(\"attributes\", JSXAttributes, defaults.emptyArray)\n      .field(\"selfClosing\", Boolean, defaults[\"false\"]);\n\n    def(\"JSXClosingElement\")\n      .bases(\"Node\") // TODO Same concern.\n      .build(\"name\")\n      .field(\"name\", JSXElementName);\n\n    def(\"JSXText\")\n      .bases(\"Literal\")\n      .build(\"value\")\n      .field(\"value\", String);\n\n    def(\"JSXEmptyExpression\").bases(\"Expression\").build();\n\n};","module.exports = function (fork) {\n    fork.use(require(\"./es7\"));\n\n    var types = fork.use(require(\"../lib/types\"));\n    var def = types.Type.def;\n    var or = types.Type.or;\n    var defaults = fork.use(require(\"../lib/shared\")).defaults;\n\n    // Type Annotations\n    def(\"Type\").bases(\"Node\");\n\n    def(\"AnyTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"EmptyTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"MixedTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"VoidTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"NumberTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"NumberLiteralTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"value\", \"raw\")\n      .field(\"value\", Number)\n      .field(\"raw\", String);\n\n    // Babylon 6 differs in AST from Flow\n    // same as NumberLiteralTypeAnnotation\n    def(\"NumericLiteralTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"value\", \"raw\")\n      .field(\"value\", Number)\n      .field(\"raw\", String);\n\n    def(\"StringTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"StringLiteralTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"value\", \"raw\")\n      .field(\"value\", String)\n      .field(\"raw\", String);\n\n    def(\"BooleanTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"BooleanLiteralTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"value\", \"raw\")\n      .field(\"value\", Boolean)\n      .field(\"raw\", String);\n\n    def(\"TypeAnnotation\")\n      .bases(\"Node\")\n      .build(\"typeAnnotation\")\n      .field(\"typeAnnotation\", def(\"Type\"));\n\n    def(\"NullableTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"typeAnnotation\")\n      .field(\"typeAnnotation\", def(\"Type\"));\n\n    def(\"NullLiteralTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"NullTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"ThisTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"ExistsTypeAnnotation\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"ExistentialTypeParam\")\n      .bases(\"Type\")\n      .build();\n\n    def(\"FunctionTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"params\", \"returnType\", \"rest\", \"typeParameters\")\n      .field(\"params\", [def(\"FunctionTypeParam\")])\n      .field(\"returnType\", def(\"Type\"))\n      .field(\"rest\", or(def(\"FunctionTypeParam\"), null))\n      .field(\"typeParameters\", or(def(\"TypeParameterDeclaration\"), null));\n\n    def(\"FunctionTypeParam\")\n      .bases(\"Node\")\n      .build(\"name\", \"typeAnnotation\", \"optional\")\n      .field(\"name\", def(\"Identifier\"))\n      .field(\"typeAnnotation\", def(\"Type\"))\n      .field(\"optional\", Boolean);\n\n    def(\"ArrayTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"elementType\")\n      .field(\"elementType\", def(\"Type\"));\n\n    def(\"ObjectTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"properties\", \"indexers\", \"callProperties\")\n      .field(\"properties\", [def(\"ObjectTypeProperty\")])\n      .field(\"indexers\", [def(\"ObjectTypeIndexer\")], defaults.emptyArray)\n      .field(\"callProperties\",\n        [def(\"ObjectTypeCallProperty\")],\n        defaults.emptyArray)\n      .field(\"exact\", Boolean, defaults[\"false\"]);\n\n    def(\"ObjectTypeProperty\")\n      .bases(\"Node\")\n      .build(\"key\", \"value\", \"optional\")\n      .field(\"key\", or(def(\"Literal\"), def(\"Identifier\")))\n      .field(\"value\", def(\"Type\"))\n      .field(\"optional\", Boolean)\n      .field(\"variance\",\n        or(\"plus\", \"minus\", null),\n        defaults[\"null\"]);\n\n    def(\"ObjectTypeIndexer\")\n      .bases(\"Node\")\n      .build(\"id\", \"key\", \"value\")\n      .field(\"id\", def(\"Identifier\"))\n      .field(\"key\", def(\"Type\"))\n      .field(\"value\", def(\"Type\"))\n      .field(\"variance\",\n        or(\"plus\", \"minus\", null),\n        defaults[\"null\"]);\n\n    def(\"ObjectTypeCallProperty\")\n      .bases(\"Node\")\n      .build(\"value\")\n      .field(\"value\", def(\"FunctionTypeAnnotation\"))\n      .field(\"static\", Boolean, defaults[\"false\"]);\n\n    def(\"QualifiedTypeIdentifier\")\n      .bases(\"Node\")\n      .build(\"qualification\", \"id\")\n      .field(\"qualification\",\n        or(def(\"Identifier\"),\n          def(\"QualifiedTypeIdentifier\")))\n      .field(\"id\", def(\"Identifier\"));\n\n    def(\"GenericTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"id\", \"typeParameters\")\n      .field(\"id\", or(def(\"Identifier\"), def(\"QualifiedTypeIdentifier\")))\n      .field(\"typeParameters\", or(def(\"TypeParameterInstantiation\"), null));\n\n    def(\"MemberTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"object\", \"property\")\n      .field(\"object\", def(\"Identifier\"))\n      .field(\"property\",\n        or(def(\"MemberTypeAnnotation\"),\n          def(\"GenericTypeAnnotation\")));\n\n    def(\"UnionTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"types\")\n      .field(\"types\", [def(\"Type\")]);\n\n    def(\"IntersectionTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"types\")\n      .field(\"types\", [def(\"Type\")]);\n\n    def(\"TypeofTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"argument\")\n      .field(\"argument\", def(\"Type\"));\n\n    def(\"Identifier\")\n      .field(\"typeAnnotation\", or(def(\"TypeAnnotation\"), null), defaults[\"null\"]);\n\n    def(\"TypeParameterDeclaration\")\n      .bases(\"Node\")\n      .build(\"params\")\n      .field(\"params\", [def(\"TypeParameter\")]);\n\n    def(\"TypeParameterInstantiation\")\n      .bases(\"Node\")\n      .build(\"params\")\n      .field(\"params\", [def(\"Type\")]);\n\n    def(\"TypeParameter\")\n      .bases(\"Type\")\n      .build(\"name\", \"variance\", \"bound\")\n      .field(\"name\", String)\n      .field(\"variance\",\n        or(\"plus\", \"minus\", null),\n        defaults[\"null\"])\n      .field(\"bound\",\n        or(def(\"TypeAnnotation\"), null),\n        defaults[\"null\"]);\n\n    def(\"Function\")\n      .field(\"returnType\",\n        or(def(\"TypeAnnotation\"), null),\n        defaults[\"null\"])\n      .field(\"typeParameters\",\n        or(def(\"TypeParameterDeclaration\"), null),\n        defaults[\"null\"]);\n\n    def(\"ClassProperty\")\n      .build(\"key\", \"value\", \"typeAnnotation\", \"static\")\n      .field(\"value\", or(def(\"Expression\"), null))\n      .field(\"typeAnnotation\", or(def(\"TypeAnnotation\"), null))\n      .field(\"static\", Boolean, defaults[\"false\"])\n      .field(\"variance\",\n        or(\"plus\", \"minus\", null),\n        defaults[\"null\"]);\n\n    def(\"ClassImplements\")\n      .field(\"typeParameters\",\n        or(def(\"TypeParameterInstantiation\"), null),\n        defaults[\"null\"]);\n\n    def(\"InterfaceDeclaration\")\n      .bases(\"Declaration\")\n      .build(\"id\", \"body\", \"extends\")\n      .field(\"id\", def(\"Identifier\"))\n      .field(\"typeParameters\",\n        or(def(\"TypeParameterDeclaration\"), null),\n        defaults[\"null\"])\n      .field(\"body\", def(\"ObjectTypeAnnotation\"))\n      .field(\"extends\", [def(\"InterfaceExtends\")]);\n\n    def(\"DeclareInterface\")\n      .bases(\"InterfaceDeclaration\")\n      .build(\"id\", \"body\", \"extends\");\n\n    def(\"InterfaceExtends\")\n      .bases(\"Node\")\n      .build(\"id\")\n      .field(\"id\", def(\"Identifier\"))\n      .field(\"typeParameters\", or(def(\"TypeParameterInstantiation\"), null));\n\n    def(\"TypeAlias\")\n      .bases(\"Declaration\")\n      .build(\"id\", \"typeParameters\", \"right\")\n      .field(\"id\", def(\"Identifier\"))\n      .field(\"typeParameters\", or(def(\"TypeParameterDeclaration\"), null))\n      .field(\"right\", def(\"Type\"));\n\n    def(\"DeclareTypeAlias\")\n      .bases(\"TypeAlias\")\n      .build(\"id\", \"typeParameters\", \"right\");\n\n    def(\"TypeCastExpression\")\n      .bases(\"Expression\")\n      .build(\"expression\", \"typeAnnotation\")\n      .field(\"expression\", def(\"Expression\"))\n      .field(\"typeAnnotation\", def(\"TypeAnnotation\"));\n\n    def(\"TupleTypeAnnotation\")\n      .bases(\"Type\")\n      .build(\"types\")\n      .field(\"types\", [def(\"Type\")]);\n\n    def(\"DeclareVariable\")\n      .bases(\"Statement\")\n      .build(\"id\")\n      .field(\"id\", def(\"Identifier\"));\n\n    def(\"DeclareFunction\")\n      .bases(\"Statement\")\n      .build(\"id\")\n      .field(\"id\", def(\"Identifier\"));\n\n    def(\"DeclareClass\")\n      .bases(\"InterfaceDeclaration\")\n      .build(\"id\");\n\n    def(\"DeclareModule\")\n      .bases(\"Statement\")\n      .build(\"id\", \"body\")\n      .field(\"id\", or(def(\"Identifier\"), def(\"Literal\")))\n      .field(\"body\", def(\"BlockStatement\"));\n\n    def(\"DeclareModuleExports\")\n      .bases(\"Statement\")\n      .build(\"typeAnnotation\")\n      .field(\"typeAnnotation\", def(\"Type\"));\n\n    def(\"DeclareExportDeclaration\")\n      .bases(\"Declaration\")\n      .build(\"default\", \"declaration\", \"specifiers\", \"source\")\n      .field(\"default\", Boolean)\n      .field(\"declaration\", or(\n        def(\"DeclareVariable\"),\n        def(\"DeclareFunction\"),\n        def(\"DeclareClass\"),\n        def(\"Type\"), // Implies default.\n        null\n      ))\n      .field(\"specifiers\", [or(\n        def(\"ExportSpecifier\"),\n        def(\"ExportBatchSpecifier\")\n      )], defaults.emptyArray)\n      .field(\"source\", or(\n        def(\"Literal\"),\n        null\n      ), defaults[\"null\"]);\n\n    def(\"DeclareExportAllDeclaration\")\n      .bases(\"Declaration\")\n      .build(\"source\")\n      .field(\"source\", or(\n        def(\"Literal\"),\n        null\n      ), defaults[\"null\"]);\n};\n","module.exports = function (fork) {\n    fork.use(require(\"./es7\"));\n\n    var types = fork.use(require(\"../lib/types\"));\n    var defaults = fork.use(require(\"../lib/shared\")).defaults;\n    var def = types.Type.def;\n    var or = types.Type.or;\n\n    def(\"VariableDeclaration\")\n      .field(\"declarations\", [or(\n        def(\"VariableDeclarator\"),\n        def(\"Identifier\") // Esprima deviation.\n      )]);\n\n    def(\"Property\")\n      .field(\"value\", or(\n        def(\"Expression\"),\n        def(\"Pattern\") // Esprima deviation.\n      ));\n\n    def(\"ArrayPattern\")\n      .field(\"elements\", [or(\n        def(\"Pattern\"),\n        def(\"SpreadElement\"),\n        null\n      )]);\n\n    def(\"ObjectPattern\")\n      .field(\"properties\", [or(\n        def(\"Property\"),\n        def(\"PropertyPattern\"),\n        def(\"SpreadPropertyPattern\"),\n        def(\"SpreadProperty\") // Used by Esprima.\n      )]);\n\n// Like ModuleSpecifier, except type:\"ExportSpecifier\" and buildable.\n// export {<id [as name]>} [from ...];\n    def(\"ExportSpecifier\")\n      .bases(\"ModuleSpecifier\")\n      .build(\"id\", \"name\");\n\n// export <*> from ...;\n    def(\"ExportBatchSpecifier\")\n      .bases(\"Specifier\")\n      .build();\n\n// Like ModuleSpecifier, except type:\"ImportSpecifier\" and buildable.\n// import {<id [as name]>} from ...;\n    def(\"ImportSpecifier\")\n      .bases(\"ModuleSpecifier\")\n      .build(\"id\", \"name\");\n\n// import <* as id> from ...;\n    def(\"ImportNamespaceSpecifier\")\n      .bases(\"ModuleSpecifier\")\n      .build(\"id\");\n\n// import <id> from ...;\n    def(\"ImportDefaultSpecifier\")\n      .bases(\"ModuleSpecifier\")\n      .build(\"id\");\n\n    def(\"ExportDeclaration\")\n      .bases(\"Declaration\")\n      .build(\"default\", \"declaration\", \"specifiers\", \"source\")\n      .field(\"default\", Boolean)\n      .field(\"declaration\", or(\n        def(\"Declaration\"),\n        def(\"Expression\"), // Implies default.\n        null\n      ))\n      .field(\"specifiers\", [or(\n        def(\"ExportSpecifier\"),\n        def(\"ExportBatchSpecifier\")\n      )], defaults.emptyArray)\n      .field(\"source\", or(\n        def(\"Literal\"),\n        null\n      ), defaults[\"null\"]);\n\n    def(\"ImportDeclaration\")\n      .bases(\"Declaration\")\n      .build(\"specifiers\", \"source\", \"importKind\")\n      .field(\"specifiers\", [or(\n        def(\"ImportSpecifier\"),\n        def(\"ImportNamespaceSpecifier\"),\n        def(\"ImportDefaultSpecifier\")\n      )], defaults.emptyArray)\n      .field(\"source\", def(\"Literal\"))\n      .field(\"importKind\", or(\n        \"value\",\n        \"type\"\n      ), function() {\n        return \"value\";\n      });\n\n    def(\"Block\")\n      .bases(\"Comment\")\n      .build(\"value\", /*optional:*/ \"leading\", \"trailing\");\n\n    def(\"Line\")\n      .bases(\"Comment\")\n      .build(\"value\", /*optional:*/ \"leading\", \"trailing\");\n};","module.exports = function (fork) {\n    fork.use(require(\"./es7\"));\n\n    var types = fork.use(require(\"../lib/types\"));\n    var defaults = fork.use(require(\"../lib/shared\")).defaults;\n    var def = types.Type.def;\n    var or = types.Type.or;\n\n    def(\"Noop\")\n        .bases(\"Node\")\n        .build();\n\n    def(\"DoExpression\")\n        .bases(\"Expression\")\n        .build(\"body\")\n        .field(\"body\", [def(\"Statement\")]);\n\n    def(\"Super\")\n        .bases(\"Expression\")\n        .build();\n\n    def(\"BindExpression\")\n        .bases(\"Expression\")\n        .build(\"object\", \"callee\")\n        .field(\"object\", or(def(\"Expression\"), null))\n        .field(\"callee\", def(\"Expression\"));\n\n    def(\"Decorator\")\n        .bases(\"Node\")\n        .build(\"expression\")\n        .field(\"expression\", def(\"Expression\"));\n\n    def(\"Property\")\n        .field(\"decorators\",\n            or([def(\"Decorator\")], null),\n            defaults[\"null\"]);\n\n    def(\"MethodDefinition\")\n        .field(\"decorators\",\n            or([def(\"Decorator\")], null),\n            defaults[\"null\"]);\n\n    def(\"MetaProperty\")\n        .bases(\"Expression\")\n        .build(\"meta\", \"property\")\n        .field(\"meta\", def(\"Identifier\"))\n        .field(\"property\", def(\"Identifier\"));\n\n    def(\"ParenthesizedExpression\")\n        .bases(\"Expression\")\n        .build(\"expression\")\n        .field(\"expression\", def(\"Expression\"));\n\n    def(\"ImportSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"imported\", \"local\")\n        .field(\"imported\", def(\"Identifier\"));\n\n    def(\"ImportDefaultSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"local\");\n\n    def(\"ImportNamespaceSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"local\");\n\n    def(\"ExportDefaultDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"declaration\")\n        .field(\"declaration\", or(def(\"Declaration\"), def(\"Expression\")));\n\n    def(\"ExportNamedDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"declaration\", \"specifiers\", \"source\")\n        .field(\"declaration\", or(def(\"Declaration\"), null))\n        .field(\"specifiers\", [def(\"ExportSpecifier\")], defaults.emptyArray)\n        .field(\"source\", or(def(\"Literal\"), null), defaults[\"null\"]);\n\n    def(\"ExportSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"local\", \"exported\")\n        .field(\"exported\", def(\"Identifier\"));\n\n    def(\"ExportNamespaceSpecifier\")\n        .bases(\"Specifier\")\n        .build(\"exported\")\n        .field(\"exported\", def(\"Identifier\"));\n\n    def(\"ExportDefaultSpecifier\")\n        .bases(\"Specifier\")\n        .build(\"exported\")\n        .field(\"exported\", def(\"Identifier\"));\n\n    def(\"ExportAllDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"exported\", \"source\")\n        .field(\"exported\", or(def(\"Identifier\"), null))\n        .field(\"source\", def(\"Literal\"));\n\n    def(\"CommentBlock\")\n        .bases(\"Comment\")\n        .build(\"value\", /*optional:*/ \"leading\", \"trailing\");\n\n    def(\"CommentLine\")\n        .bases(\"Comment\")\n        .build(\"value\", /*optional:*/ \"leading\", \"trailing\");\n};","module.exports = function (fork) {\n  fork.use(require(\"./babel\"));\n  fork.use(require(\"./flow\"));\n\n  // var types = fork.types;\n  var types = fork.use(require(\"../lib/types\"));\n  // var defaults = fork.shared.defaults;\n  var defaults = fork.use(require(\"../lib/shared\")).defaults;\n  var def = types.Type.def;\n  var or = types.Type.or;\n\n  def(\"Directive\")\n    .bases(\"Node\")\n    .build(\"value\")\n    .field(\"value\", def(\"DirectiveLiteral\"));\n\n  def(\"DirectiveLiteral\")\n    .bases(\"Node\", \"Expression\")\n    .build(\"value\")\n    .field(\"value\", String, defaults[\"use strict\"]);\n\n  def(\"BlockStatement\")\n    .bases(\"Statement\")\n    .build(\"body\")\n    .field(\"body\", [def(\"Statement\")])\n    .field(\"directives\", [def(\"Directive\")], defaults.emptyArray);\n\n  def(\"Program\")\n    .bases(\"Node\")\n    .build(\"body\")\n    .field(\"body\", [def(\"Statement\")])\n    .field(\"directives\", [def(\"Directive\")], defaults.emptyArray);\n\n  // Split Literal\n  def(\"StringLiteral\")\n    .bases(\"Literal\")\n    .build(\"value\")\n    .field(\"value\", String);\n\n  def(\"NumericLiteral\")\n    .bases(\"Literal\")\n    .build(\"value\")\n    .field(\"value\", Number);\n\n  def(\"NullLiteral\")\n    .bases(\"Literal\")\n    .build();\n\n  def(\"BooleanLiteral\")\n    .bases(\"Literal\")\n    .build(\"value\")\n    .field(\"value\", Boolean);\n\n  def(\"RegExpLiteral\")\n    .bases(\"Literal\")\n    .build(\"pattern\", \"flags\")\n    .field(\"pattern\", String)\n    .field(\"flags\", String);\n\n  var ObjectExpressionProperty = or(\n    def(\"Property\"),\n    def(\"ObjectMethod\"),\n    def(\"ObjectProperty\"),\n    def(\"SpreadProperty\")\n  );\n\n  // Split Property -> ObjectProperty and ObjectMethod\n  def(\"ObjectExpression\")\n    .bases(\"Expression\")\n    .build(\"properties\")\n    .field(\"properties\", [ObjectExpressionProperty]);\n\n  // ObjectMethod hoist .value properties to own properties\n  def(\"ObjectMethod\")\n    .bases(\"Node\", \"Function\")\n    .build(\"kind\", \"key\", \"params\", \"body\", \"computed\")\n    .field(\"kind\", or(\"method\", \"get\", \"set\"))\n    .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n    .field(\"params\", [def(\"Pattern\")])\n    .field(\"body\", def(\"BlockStatement\"))\n    .field(\"computed\", Boolean, defaults[\"false\"])\n    .field(\"generator\", Boolean, defaults[\"false\"])\n    .field(\"async\", Boolean, defaults[\"false\"])\n    .field(\"decorators\",\n           or([def(\"Decorator\")], null),\n           defaults[\"null\"]);\n\n  def(\"ObjectProperty\")\n    .bases(\"Node\")\n    .build(\"key\", \"value\")\n    .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n    .field(\"value\", or(def(\"Expression\"), def(\"Pattern\")))\n    .field(\"computed\", Boolean, defaults[\"false\"]);\n\n  var ClassBodyElement = or(\n    def(\"MethodDefinition\"),\n    def(\"VariableDeclarator\"),\n    def(\"ClassPropertyDefinition\"),\n    def(\"ClassProperty\"),\n    def(\"ClassMethod\")\n  );\n\n  // MethodDefinition -> ClassMethod\n  def(\"ClassBody\")\n    .bases(\"Declaration\")\n    .build(\"body\")\n    .field(\"body\", [ClassBodyElement]);\n\n  def(\"ClassMethod\")\n    .bases(\"Declaration\", \"Function\")\n    .build(\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\")\n    .field(\"kind\", or(\"get\", \"set\", \"method\", \"constructor\"))\n    .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n    .field(\"params\", [def(\"Pattern\")])\n    .field(\"body\", def(\"BlockStatement\"))\n    .field(\"computed\", Boolean, defaults[\"false\"])\n    .field(\"static\", Boolean, defaults[\"false\"])\n    .field(\"generator\", Boolean, defaults[\"false\"])\n    .field(\"async\", Boolean, defaults[\"false\"])\n    .field(\"decorators\",\n           or([def(\"Decorator\")], null),\n           defaults[\"null\"]);\n\n  var ObjectPatternProperty = or(\n    def(\"Property\"),\n    def(\"PropertyPattern\"),\n    def(\"SpreadPropertyPattern\"),\n    def(\"SpreadProperty\"), // Used by Esprima\n    def(\"ObjectProperty\"), // Babel 6\n    def(\"RestProperty\") // Babel 6\n  );\n\n  // Split into RestProperty and SpreadProperty\n  def(\"ObjectPattern\")\n    .bases(\"Pattern\")\n    .build(\"properties\")\n    .field(\"properties\", [ObjectPatternProperty])\n    .field(\"decorators\",\n           or([def(\"Decorator\")], null),\n           defaults[\"null\"]);\n\n  def(\"SpreadProperty\")\n    .bases(\"Node\")\n    .build(\"argument\")\n    .field(\"argument\", def(\"Expression\"));\n\n  def(\"RestProperty\")\n    .bases(\"Node\")\n    .build(\"argument\")\n    .field(\"argument\", def(\"Expression\"));\n\n  def(\"ForAwaitStatement\")\n    .bases(\"Statement\")\n    .build(\"left\", \"right\", \"body\")\n    .field(\"left\", or(\n      def(\"VariableDeclaration\"),\n      def(\"Expression\")))\n    .field(\"right\", def(\"Expression\"))\n    .field(\"body\", def(\"Statement\"));\n\n  // The callee node of a dynamic import(...) expression.\n  def(\"Import\")\n    .bases(\"Expression\")\n    .build();\n};\n"]}