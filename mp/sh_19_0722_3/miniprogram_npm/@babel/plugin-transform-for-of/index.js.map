{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose,\n    assumeArray\n  } = options;\n\n  if (loose === true && assumeArray === true) {\n    throw new Error(`The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`);\n  }\n\n  if (assumeArray) {\n    return {\n      name: \"transform-for-of\",\n      visitor: {\n        ForOfStatement(path) {\n          const {\n            scope\n          } = path;\n          const {\n            left,\n            right,\n            body,\n            await: isAwait\n          } = path.node;\n\n          if (isAwait) {\n            return;\n          }\n\n          const i = scope.generateUidIdentifier(\"i\");\n          let array = scope.maybeGenerateMemoised(right, true);\n          const inits = [_core.types.variableDeclarator(i, _core.types.numericLiteral(0))];\n\n          if (array) {\n            inits.push(_core.types.variableDeclarator(array, right));\n          } else {\n            array = right;\n          }\n\n          const item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), true);\n\n          let assignment;\n\n          if (_core.types.isVariableDeclaration(left)) {\n            assignment = left;\n            assignment.declarations[0].init = item;\n          } else {\n            assignment = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, item));\n          }\n\n          const block = _core.types.toBlock(body);\n\n          block.body.unshift(assignment);\n          path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration(\"let\", inits), _core.types.binaryExpression(\"<\", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier(\"length\"))), _core.types.updateExpression(\"++\", _core.types.cloneNode(i)), block));\n        }\n\n      }\n    };\n  }\n\n  const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;\n  const buildForOfArray = (0, _core.template)(`\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  `);\n  const buildForOfLoose = (0, _core.template)(`\n    for (var LOOP_OBJECT = OBJECT,\n             IS_ARRAY = Array.isArray(LOOP_OBJECT),\n             INDEX = 0,\n             LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n      INTERMEDIATE;\n      if (IS_ARRAY) {\n        if (INDEX >= LOOP_OBJECT.length) break;\n        ID = LOOP_OBJECT[INDEX++];\n      } else {\n        INDEX = LOOP_OBJECT.next();\n        if (INDEX.done) break;\n        ID = INDEX.value;\n      }\n    }\n  `);\n  const buildForOf = (0, _core.template)(`\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY = undefined;\n    try {\n      for (\n        var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n        !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n        ITERATOR_COMPLETION = true\n      ) {}\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  `);\n\n  function _ForOfStatementArray(path) {\n    const {\n      node,\n      scope\n    } = path;\n    const right = scope.generateUidIdentifierBasedOnNode(node.right, \"arr\");\n    const iterationKey = scope.generateUidIdentifier(\"i\");\n    let loop = buildForOfArray({\n      BODY: node.body,\n      KEY: iterationKey,\n      NAME: right,\n      ARR: node.right\n    });\n\n    _core.types.inherits(loop, node);\n\n    _core.types.ensureBlock(loop);\n\n    const iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), true);\n\n    const left = node.left;\n\n    if (_core.types.isVariableDeclaration(left)) {\n      left.declarations[0].init = iterationValue;\n      loop.body.body.unshift(left);\n    } else {\n      loop.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, iterationValue)));\n    }\n\n    if (path.parentPath.isLabeledStatement()) {\n      loop = _core.types.labeledStatement(path.parentPath.node.label, loop);\n    }\n\n    return [loop];\n  }\n\n  function replaceWithArray(path) {\n    if (path.parentPath.isLabeledStatement()) {\n      path.parentPath.replaceWithMultiple(_ForOfStatementArray(path));\n    } else {\n      path.replaceWithMultiple(_ForOfStatementArray(path));\n    }\n  }\n\n  return {\n    name: \"transform-for-of\",\n    visitor: {\n      ForOfStatement(path, state) {\n        const right = path.get(\"right\");\n\n        if (right.isArrayExpression() || right.isGenericType(\"Array\") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) {\n          replaceWithArray(path);\n          return;\n        }\n\n        const {\n          node\n        } = path;\n        const build = pushComputedProps(path, state);\n        const declar = build.declar;\n        const loop = build.loop;\n        const block = loop.body;\n        path.ensureBlock();\n\n        if (declar) {\n          block.body.push(declar);\n        }\n\n        block.body = block.body.concat(node.body.body);\n\n        _core.types.inherits(loop, node);\n\n        _core.types.inherits(loop.body, node.body);\n\n        if (build.replaceParent) {\n          path.parentPath.replaceWithMultiple(build.node);\n          path.remove();\n        } else {\n          path.replaceWithMultiple(build.node);\n        }\n      }\n\n    }\n  };\n\n  function pushComputedPropsLoose(path, file) {\n    const {\n      node,\n      scope,\n      parent\n    } = path;\n    const {\n      left\n    } = node;\n    let declar, id, intermediate;\n\n    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {\n      id = left;\n      intermediate = null;\n    } else if (_core.types.isVariableDeclaration(left)) {\n      id = scope.generateUidIdentifier(\"ref\");\n      declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, _core.types.identifier(id.name))]);\n      intermediate = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(id.name))]);\n    } else {\n      throw file.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);\n    }\n\n    const iteratorKey = scope.generateUidIdentifier(\"iterator\");\n    const isArrayKey = scope.generateUidIdentifier(\"isArray\");\n    const loop = buildForOfLoose({\n      LOOP_OBJECT: iteratorKey,\n      IS_ARRAY: isArrayKey,\n      OBJECT: node.right,\n      INDEX: scope.generateUidIdentifier(\"i\"),\n      ID: id,\n      INTERMEDIATE: intermediate\n    });\n\n    const isLabeledParent = _core.types.isLabeledStatement(parent);\n\n    let labeled;\n\n    if (isLabeledParent) {\n      labeled = _core.types.labeledStatement(parent.label, loop);\n    }\n\n    return {\n      replaceParent: isLabeledParent,\n      declar: declar,\n      node: labeled || loop,\n      loop: loop\n    };\n  }\n\n  function pushComputedPropsSpec(path, file) {\n    const {\n      node,\n      scope,\n      parent\n    } = path;\n    const left = node.left;\n    let declar;\n    const stepKey = scope.generateUid(\"step\");\n\n    const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier(\"value\"));\n\n    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {\n      declar = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, stepValue));\n    } else if (_core.types.isVariableDeclaration(left)) {\n      declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);\n    } else {\n      throw file.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);\n    }\n\n    const template = buildForOf({\n      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n      ITERATOR_COMPLETION: scope.generateUidIdentifier(\"iteratorNormalCompletion\"),\n      ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n      ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n      STEP_KEY: _core.types.identifier(stepKey),\n      OBJECT: node.right\n    });\n\n    const isLabeledParent = _core.types.isLabeledStatement(parent);\n\n    const tryBody = template[3].block.body;\n    const loop = tryBody[0];\n\n    if (isLabeledParent) {\n      tryBody[0] = _core.types.labeledStatement(parent.label, loop);\n    }\n\n    return {\n      replaceParent: isLabeledParent,\n      declar: declar,\n      loop: loop,\n      node: template\n    };\n  }\n});\n\nexports.default = _default;"]}