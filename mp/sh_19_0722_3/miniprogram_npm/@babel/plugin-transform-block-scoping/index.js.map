{"version":3,"sources":["index.js","tdz.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _tdz = require(\"./tdz\");\n\nvar _values = _interopRequireDefault(require(\"lodash/values\"));\n\nvar _extend = _interopRequireDefault(require(\"lodash/extend\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DONE = new WeakSet();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    throwIfClosureRequired = false,\n    tdz: tdzEnabled = false\n  } = opts;\n\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n    visitor: {\n      VariableDeclaration(path) {\n        const {\n          node,\n          parent,\n          scope\n        } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        if (node._tdzThis) {\n          const nodes = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n\n            const assign = _core.types.assignmentExpression(\"=\", decl.id, decl.init || scope.buildUndefinedNode());\n\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(_core.types.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(path, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        const blockScoping = new BlockScoping(null, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(path, state) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);\n          blockScoping.run();\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;\n\nfunction ignoreBlock(path) {\n  return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = (0, _core.template)(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node) {\n  if (!_core.types.isVariableDeclaration(node)) return false;\n  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) return true;\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\nfunction isInLoop(path) {\n  const loopOrFunctionParent = path.find(path => path.isLoop() || path.isFunction());\n  return loopOrFunctionParent && loopOrFunctionParent.isLoop();\n}\n\nfunction convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent = false) {\n  if (!node) {\n    node = path.node;\n  }\n\n  if (isInLoop(path) && !_core.types.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  node[_core.types.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node) {\n  return _core.types.isVariableDeclaration(node, {\n    kind: \"var\"\n  }) && !isBlockScoped(node);\n}\n\nconst letReferenceBlockVisitor = _core.traverse.visitors.merge([{\n  Loop: {\n    enter(path, state) {\n      state.loopDepth++;\n    },\n\n    exit(path, state) {\n      state.loopDepth--;\n    }\n\n  },\n\n  Function(path, state) {\n    if (state.loopDepth > 0) {\n      path.traverse(letReferenceFunctionVisitor, state);\n    } else {\n      path.traverse(_tdz.visitor, state);\n    }\n\n    return path.skip();\n  }\n\n}, _tdz.visitor]);\n\nconst letReferenceFunctionVisitor = _core.traverse.visitors.merge([{\n  ReferencedIdentifier(path, state) {\n    const ref = state.letReferences[path.node.name];\n    if (!ref) return;\n    const localBinding = path.scope.getBindingIdentifier(path.node.name);\n    if (localBinding && localBinding !== ref) return;\n    state.closurify = true;\n  }\n\n}, _tdz.visitor]);\n\nconst hoistVarDeclarationsVisitor = {\n  enter(path, self) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (path.isForStatement()) {\n      if (isVar(node.init, node)) {\n        const nodes = self.pushDeclar(node.init);\n\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = _core.types.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isFor()) {\n      if (isVar(node.left, node)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(node, parent)) {\n      path.replaceWithMultiple(self.pushDeclar(node).map(expr => _core.types.expressionStatement(expr)));\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  }\n\n};\nconst loopLabelVisitor = {\n  LabeledStatement({\n    node\n  }, state) {\n    state.innerLabels.push(node.label.name);\n  }\n\n};\nconst continuationVisitor = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (state.outsideReferences[name] !== path.scope.getBindingIdentifier(name)) {\n          continue;\n        }\n\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  }\n\n};\n\nfunction loopNodeTo(node) {\n  if (_core.types.isBreakStatement(node)) {\n    return \"break\";\n  } else if (_core.types.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(path, state) {\n    const {\n      node,\n      scope\n    } = path;\n    if (node[this.LOOP_IGNORE]) return;\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (node.label) {\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        if (state.ignoreLabeless) return;\n        if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map[loopText] = node;\n      replace = _core.types.stringLiteral(loopText);\n    }\n\n    if (path.isReturnStatement()) {\n      state.hasReturn = true;\n      replace = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"v\"), node.argument || scope.buildUndefinedNode())]);\n    }\n\n    if (replace) {\n      replace = _core.types.returnStatement(replace);\n      replace[this.LOOP_IGNORE] = true;\n      path.skip();\n      path.replaceWith(_core.types.inherits(replace, node));\n    }\n  }\n\n};\n\nclass BlockScoping {\n  constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n    this.outsideLetReferences = Object.create(null);\n    this.hasLetReferences = false;\n    this.letReferences = Object.create(null);\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n    const needsClosure = this.getLetReferences();\n    this.checkConstants();\n\n    if (_core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !_core.types.isLabeledStatement(this.loopParent)) {\n      return _core.types.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const scope = this.scope;\n    const state = this.state;\n\n    for (const name of Object.keys(scope.bindings)) {\n      const binding = scope.bindings[name];\n      if (binding.kind !== \"const\") continue;\n\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n\n        const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);\n\n        if (violation.isAssignmentExpression()) {\n          violation.get(\"right\").replaceWith(_core.types.sequenceExpression([throwNode, violation.get(\"right\").node]));\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(_core.types.sequenceExpression([throwNode, violation.node]));\n        } else if (violation.isForXStatement()) {\n          violation.ensureBlock();\n          violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure) {\n    const blockScope = this.blockPath.scope;\n    const parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of Object.keys(letRefs)) {\n      const ref = letRefs[key];\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    for (const key of Object.keys(letRefs)) {\n      const ref = letRefs[key];\n\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        if (scope.hasOwnBinding(key)) {\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of Object.keys(outsideLetRefs)) {\n      const ref = letRefs[key];\n\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n    }\n\n    const block = this.block;\n    const outsideRefs = this.outsideLetReferences;\n\n    if (this.loop) {\n      for (const name of Object.keys(outsideRefs)) {\n        const id = outsideRefs[name];\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          delete outsideRefs[id.name];\n          delete this.letReferences[id.name];\n          this.scope.rename(id.name);\n          this.letReferences[id.name] = id;\n          outsideRefs[id.name] = id;\n        }\n      }\n    }\n\n    this.has = this.checkLoop();\n    this.hoistVarDeclarations();\n    const args = (0, _values.default)(outsideRefs).map(id => _core.types.cloneNode(id));\n    const params = args.map(id => _core.types.cloneNode(id));\n    const isSwitch = this.blockPath.isSwitchStatement();\n\n    const fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [block] : block.body));\n\n    this.addContinuations(fn);\n\n    let call = _core.types.callExpression(_core.types.nullLiteral(), args);\n\n    let basePath = \".callee\";\n\n    const hasYield = _core.traverse.hasType(fn.body, \"YieldExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasYield) {\n      fn.generator = true;\n      call = _core.types.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    const hasAsync = _core.traverse.hasType(fn.body, \"AwaitExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasAsync) {\n      fn.async = true;\n      call = _core.types.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n      this.body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(ret), call)]));\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n      this.buildHas(ret);\n    } else {\n      this.body.push(_core.types.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath;\n\n    if (isSwitch) {\n      const {\n        parentPath,\n        listKey,\n        key\n      } = this.blockPath;\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[key + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath);\n    let fnPath;\n\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(loopId), fn)]));\n      placeholder.replaceWith(_core.types.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  addContinuations(fn) {\n    const state = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences\n    };\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = _core.types.identifier(newParamName);\n      this.scope.rename(paramName, newParamName, fn);\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n      });\n      fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n    let declarators = [];\n\n    if (this.loop) {\n      const init = this.loop.left || this.loop.init;\n\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n        (0, _extend.default)(this.outsideLetReferences, _core.types.getBindingIdentifiers(init));\n      }\n    }\n\n    const addDeclarationsFromChild = (path, node) => {\n      node = node || path.node;\n\n      if (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(path, node, block, this.scope);\n        }\n\n        declarators = declarators.concat(node.declarations || node);\n      }\n\n      if (_core.types.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.body) {\n      const declarPaths = this.blockPath.get(\"body\");\n\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i]);\n      }\n    }\n\n    if (block.cases) {\n      const declarPaths = this.blockPath.get(\"cases\");\n\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    }\n\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n\n      const keys = _core.types.getBindingIdentifiers(declar, false, true);\n\n      (0, _extend.default)(this.letReferences, keys);\n      this.hasLetReferences = true;\n    }\n\n    if (!this.hasLetReferences) return;\n    const state = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name)\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n    return state.closurify;\n  }\n\n  checkLoop() {\n    const state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: {},\n      LOOP_IGNORE: Symbol()\n    };\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n    return state;\n  }\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  pushDeclar(node) {\n    const declars = [];\n\n    const names = _core.types.getBindingIdentifiers(node);\n\n    for (const name of Object.keys(names)) {\n      declars.push(_core.types.variableDeclarator(names[name]));\n    }\n\n    this.body.push(_core.types.variableDeclaration(node.kind, declars));\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));\n\n      replace.push(_core.types.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret) {\n    const body = this.body;\n    let retCheck;\n    const has = this.has;\n    const cases = [];\n\n    if (has.hasReturn) {\n      retCheck = buildRetCheck({\n        RETURN: _core.types.identifier(ret)\n      });\n    }\n\n    if (has.hasBreakContinue) {\n      for (const key of Object.keys(has.map)) {\n        cases.push(_core.types.switchCase(_core.types.stringLiteral(key), [has.map[key]]));\n      }\n\n      if (has.hasReturn) {\n        cases.push(_core.types.switchCase(null, [retCheck]));\n      }\n\n      if (cases.length === 1) {\n        const single = cases[0];\n        body.push(_core.types.ifStatement(_core.types.binaryExpression(\"===\", _core.types.identifier(ret), single.test), single.consequent[0]));\n      } else {\n        if (this.loop) {\n          for (let i = 0; i < cases.length; i++) {\n            const caseConsequent = cases[i].consequent[0];\n\n            if (_core.types.isBreakStatement(caseConsequent) && !caseConsequent.label) {\n              if (!this.loopLabel) {\n                this.loopLabel = this.scope.generateUidIdentifier(\"loop\");\n              }\n\n              caseConsequent.label = _core.types.cloneNode(this.loopLabel);\n            }\n          }\n        }\n\n        body.push(_core.types.switchStatement(_core.types.identifier(ret), cases));\n      }\n    } else {\n      if (has.hasReturn) {\n        body.push(retCheck);\n      }\n    }\n  }\n\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitor = void 0;\n\nvar _core = require(\"@babel/core\");\n\nfunction getTDZStatus(refPath, bindingPath) {\n  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n\n  if (executionStatus === \"before\") {\n    return \"outside\";\n  } else if (executionStatus === \"after\") {\n    return \"inside\";\n  } else {\n    return \"maybe\";\n  }\n}\n\nfunction buildTDZAssert(node, state) {\n  return _core.types.callExpression(state.addHelper(\"temporalRef\"), [node, _core.types.stringLiteral(node.name)]);\n}\n\nfunction isReference(node, scope, state) {\n  const declared = state.letReferences[node.name];\n  if (!declared) return false;\n  return scope.getBindingIdentifier(node.name) === declared;\n}\n\nconst visitor = {\n  ReferencedIdentifier(path, state) {\n    if (!state.tdzEnabled) return;\n    const {\n      node,\n      parent,\n      scope\n    } = path;\n    if (path.parentPath.isFor({\n      left: node\n    })) return;\n    if (!isReference(node, scope, state)) return;\n    const bindingPath = scope.getBinding(node.name).path;\n    if (bindingPath.isFunctionDeclaration()) return;\n    const status = getTDZStatus(path, bindingPath);\n    if (status === \"outside\") return;\n\n    if (status === \"maybe\") {\n      const assert = buildTDZAssert(node, state);\n      bindingPath.parent._tdzThis = true;\n      path.skip();\n\n      if (path.parentPath.isUpdateExpression()) {\n        if (parent._ignoreBlockScopingTDZ) return;\n        path.parentPath.replaceWith(_core.types.sequenceExpression([assert, parent]));\n      } else {\n        path.replaceWith(assert);\n      }\n    } else if (status === \"inside\") {\n      path.replaceWith(_core.template.ast`${state.addHelper(\"tdz\")}(\"${node.name}\")`);\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path, state) {\n      if (!state.tdzEnabled) return;\n      const {\n        node\n      } = path;\n      if (node._ignoreBlockScopingTDZ) return;\n      const nodes = [];\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        const id = ids[name];\n\n        if (isReference(id, path.scope, state)) {\n          nodes.push(id);\n        }\n      }\n\n      if (nodes.length) {\n        node._ignoreBlockScopingTDZ = true;\n        nodes.push(node);\n        path.replaceWithMultiple(nodes.map(n => _core.types.expressionStatement(n)));\n      }\n    }\n\n  }\n};\nexports.visitor = visitor;"]}